"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base = void 0;
const keyring_1 = require("@polkadot/keyring");
const util_1 = require("@polkadot/util");
const accounts_js_1 = require("./observable/accounts.js");
const addresses_js_1 = require("./observable/addresses.js");
const contracts_js_1 = require("./observable/contracts.js");
const env_js_1 = require("./observable/env.js");
const Browser_js_1 = require("./stores/Browser.js"); // direct import (skip index with all)
class Base {
    #accounts;
    #addresses;
    #contracts;
    #isEthereum;
    #keyring;
    _store;
    _genesisHash;
    _genesisHashAdd = [];
    constructor() {
        this.#accounts = accounts_js_1.accounts;
        this.#addresses = addresses_js_1.addresses;
        this.#contracts = contracts_js_1.contracts;
        this.#isEthereum = false;
        this._store = new Browser_js_1.BrowserStore();
    }
    get accounts() {
        return this.#accounts;
    }
    get addresses() {
        return this.#addresses;
    }
    get contracts() {
        return this.#contracts;
    }
    get isEthereum() {
        return this.#isEthereum;
    }
    get keyring() {
        if (this.#keyring) {
            return this.#keyring;
        }
        throw new Error('Keyring should be initialised via \'loadAll\' before use');
    }
    get genesisHash() {
        return this._genesisHash;
    }
    get genesisHashes() {
        return this._genesisHash
            ? [this._genesisHash, ...this._genesisHashAdd]
            : [...this._genesisHashAdd];
    }
    decodeAddress = (key, ignoreChecksum, ss58Format) => {
        return this.keyring.decodeAddress(key, ignoreChecksum, ss58Format);
    };
    encodeAddress = (key, ss58Format) => {
        return this.keyring.encodeAddress(key, ss58Format);
    };
    getPair(address) {
        return this.keyring.getPair(address);
    }
    getPairs() {
        return this.keyring.getPairs().filter((pair) => env_js_1.env.isDevelopment() || pair.meta.isTesting !== true);
    }
    isAvailable(_address) {
        const accountsValue = this.accounts.subject.getValue();
        const addressesValue = this.addresses.subject.getValue();
        const contractsValue = this.contracts.subject.getValue();
        const address = (0, util_1.isString)(_address)
            ? _address
            : this.encodeAddress(_address);
        return !accountsValue[address] && !addressesValue[address] && !contractsValue[address];
    }
    isPassValid(password) {
        return password.length > 0;
    }
    setSS58Format(ss58Format) {
        if (this.#keyring && (0, util_1.isNumber)(ss58Format)) {
            this.#keyring.setSS58Format(ss58Format);
        }
    }
    setDevMode(isDevelopment) {
        env_js_1.env.set(isDevelopment);
    }
    initKeyring(options) {
        const keyring = (0, keyring_1.createTestKeyring)(options, true);
        if ((0, util_1.isBoolean)(options.isDevelopment)) {
            this.setDevMode(options.isDevelopment);
        }
        // set Ethereum state
        this.#isEthereum = keyring.type === 'ethereum';
        this.#keyring = keyring;
        this._genesisHash = options.genesisHash && ((0, util_1.isString)(options.genesisHash)
            ? options.genesisHash.toString()
            : options.genesisHash.toHex());
        this._genesisHashAdd = options.genesisHashAdd || [];
        this._store = options.store || this._store;
        this.addAccountPairs();
    }
    addAccountPairs() {
        this.keyring
            .getPairs()
            .forEach(({ address, meta }) => {
            this.accounts.add(this._store, address, { address, meta });
        });
    }
    addTimestamp(pair) {
        if (!pair.meta.whenCreated) {
            pair.setMeta({ whenCreated: Date.now() });
        }
    }
}
exports.Base = Base;
