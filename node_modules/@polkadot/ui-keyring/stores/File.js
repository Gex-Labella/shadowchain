import { mkdirpSync } from 'mkdirp';
import fs from 'node:fs';
import path from 'node:path';
export class FileStore {
    #path;
    constructor(path) {
        if (!fs.existsSync(path)) {
            mkdirpSync(path);
        }
        this.#path = path;
    }
    validateKey(key) {
        // Make sure the key has a .json extension
        if (!key.endsWith('.json')) {
            console.error('Non-JSON file requested: ', key);
            return false;
        }
        // Remove '.json'
        const keyWithoutExtension = key.slice(0, -5);
        // Only allow alphanumeric characters, hyphens, and underscores in the base filename
        const safeKeyRegex = /^[a-zA-Z0-9_-]+$/;
        if (!safeKeyRegex.test(keyWithoutExtension)) {
            console.error('Invalid key format detected: ', key);
            return false;
        }
        return true;
    }
    all(fn) {
        fs
            .readdirSync(this.#path)
            .filter((key) => !['.', '..', '.DS_Store'].includes(key))
            .forEach((key) => {
            const value = this._readKey(key);
            value?.address && fn(key, value);
        });
    }
    get(key, fn) {
        const value = this._readKey(key);
        if (!value?.address) {
            throw new Error(`Invalid JSON found for ${key}`);
        }
        fn(value);
    }
    remove(key, fn) {
        fs.unlinkSync(this._getPath(key));
        fn && fn();
    }
    set(key, value, fn) {
        fs.writeFileSync(this._getPath(key), Buffer.from(JSON.stringify(value), 'utf-8'));
        fn && fn();
    }
    _getPath(key) {
        if (!this.validateKey(key)) {
            throw new Error('Invalid key format');
        }
        return path.join(this.#path, key);
    }
    _readKey(key) {
        try {
            return JSON.parse(fs.readFileSync(this._getPath(key)).toString('utf-8'));
        }
        catch (error) {
            console.error(error);
        }
        return undefined;
    }
}
