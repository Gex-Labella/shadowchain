{"ast":null,"code":"export function typeSplit(type) {\n  const result = [];\n  // these are the depths of the various tokens: <, [, {, (\n  let c = 0;\n  let f = 0;\n  let s = 0;\n  let t = 0;\n  // current start position\n  let start = 0;\n  for (let i = 0, count = type.length; i < count; i++) {\n    switch (type[i]) {\n      // if we are not nested, add the type\n      case ',':\n        {\n          if (!(c || f || s || t)) {\n            result.push(type.substring(start, i).trim());\n            start = i + 1;\n          }\n          break;\n        }\n      // adjust compact/vec (and friends) depth\n      case '<':\n        c++;\n        break;\n      case '>':\n        c--;\n        break;\n      // adjust fixed vec depths\n      case '[':\n        f++;\n        break;\n      case ']':\n        f--;\n        break;\n      // adjust struct depth\n      case '{':\n        s++;\n        break;\n      case '}':\n        s--;\n        break;\n      // adjust tuple depth\n      case '(':\n        t++;\n        break;\n      case ')':\n        t--;\n        break;\n    }\n  }\n  // ensure we have all the terminators taken care of\n  if (c || f || s || t) {\n    throw new Error(`Invalid definition (missing terminators) found in ${type}`);\n  }\n  // the final leg of the journey\n  result.push(type.substring(start, type.length).trim());\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}