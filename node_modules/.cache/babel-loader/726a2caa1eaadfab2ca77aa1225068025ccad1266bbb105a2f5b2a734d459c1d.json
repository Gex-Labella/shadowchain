{"ast":null,"code":"import { Enum } from '@polkadot/types-codec';\nimport { isString, isU8a, u8aToU8a } from '@polkadot/util';\n/** @internal */\nfunction decodeDataU8a(registry, value) {\n  const indicator = value[0];\n  if (!indicator) {\n    return [undefined, undefined];\n  } else if (indicator >= 1 && indicator <= 33) {\n    const length = indicator - 1;\n    const data = value.subarray(1, length + 1);\n    // in this case, we are passing a Raw back (since we have no length)\n    return [registry.createTypeUnsafe('Raw', [data]), 1];\n  } else if (indicator >= 34 && indicator <= 37) {\n    return [value.subarray(1, 32 + 1), indicator - 32]; // 34 becomes 2\n  }\n  throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);\n}\n/** @internal */\nfunction decodeData(registry, value) {\n  if (isU8a(value) || isString(value)) {\n    return decodeDataU8a(registry, u8aToU8a(value));\n  } else if (!value) {\n    return [undefined, undefined];\n  }\n  // assume we have an Enum or an  object input, handle this via the normal Enum decoding\n  return [value, undefined];\n}\n/**\n * @name Data\n * @description\n * A [[Data]] container with node, raw or hashed data\n */\nexport class Data extends Enum {\n  constructor(registry, value) {\n    super(registry, {\n      None: 'Null',\n      // 0\n      Raw: 'Bytes',\n      // 1\n      // eslint-disable-next-line sort-keys\n      BlakeTwo256: 'H256',\n      // 2\n      Sha256: 'H256',\n      // 3\n      // eslint-disable-next-line sort-keys\n      Keccak256: 'H256',\n      // 4\n      ShaThree256: 'H256' // 5\n    }, ...decodeData(registry, value));\n    if (this.isRaw && this.asRaw.length > 32) {\n      throw new Error('Data.Raw values are limited to a maximum length of 32 bytes');\n    }\n  }\n  get asBlakeTwo256() {\n    return this.value;\n  }\n  get asKeccak256() {\n    return this.value;\n  }\n  get asRaw() {\n    return this.value;\n  }\n  get asSha256() {\n    return this.value;\n  }\n  get asShaThree256() {\n    return this.value;\n  }\n  get isBlakeTwo256() {\n    return this.index === 2;\n  }\n  get isKeccak256() {\n    return this.index === 4;\n  }\n  get isNone() {\n    return this.index === 0;\n  }\n  get isRaw() {\n    return this.index === 1;\n  }\n  get isSha256() {\n    return this.index === 3;\n  }\n  get isShaThree256() {\n    return this.index === 5;\n  }\n  /**\n   * @description The encoded length\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a() {\n    if (this.index === 0) {\n      return new Uint8Array(1);\n    } else if (this.index === 1) {\n      // don't add the length, just the data\n      const data = this.value.toU8a(true);\n      const length = Math.min(data.length, 32);\n      const u8a = new Uint8Array(length + 1);\n      u8a.set([length + 1], 0);\n      u8a.set(data.subarray(0, length), 1);\n      return u8a;\n    }\n    // otherwise we simply have a hash\n    const u8a = new Uint8Array(33);\n    u8a.set([this.index + 32], 0);\n    u8a.set(this.value.toU8a(), 1);\n    return u8a;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}