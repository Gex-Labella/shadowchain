{"ast":null,"code":"import { stringify } from '@polkadot/util';\n/*\n * Creates a new health checker.\n *\n * The role of the health checker is to report to the user the health of a smoldot chain.\n *\n * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the\n * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use\n * `start()` in order to start the health checks. The `start()` function must be passed a callback called\n * when an update to the health of the node is available.\n *\n * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function\n * of the health checker. The health checker rewrites the `id` of the requests it receives.\n *\n * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This\n * function intercepts the responses destined to the requests that have been emitted by the health\n * checker and returns `null`. If the response doesn't concern the health checker, the response is\n * simply returned by the function.\n *\n * # How it works\n *\n * The health checker periodically calls the `system_health` JSON-RPC call in order to determine\n * the health of the chain.\n *\n * In addition to this, as long as the health check reports that `isSyncing` is `true`, the\n * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.\n * Whenever a new block is notified, a health check is performed immediately in order to determine\n * whether `isSyncing` has changed to `false`.\n *\n * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to\n * `isSyncing: false` is very low.\n *\n */\nexport function healthChecker() {\n  // `null` if health checker is not started.\n  let checker = null;\n  let sendJsonRpc = null;\n  return {\n    responsePassThrough: jsonRpcResponse => {\n      if (checker === null) {\n        return jsonRpcResponse;\n      }\n      return checker.responsePassThrough(jsonRpcResponse);\n    },\n    sendJsonRpc: request => {\n      if (!sendJsonRpc) {\n        throw new Error('setSendJsonRpc must be called before sending requests');\n      }\n      if (checker === null) {\n        sendJsonRpc(request);\n      } else {\n        checker.sendJsonRpc(request);\n      }\n    },\n    setSendJsonRpc: cb => {\n      sendJsonRpc = cb;\n    },\n    start: healthCallback => {\n      if (checker !== null) {\n        throw new Error(\"Can't start the health checker multiple times in parallel\");\n      } else if (!sendJsonRpc) {\n        throw new Error('setSendJsonRpc must be called before starting the health checks');\n      }\n      checker = new InnerChecker(healthCallback, sendJsonRpc);\n      checker.update(true);\n    },\n    stop: () => {\n      if (checker === null) {\n        return;\n      } // Already stopped.\n      checker.destroy();\n      checker = null;\n    }\n  };\n}\nclass InnerChecker {\n  __internal__healthCallback;\n  __internal__currentHealthCheckId = null;\n  __internal__currentHealthTimeout = null;\n  __internal__currentSubunsubRequestId = null;\n  __internal__currentSubscriptionId = null;\n  __internal__requestToSmoldot;\n  __internal__isSyncing = false;\n  __internal__nextRequestId = 0;\n  constructor(healthCallback, requestToSmoldot) {\n    this.__internal__healthCallback = healthCallback;\n    this.__internal__requestToSmoldot = request => requestToSmoldot(stringify(request));\n  }\n  sendJsonRpc = request => {\n    // Replace the `id` in the request to prefix the request ID with `extern:`.\n    let parsedRequest;\n    try {\n      parsedRequest = JSON.parse(request);\n    } catch {\n      return;\n    }\n    if (parsedRequest.id) {\n      const newId = 'extern:' + stringify(parsedRequest.id);\n      parsedRequest.id = newId;\n    }\n    this.__internal__requestToSmoldot(parsedRequest);\n  };\n  responsePassThrough = jsonRpcResponse => {\n    let parsedResponse;\n    try {\n      parsedResponse = JSON.parse(jsonRpcResponse);\n    } catch {\n      return jsonRpcResponse;\n    }\n    // Check whether response is a response to `system_health`.\n    if (parsedResponse.id && this.__internal__currentHealthCheckId === parsedResponse.id) {\n      this.__internal__currentHealthCheckId = null;\n      // Check whether query was successful. It is possible for queries to fail for\n      // various reasons, such as the client being overloaded.\n      if (!parsedResponse.result) {\n        this.update(false);\n        return null;\n      }\n      this.__internal__healthCallback(parsedResponse.result);\n      this.__internal__isSyncing = parsedResponse.result.isSyncing;\n      this.update(false);\n      return null;\n    }\n    // Check whether response is a response to the subscription or unsubscription.\n    if (parsedResponse.id && this.__internal__currentSubunsubRequestId === parsedResponse.id) {\n      this.__internal__currentSubunsubRequestId = null;\n      // Check whether query was successful. It is possible for queries to fail for\n      // various reasons, such as the client being overloaded.\n      if (!parsedResponse.result) {\n        this.update(false);\n        return null;\n      }\n      if (this.__internal__currentSubscriptionId) {\n        this.__internal__currentSubscriptionId = null;\n      } else {\n        this.__internal__currentSubscriptionId = parsedResponse.result;\n      }\n      this.update(false);\n      return null;\n    }\n    // Check whether response is a notification to a subscription.\n    if (parsedResponse.params && this.__internal__currentSubscriptionId && parsedResponse.params.subscription === this.__internal__currentSubscriptionId) {\n      // Note that after a successful subscription, a notification containing\n      // the current best block is always returned. Considering that a\n      // subscription is performed in response to a health check, calling\n      // `startHealthCheck()` here will lead to a second health check.\n      // It might seem redundant to perform two health checks in a quick\n      // succession, but doing so doesn't lead to any problem, and it is\n      // actually possible for the health to have changed in between as the\n      // current best block might have been updated during the subscription\n      // request.\n      this.update(true);\n      return null;\n    }\n    // Response doesn't concern us.\n    if (parsedResponse.id) {\n      const id = parsedResponse.id;\n      // Need to remove the `extern:` prefix.\n      if (!id.startsWith('extern:')) {\n        throw new Error('State inconsistency in health checker');\n      }\n      const newId = JSON.parse(id.slice('extern:'.length));\n      parsedResponse.id = newId;\n    }\n    return stringify(parsedResponse);\n  };\n  update = startNow => {\n    // If `startNow`, clear `#currentHealthTimeout` so that it is set below.\n    if (startNow && this.__internal__currentHealthTimeout) {\n      clearTimeout(this.__internal__currentHealthTimeout);\n      this.__internal__currentHealthTimeout = null;\n    }\n    if (!this.__internal__currentHealthTimeout) {\n      const startHealthRequest = () => {\n        this.__internal__currentHealthTimeout = null;\n        // No matter what, don't start a health request if there is already one in progress.\n        // This is sane to do because receiving a response to a health request calls `update()`.\n        if (this.__internal__currentHealthCheckId) {\n          return;\n        }\n        // Actual request starting.\n        this.__internal__currentHealthCheckId = `health-checker:${this.__internal__nextRequestId}`;\n        this.__internal__nextRequestId += 1;\n        this.__internal__requestToSmoldot({\n          id: this.__internal__currentHealthCheckId,\n          jsonrpc: '2.0',\n          method: 'system_health',\n          params: []\n        });\n      };\n      if (startNow) {\n        startHealthRequest();\n      } else {\n        this.__internal__currentHealthTimeout = setTimeout(startHealthRequest, 1000);\n      }\n    }\n    if (this.__internal__isSyncing && !this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {\n      this.startSubscription();\n    }\n    if (!this.__internal__isSyncing && this.__internal__currentSubscriptionId && !this.__internal__currentSubunsubRequestId) {\n      this.endSubscription();\n    }\n  };\n  startSubscription = () => {\n    if (this.__internal__currentSubunsubRequestId || this.__internal__currentSubscriptionId) {\n      throw new Error('Internal error in health checker');\n    }\n    this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n    this.__internal__nextRequestId += 1;\n    this.__internal__requestToSmoldot({\n      id: this.__internal__currentSubunsubRequestId,\n      jsonrpc: '2.0',\n      method: 'chain_subscribeNewHeads',\n      params: []\n    });\n  };\n  endSubscription = () => {\n    if (this.__internal__currentSubunsubRequestId || !this.__internal__currentSubscriptionId) {\n      throw new Error('Internal error in health checker');\n    }\n    this.__internal__currentSubunsubRequestId = `health-checker:${this.__internal__nextRequestId}`;\n    this.__internal__nextRequestId += 1;\n    this.__internal__requestToSmoldot({\n      id: this.__internal__currentSubunsubRequestId,\n      jsonrpc: '2.0',\n      method: 'chain_unsubscribeNewHeads',\n      params: [this.__internal__currentSubscriptionId]\n    });\n  };\n  destroy = () => {\n    if (this.__internal__currentHealthTimeout) {\n      clearTimeout(this.__internal__currentHealthTimeout);\n      this.__internal__currentHealthTimeout = null;\n    }\n  };\n}\nexport class HealthCheckError extends Error {\n  __internal__cause;\n  getCause() {\n    return this.__internal__cause;\n  }\n  constructor(response, message = 'Got error response asking for system health') {\n    super(message);\n    this.__internal__cause = response;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}