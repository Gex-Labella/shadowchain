{"ast":null,"code":"import { compactToU8a, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { compareArray } from '../utils/compareArray.js';\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\nexport class AbstractArray extends Array {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  /**\n   * @description This ensures that operators such as clice, filter, map, etc. return\n   * new Array instances (without this we need to apply overrides)\n   */\n  static get [Symbol.species]() {\n    return Array;\n  }\n  constructor(registry, length) {\n    super(length);\n    this.registry = registry;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    // We need to loop through all entries since they may have a variable length themselves,\n    // e.g. when a Vec or Compact is contained withing, it has a variable length based on data\n    const count = this.length;\n    let total = compactToU8a(count).length;\n    for (let i = 0; i < count; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareArray(this, other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner(),\n      outer: [compactToU8a(this.length)]\n    };\n  }\n  /**\n   * @internal\n   * @description Internal per-item inspection of internal values\n   */\n  inspectInner() {\n    const count = this.length;\n    const inner = new Array(count);\n    for (let i = 0; i < count; i++) {\n      inner[i] = this[i].inspect();\n    }\n    return inner;\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n  toArray() {\n    return Array.from(this);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      result[i] = this[i] && this[i].toHuman(isExtended, disableAscii);\n    }\n    return result;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      // We actually log inside the U8a decoding and use JSON.stringify(...), which\n      // means that the Vec may be partially populated (same applies to toHuman, same check)\n      result[i] = this[i] && this[i].toJSON();\n    }\n    return result;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      result[i] = this[i] && this[i].toPrimitive(disableAscii);\n    }\n    return result;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    const count = this.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n      result[i] = this[i].toString();\n    }\n    return `[${result.join(', ')}]`;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = this.toU8aInner();\n    return isBare ? u8aConcatStrict(encoded) : u8aConcatStrict([compactToU8a(this.length), ...encoded]);\n  }\n  /**\n   * @internal\n   * @description Internal per-item SCALE encoding of contained values\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8aInner(isBare) {\n    const count = this.length;\n    const encoded = new Array(count);\n    for (let i = 0; i < count; i++) {\n      encoded[i] = this[i].toU8a(isBare);\n    }\n    return encoded;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}