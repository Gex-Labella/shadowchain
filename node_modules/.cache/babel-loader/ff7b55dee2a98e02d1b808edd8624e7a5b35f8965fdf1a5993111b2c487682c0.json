{"ast":null,"code":"/** @internal */\nexport const SI_MID = 8;\n/** @internal */\nexport const SI = [{\n  power: -24,\n  text: 'yocto',\n  value: 'y'\n}, {\n  power: -21,\n  text: 'zepto',\n  value: 'z'\n}, {\n  power: -18,\n  text: 'atto',\n  value: 'a'\n}, {\n  power: -15,\n  text: 'femto',\n  value: 'f'\n}, {\n  power: -12,\n  text: 'pico',\n  value: 'p'\n}, {\n  power: -9,\n  text: 'nano',\n  value: 'n'\n}, {\n  power: -6,\n  text: 'micro',\n  value: 'Âµ'\n}, {\n  power: -3,\n  text: 'milli',\n  value: 'm'\n}, {\n  power: 0,\n  text: 'Unit',\n  value: '-'\n},\n// position 8\n{\n  power: 3,\n  text: 'Kilo',\n  value: 'k'\n}, {\n  power: 6,\n  text: 'Mill',\n  value: 'M'\n},\n// Mega, M\n{\n  power: 9,\n  text: 'Bill',\n  value: 'B'\n},\n// Giga, G\n{\n  power: 12,\n  text: 'Tril',\n  value: 'T'\n},\n// Tera, T\n{\n  power: 15,\n  text: 'Peta',\n  value: 'P'\n}, {\n  power: 18,\n  text: 'Exa',\n  value: 'E'\n}, {\n  power: 21,\n  text: 'Zeta',\n  value: 'Z'\n}, {\n  power: 24,\n  text: 'Yotta',\n  value: 'Y'\n}];\n/** @internal */\nexport function findSi(type) {\n  // use a loop here, better RN support (which doesn't have [].find)\n  for (let i = 0, count = SI.length; i < count; i++) {\n    if (SI[i].value === type) {\n      return SI[i];\n    }\n  }\n  return SI[SI_MID];\n}\n/** @internal */\nexport function calcSi(text, decimals, forceUnit) {\n  if (forceUnit) {\n    return findSi(forceUnit);\n  }\n  const siDefIndex = SI_MID - 1 + Math.ceil((text.length - decimals) / 3);\n  return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}