{"ast":null,"code":"/* eslint-disable brace-style,camelcase,comma-spacing,curly,one-var,padding-line-between-statements,space-infix-ops */\nfunction L32(x, c) {\n  return x << c | x >>> 32 - c;\n}\nfunction ld32(x, i) {\n  let u = x[i + 3] & 0xff;\n  u = u << 8 | x[i + 2] & 0xff;\n  u = u << 8 | x[i + 1] & 0xff;\n  return u << 8 | x[i + 0] & 0xff;\n}\nfunction st32(x, j, u) {\n  for (let i = 0; i < 4; i++) {\n    x[j + i] = u & 255;\n    u >>>= 8;\n  }\n}\nfunction vn(x, xi, y, yi, n) {\n  let d = 0;\n  for (let i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];\n  return (1 & d - 1 >>> 8) - 1;\n}\nfunction core(out, inp, k, c, h) {\n  const w = new Uint32Array(16),\n    x = new Uint32Array(16),\n    y = new Uint32Array(16),\n    t = new Uint32Array(4);\n  let i, j, m;\n  for (i = 0; i < 4; i++) {\n    x[5 * i] = ld32(c, 4 * i);\n    x[1 + i] = ld32(k, 4 * i);\n    x[6 + i] = ld32(inp, 4 * i);\n    x[11 + i] = ld32(k, 16 + 4 * i);\n  }\n  for (i = 0; i < 16; i++) y[i] = x[i];\n  for (i = 0; i < 20; i++) {\n    for (j = 0; j < 4; j++) {\n      for (m = 0; m < 4; m++) t[m] = x[(5 * j + 4 * m) % 16];\n      t[1] ^= L32(t[0] + t[3] | 0, 7);\n      t[2] ^= L32(t[1] + t[0] | 0, 9);\n      t[3] ^= L32(t[2] + t[1] | 0, 13);\n      t[0] ^= L32(t[3] + t[2] | 0, 18);\n      for (m = 0; m < 4; m++) w[4 * j + (j + m) % 4] = t[m];\n    }\n    for (m = 0; m < 16; m++) x[m] = w[m];\n  }\n  if (h) {\n    for (i = 0; i < 16; i++) x[i] = x[i] + y[i] | 0;\n    for (i = 0; i < 4; i++) {\n      x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;\n      x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;\n    }\n    for (i = 0; i < 4; i++) {\n      st32(out, 4 * i, x[5 * i]);\n      st32(out, 16 + 4 * i, x[6 + i]);\n    }\n  } else {\n    for (i = 0; i < 16; i++) st32(out, 4 * i, x[i] + y[i] | 0);\n  }\n}\nconst sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\nfunction crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n  const z = new Uint8Array(16),\n    x = new Uint8Array(64);\n  let u, i;\n  if (!b) return 0;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    core(x, z, k, sigma, false);\n    for (i = 0; i < 64; i++) c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    if (m) mpos += 64;\n  }\n  if (b > 0) {\n    core(x, z, k, sigma, false);\n    for (i = 0; i < b; i++) c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n  }\n  return 0;\n}\nfunction crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n  const s = new Uint8Array(32);\n  core(s, n, k, sigma, true);\n  return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n}\nfunction add1305(h, c) {\n  let u = 0;\n  for (let j = 0; j < 17; j++) {\n    u = u + (h[j] + c[j] | 0) | 0;\n    h[j] = u & 255;\n    u >>>= 8;\n  }\n}\nconst minusp = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  let i, j, u;\n  const x = new Uint32Array(17),\n    r = new Uint32Array(17),\n    h = new Uint32Array(17),\n    c = new Uint32Array(17),\n    g = new Uint32Array(17);\n  for (j = 0; j < 17; j++) r[j] = h[j] = 0;\n  for (j = 0; j < 16; j++) r[j] = k[j];\n  r[3] &= 15;\n  r[4] &= 252;\n  r[7] &= 15;\n  r[8] &= 252;\n  r[11] &= 15;\n  r[12] &= 252;\n  r[15] &= 15;\n  while (n > 0) {\n    for (j = 0; j < 17; j++) c[j] = 0;\n    for (j = 0; j < 16 && j < n; ++j) c[j] = m[mpos + j];\n    c[j] = 1;\n    mpos += j;\n    n -= j;\n    add1305(h, c);\n    for (i = 0; i < 17; i++) {\n      x[i] = 0;\n      for (j = 0; j < 17; j++) x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;\n    }\n    for (i = 0; i < 17; i++) h[i] = x[i];\n    u = 0;\n    for (j = 0; j < 16; j++) {\n      u = u + h[j] | 0;\n      h[j] = u & 255;\n      u >>>= 8;\n    }\n    u = u + h[16] | 0;\n    h[16] = u & 3;\n    u = 5 * (u >>> 2) | 0;\n    for (j = 0; j < 16; j++) {\n      u = u + h[j] | 0;\n      h[j] = u & 255;\n      u >>>= 8;\n    }\n    u = u + h[16] | 0;\n    h[16] = u;\n  }\n  for (j = 0; j < 17; j++) g[j] = h[j];\n  add1305(h, minusp);\n  const s = -(h[16] >>> 7) | 0;\n  for (j = 0; j < 17; j++) h[j] ^= s & (g[j] ^ h[j]);\n  for (j = 0; j < 16; j++) c[j] = k[j + 16];\n  c[16] = 0;\n  add1305(h, c);\n  for (j = 0; j < 16; j++) out[outpos + j] = h[j];\n  return 0;\n}\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  const x = new Uint8Array(16);\n  crypto_onetimeauth(x, 0, m, mpos, n, k);\n  return vn(h, hpos, x, 0, 16);\n}\nfunction crypto_secretbox(c, m, d, n, k) {\n  if (d < 32) return -1;\n  crypto_stream_xor(c, 0, m, 0, d, n, k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (let i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\nfunction crypto_secretbox_open(m, c, d, n, k) {\n  const x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream_xor(x, 0, null, 0, 32, n, k);\n  if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n  crypto_stream_xor(m, 0, c, 0, d, n, k);\n  for (let i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\nconst crypto_secretbox_KEYBYTES = 32;\nconst crypto_secretbox_NONCEBYTES = 24;\nconst crypto_secretbox_ZEROBYTES = 32;\nconst crypto_secretbox_BOXZEROBYTES = 16;\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\nfunction checkArrayTypes(...args) {\n  for (let i = 0, count = args.length; i < count; i++) {\n    if (!(args[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');\n  }\n}\nexport function naclSecretbox(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  const m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  const c = new Uint8Array(m.length);\n  for (let i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n}\nexport function naclSecretboxOpen(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  const c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  const m = new Uint8Array(c.length);\n  for (let i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return null;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}