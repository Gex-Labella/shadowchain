{"ast":null,"code":"import { _0n, BN, bnToU8a, hasBigInt, isU8a, nToU8a, u8aToBigInt } from '@polkadot/util';\nimport { BigInt } from '@polkadot/x-bigint';\nimport { BN_BE_256_OPTS, BN_BE_OPTS } from '../bn.js';\nconst N = 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141'.replace(/ /g, '');\nconst N_BI = BigInt(`0x${N}`);\nconst N_BN = new BN(N, 'hex');\nfunction addBi(seckey, tweak) {\n  let res = u8aToBigInt(tweak, BN_BE_OPTS);\n  if (res >= N_BI) {\n    throw new Error('Tweak parameter is out of range');\n  }\n  res += u8aToBigInt(seckey, BN_BE_OPTS);\n  if (res >= N_BI) {\n    res -= N_BI;\n  }\n  if (res === _0n) {\n    throw new Error('Invalid resulting private key');\n  }\n  return nToU8a(res, BN_BE_256_OPTS);\n}\nfunction addBn(seckey, tweak) {\n  const res = new BN(tweak);\n  if (res.cmp(N_BN) >= 0) {\n    throw new Error('Tweak parameter is out of range');\n  }\n  res.iadd(new BN(seckey));\n  if (res.cmp(N_BN) >= 0) {\n    res.isub(N_BN);\n  }\n  if (res.isZero()) {\n    throw new Error('Invalid resulting private key');\n  }\n  return bnToU8a(res, BN_BE_256_OPTS);\n}\nexport function secp256k1PrivateKeyTweakAdd(seckey, tweak, onlyBn) {\n  if (!isU8a(seckey) || seckey.length !== 32) {\n    throw new Error('Expected seckey to be an Uint8Array with length 32');\n  } else if (!isU8a(tweak) || tweak.length !== 32) {\n    throw new Error('Expected tweak to be an Uint8Array with length 32');\n  }\n  return !hasBigInt || onlyBn ? addBn(seckey, tweak) : addBi(seckey, tweak);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}