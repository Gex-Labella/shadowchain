{"ast":null,"code":"import { u8aIsWrapped, u8aToU8a, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nimport { decodeAddress } from '../address/decode.js';\nimport { ed25519Verify } from '../ed25519/verify.js';\nimport { secp256k1Verify } from '../secp256k1/verify.js';\nimport { sr25519Verify } from '../sr25519/verify.js';\nconst secp256k1VerifyHasher = hashType => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType, true);\nconst VERIFIERS_ECDSA = [['ecdsa', secp256k1VerifyHasher('blake2')], ['ethereum', secp256k1VerifyHasher('keccak')]];\nconst VERIFIERS = [['ed25519', ed25519Verify], ['sr25519', sr25519Verify]];\nfunction verifyDetect(result, {\n  message,\n  publicKey,\n  signature\n}, verifiers = [...VERIFIERS, ...VERIFIERS_ECDSA]) {\n  result.isValid = verifiers.some(([crypto, verify]) => {\n    try {\n      if (verify(message, signature, publicKey)) {\n        result.crypto = crypto;\n        return true;\n      }\n    } catch {\n      // do nothing, result.isValid still set to false\n    }\n    return false;\n  });\n  return result;\n}\nfunction verifyMultisig(result, {\n  message,\n  publicKey,\n  signature\n}) {\n  if (![0, 1, 2].includes(signature[0]) || ![65, 66].includes(signature.length)) {\n    throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);\n  }\n  // If the signature is 66 bytes it must be an ecdsa signature\n  // containing: prefix [1 byte] + signature [65] bytes.\n  // Remove the and then verify\n  if (signature.length === 66) {\n    result = verifyDetect(result, {\n      message,\n      publicKey,\n      signature: signature.subarray(1)\n    }, VERIFIERS_ECDSA);\n  } else {\n    // The signature contains 65 bytes which is either\n    // - A ed25519 or sr25519 signature [1 byte prefix + 64 bytes]\n    // - An ecdsa signature [65 bytes]\n    result = verifyDetect(result, {\n      message,\n      publicKey,\n      signature: signature.subarray(1)\n    }, VERIFIERS);\n    if (!result.isValid) {\n      result = verifyDetect(result, {\n        message,\n        publicKey,\n        signature\n      }, VERIFIERS_ECDSA);\n    }\n    // If both failed, explicitly set crypto to 'none'\n    if (!result.isValid) {\n      result.crypto = 'none';\n    }\n  }\n  return result;\n}\nfunction getVerifyFn(signature) {\n  return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;\n}\nexport function signatureVerify(message, signature, addressOrPublicKey) {\n  const signatureU8a = u8aToU8a(signature);\n  if (![64, 65, 66].includes(signatureU8a.length)) {\n    throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);\n  }\n  const publicKey = decodeAddress(addressOrPublicKey);\n  const input = {\n    message: u8aToU8a(message),\n    publicKey,\n    signature: signatureU8a\n  };\n  const result = {\n    crypto: 'none',\n    isValid: false,\n    isWrapped: u8aIsWrapped(input.message, true),\n    publicKey\n  };\n  const isWrappedBytes = u8aIsWrapped(input.message, false);\n  const verifyFn = getVerifyFn(signatureU8a);\n  verifyFn(result, input);\n  if (result.crypto !== 'none' || result.isWrapped && !isWrappedBytes) {\n    return result;\n  }\n  input.message = isWrappedBytes ? u8aUnwrapBytes(input.message) : u8aWrapBytes(input.message);\n  return verifyFn(result, input);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}