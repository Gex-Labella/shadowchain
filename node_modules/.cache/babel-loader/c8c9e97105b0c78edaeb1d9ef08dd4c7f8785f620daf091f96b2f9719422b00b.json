{"ast":null,"code":"import { isAscii, isUndefined, isUtf8, u8aToHex, u8aToString, u8aToU8a } from '@polkadot/util';\n/**\n * @name Raw\n * @description\n * A basic wrapper around Uint8Array, with no frills and no fuss. It does differ\n * from other implementations where it will consume the full Uint8Array as passed to it.\n * As such it is meant to be subclassed where the wrapper takes care of the\n * actual lengths instead of used directly.\n * @noInheritDoc\n */\nexport class Raw extends Uint8Array {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  /**\n   * @description This ensures that operators such as clice, filter, map, etc. return\n   * new Array instances (without this we need to apply overrides)\n   */\n  static get [Symbol.species]() {\n    return Uint8Array;\n  }\n  constructor(registry, value, initialU8aLength) {\n    super(u8aToU8a(value));\n    this.registry = registry;\n    this.initialU8aLength = initialU8aLength;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.length;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Returns true if the wrapped value contains only ASCII printable characters\n   */\n  get isAscii() {\n    return isAscii(this);\n  }\n  /**\n   * @description Returns true if the type wraps an empty/default all-0 value\n   */\n  get isEmpty() {\n    return !this.length || isUndefined(this.find(b => !!b));\n  }\n  /**\n   * @description Returns true if the wrapped value contains only utf8 characters\n   */\n  get isUtf8() {\n    return isUtf8(this);\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n  bitLength() {\n    return this.length * 8;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    if (other instanceof Uint8Array) {\n      return this.length === other.length && !this.some((b, index) => b !== other[index]);\n    }\n    return this.eq(u8aToU8a(other));\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [this.toU8a()]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this);\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(_isExtended, disableAscii) {\n    return this.toPrimitive(disableAscii);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    if (!disableAscii && this.isAscii) {\n      const text = this.toUtf8();\n      // ensure we didn't end up with multibyte codepoints\n      if (isAscii(text)) {\n        return text;\n      }\n    }\n    return this.toJSON();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Raw';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a(_isBare) {\n    return Uint8Array.from(this);\n  }\n  /**\n   * @description Returns the wrapped data as a UTF-8 string\n   */\n  toUtf8() {\n    if (!this.isUtf8) {\n      throw new Error('The character sequence is not a valid Utf8 string');\n    }\n    return u8aToString(this);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}