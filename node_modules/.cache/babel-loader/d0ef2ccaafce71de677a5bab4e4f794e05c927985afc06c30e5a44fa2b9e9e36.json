{"ast":null,"code":"import { BehaviorSubject, combineLatest, EMPTY, map, of, startWith, switchMap, tap, toArray } from 'rxjs';\nimport { arrayFlatten, isFunction, nextTick } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { extractContributed } from './util.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nfunction _getUpdates(api, paraId) {\n  let added = [];\n  let removed = [];\n  return api.query.system.events().pipe(switchMap(events => {\n    const changes = extractContributed(paraId, events);\n    if (changes.added.length || changes.removed.length) {\n      added = added.concat(...changes.added);\n      removed = removed.concat(...changes.removed);\n      return of({\n        added,\n        addedDelta: changes.added,\n        blockHash: events.createdAtHash?.toHex() || '-',\n        removed,\n        removedDelta: changes.removed\n      });\n    }\n    return EMPTY;\n  }), startWith({\n    added,\n    addedDelta: [],\n    blockHash: '-',\n    removed,\n    removedDelta: []\n  }));\n}\nfunction _eventTriggerAll(api, paraId) {\n  return api.query.system.events().pipe(switchMap(events => {\n    const items = events.filter(({\n      event: {\n        data: [eventParaId],\n        method,\n        section\n      }\n    }) => section === 'crowdloan' && ['AllRefunded', 'Dissolved', 'PartiallyRefunded'].includes(method) && eventParaId.eq(paraId));\n    return items.length ? of(events.createdAtHash?.toHex() || '-') : EMPTY;\n  }), startWith('-'));\n}\nfunction _getKeysPaged(api, childKey) {\n  const subject = new BehaviorSubject(undefined);\n  return subject.pipe(switchMap(startKey => api.rpc.childstate.getKeysPaged(childKey, '0x', PAGE_SIZE_K, startKey)), tap(keys => {\n    nextTick(() => {\n      keys.length === PAGE_SIZE_K ? subject.next(keys[PAGE_SIZE_K - 1].toHex()) : subject.complete();\n    });\n  }), toArray(),\n  // toArray since we want to startSubject to be completed\n  map(keyArr => arrayFlatten(keyArr)));\n}\nfunction _getAll(api, paraId, childKey) {\n  return _eventTriggerAll(api, paraId).pipe(switchMap(() => isFunction(api.rpc.childstate.getKeysPaged) ? _getKeysPaged(api, childKey) : api.rpc.childstate.getKeys(childKey, '0x')), map(keys => keys.map(k => k.toHex())));\n}\nfunction _contributions(api, paraId, childKey) {\n  return combineLatest([_getAll(api, paraId, childKey), _getUpdates(api, paraId)]).pipe(map(([keys, {\n    added,\n    blockHash,\n    removed\n  }]) => {\n    const contributorsMap = {};\n    keys.forEach(k => {\n      contributorsMap[k] = true;\n    });\n    added.forEach(k => {\n      contributorsMap[k] = true;\n    });\n    removed.forEach(k => {\n      delete contributorsMap[k];\n    });\n    return {\n      blockHash,\n      contributorsHex: Object.keys(contributorsMap)\n    };\n  }));\n}\nexport function contributions(instanceId, api) {\n  return memo(instanceId, paraId => api.derive.crowdloan.childKey(paraId).pipe(switchMap(childKey => childKey ? _contributions(api, paraId, childKey) : of({\n    blockHash: '-',\n    contributorsHex: []\n  }))));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}