{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isHex, u8aToString } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nconst UNDEF_HEX = {\n  toHex: () => undefined\n};\nfunction dataAsString(data) {\n  if (!data) {\n    return data;\n  }\n  return data.isRaw ? u8aToString(data.asRaw.toU8a(true)) : data.isNone ? undefined : data.toHex();\n}\nfunction extractOther(additional) {\n  return additional.reduce((other, [_key, _value]) => {\n    const key = dataAsString(_key);\n    const value = dataAsString(_value);\n    if (key && value) {\n      other[key] = value;\n    }\n    return other;\n  }, {});\n}\nfunction identityCompat(identityOfOpt) {\n  const identity = identityOfOpt.unwrap();\n  return Array.isArray(identity) ? identity[0] : identity;\n}\nfunction extractIdentity(identityOfOpt, superOf) {\n  if (!identityOfOpt?.isSome) {\n    return {\n      judgements: []\n    };\n  }\n  const {\n    info,\n    judgements\n  } = identityCompat(identityOfOpt);\n  const topDisplay = dataAsString(info.display);\n  return {\n    discord: dataAsString(info.discord),\n    display: superOf && dataAsString(superOf[1]) || topDisplay,\n    displayParent: superOf && topDisplay,\n    email: dataAsString(info.email),\n    github: dataAsString(info.github),\n    image: dataAsString(info.image),\n    judgements,\n    legal: dataAsString(info.legal),\n    matrix: dataAsString(info.matrix),\n    other: info.additional ? extractOther(info.additional) : {},\n    parent: superOf?.[0],\n    pgp: info.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),\n    riot: dataAsString(info.riot),\n    twitter: dataAsString(info.twitter),\n    web: dataAsString(info.web)\n  };\n}\nfunction getParent(api, identityOfOpt, superOfOpt) {\n  if (identityOfOpt?.isSome) {\n    // this identity has something set\n    return of([identityOfOpt, undefined]);\n  } else if (superOfOpt?.isSome) {\n    const superOf = superOfOpt.unwrap();\n    return combineLatest([api.derive.accounts._identity(superOf[0]).pipe(map(([info]) => info)), of(superOf)]);\n  }\n  // nothing of value returned\n  return of([undefined, undefined]);\n}\nexport function _identity(instanceId, api) {\n  return memo(instanceId, accountId => accountId && api.query.identity?.identityOf ? combineLatest([api.query.identity.identityOf(accountId), api.query.identity.superOf(accountId)]) : of([undefined, undefined]));\n}\n/**\n * @name identity\n * @description Returns identity info for an account\n */\nexport function identity(instanceId, api) {\n  return memo(instanceId, accountId => api.derive.accounts._identity(accountId).pipe(switchMap(([identityOfOpt, superOfOpt]) => getParent(api, identityOfOpt, superOfOpt)), map(([identityOfOpt, superOf]) => extractIdentity(identityOfOpt, superOf))));\n}\nexport const hasIdentity = /*#__PURE__*/firstMemo((api, accountId) => api.derive.accounts.hasIdentityMulti([accountId]));\nexport function hasIdentityMulti(instanceId, api) {\n  return memo(instanceId, accountIds => api.query.identity?.identityOf ? combineLatest([api.query.identity.identityOf.multi(accountIds), api.query.identity.superOf.multi(accountIds)]).pipe(map(([identities, supers]) => identities.map((identityOfOpt, index) => {\n    const superOfOpt = supers[index];\n    const parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : undefined;\n    let display;\n    if (identityOfOpt && identityOfOpt.isSome) {\n      const value = dataAsString(identityCompat(identityOfOpt).info.display);\n      if (value && !isHex(value)) {\n        display = value;\n      }\n    }\n    return {\n      display,\n      hasIdentity: !!(display || parentId),\n      parentId\n    };\n  }))) : of(accountIds.map(() => ({\n    hasIdentity: false\n  }))));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}