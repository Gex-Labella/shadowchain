{"ast":null,"code":"import { Null, Struct, Tuple } from '@polkadot/types-codec';\nimport { objectProperties, objectSpread } from '@polkadot/util';\n/** @internal */\nfunction decodeEvent(registry, value) {\n  if (!value?.length) {\n    return {\n      DataType: Null\n    };\n  }\n  const index = value.subarray(0, 2);\n  return {\n    DataType: registry.findMetaEvent(index),\n    value: {\n      data: value.subarray(2),\n      index\n    }\n  };\n}\n/**\n * @name GenericEventData\n * @description\n * Wrapper for the actual data that forms part of an [[Event]]\n */\nexport class GenericEventData extends Tuple {\n  __internal__meta;\n  __internal__method;\n  __internal__names = null;\n  __internal__section;\n  __internal__typeDef;\n  constructor(registry, value, meta, section = '<unknown>', method = '<unknown>') {\n    const fields = meta?.fields || [];\n    super(registry, fields.map(({\n      type\n    }) => registry.createLookupType(type)), value);\n    this.__internal__meta = meta;\n    this.__internal__method = method;\n    this.__internal__section = section;\n    this.__internal__typeDef = fields.map(({\n      type\n    }) => registry.lookup.getTypeDef(type));\n    const names = fields.map(({\n      name\n    }) => registry.lookup.sanitizeField(name)[0]).filter(n => !!n);\n    if (names.length === fields.length) {\n      this.__internal__names = names;\n      objectProperties(this, names, (_, i) => this[i]);\n    }\n  }\n  /**\n   * @description The wrapped [[EventMetadata]]\n   */\n  get meta() {\n    return this.__internal__meta;\n  }\n  /**\n   * @description The method as a string\n   */\n  get method() {\n    return this.__internal__method;\n  }\n  /**\n   * @description The field names (as available)\n   */\n  get names() {\n    return this.__internal__names;\n  }\n  /**\n   * @description The section as a string\n   */\n  get section() {\n    return this.__internal__section;\n  }\n  /**\n   * @description The [[TypeDef]] for this event\n   */\n  get typeDef() {\n    return this.__internal__typeDef;\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    if (this.__internal__names !== null) {\n      const json = {};\n      for (let i = 0, count = this.__internal__names.length; i < count; i++) {\n        json[this.__internal__names[i]] = this[i].toHuman(isExtended, disableAscii);\n      }\n      return json;\n    }\n    return super.toHuman(isExtended);\n  }\n}\n/**\n * @name GenericEvent\n * @description\n * A representation of a system event. These are generated via the [[Metadata]] interfaces and\n * specific to a specific Substrate runtime\n */\nexport class GenericEvent extends Struct {\n  // Currently we _only_ decode from Uint8Array, since we expect it to\n  // be used via EventRecord\n  constructor(registry, _value) {\n    const {\n      DataType,\n      value\n    } = decodeEvent(registry, _value);\n    super(registry, {\n      index: 'EventId',\n      // eslint-disable-next-line sort-keys\n      data: DataType\n    }, value);\n  }\n  /**\n   * @description The wrapped [[EventData]]\n   */\n  get data() {\n    return this.getT('data');\n  }\n  /**\n   * @description The [[EventId]], identifying the raw event\n   */\n  get index() {\n    return this.getT('index');\n  }\n  /**\n   * @description The [[EventMetadata]] with the documentation\n   */\n  get meta() {\n    return this.data.meta;\n  }\n  /**\n   * @description The method string identifying the event\n   */\n  get method() {\n    return this.data.method;\n  }\n  /**\n   * @description The section string identifying the event\n   */\n  get section() {\n    return this.data.section;\n  }\n  /**\n   * @description The [[TypeDef]] for the event\n   */\n  get typeDef() {\n    return this.data.typeDef;\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExpanded, disableAscii) {\n    return objectSpread({\n      method: this.method,\n      section: this.section\n    }, isExpanded ? {\n      docs: this.meta.docs.map(d => d.toString())\n    } : null, super.toHuman(isExpanded, disableAscii));\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}