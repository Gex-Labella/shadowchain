{"ast":null,"code":"import { BigInt } from '@polkadot/x-bigint';\nimport { _1n } from '../bi/consts.js';\nconst U8_MAX = BigInt(256);\nconst U16_MAX = BigInt(256 * 256);\nconst U64_MAX = BigInt('0x10000000000000000');\n/**\n * @name u8aToBigInt\n * @summary Creates a BigInt from a Uint8Array object.\n */\nexport function u8aToBigInt(value, {\n  isLe = true,\n  isNegative = false\n} = {}) {\n  // slice + reverse is expensive, however SCALE is LE by default so this is the path\n  // we are most interested in (the BE is added for the sake of being comprehensive)\n  if (!isLe) {\n    value = value.slice().reverse();\n  }\n  const count = value.length;\n  if (isNegative && count && value[count - 1] & 0x80) {\n    switch (count) {\n      case 0:\n        return BigInt(0);\n      case 1:\n        return BigInt((value[0] ^ 0x0000_00ff) * -1 - 1);\n      case 2:\n        return BigInt((value[0] + (value[1] << 8) ^ 0x0000_ffff) * -1 - 1);\n      case 4:\n        return BigInt((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00 ^ 0xffff_ffff) * -1 - 1);\n    }\n    const dvI = new DataView(value.buffer, value.byteOffset);\n    if (count === 8) {\n      return dvI.getBigInt64(0, true);\n    }\n    let result = BigInt(0);\n    const mod = count % 2;\n    for (let i = count - 2; i >= mod; i -= 2) {\n      result = result * U16_MAX + BigInt(dvI.getUint16(i, true) ^ 0xffff);\n    }\n    if (mod) {\n      result = result * U8_MAX + BigInt(value[0] ^ 0xff);\n    }\n    return result * -_1n - _1n;\n  }\n  switch (count) {\n    case 0:\n      return BigInt(0);\n    case 1:\n      return BigInt(value[0]);\n    case 2:\n      return BigInt(value[0] + (value[1] << 8));\n    case 4:\n      return BigInt(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00);\n  }\n  const dvI = new DataView(value.buffer, value.byteOffset);\n  switch (count) {\n    case 8:\n      return dvI.getBigUint64(0, true);\n    case 16:\n      return dvI.getBigUint64(8, true) * U64_MAX + dvI.getBigUint64(0, true);\n    default:\n      {\n        let result = BigInt(0);\n        const mod = count % 2;\n        for (let i = count - 2; i >= mod; i -= 2) {\n          result = result * U16_MAX + BigInt(dvI.getUint16(i, true));\n        }\n        if (mod) {\n          result = result * U8_MAX + BigInt(value[0]);\n        }\n        return result;\n      }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}