{"ast":null,"code":"/**\r\n * Transaction service for handling user-signed blockchain transactions\r\n * This implements the proper Web3 pattern where users sign their own transactions\r\n */\n\nimport axios from 'axios';\nimport { u8aToHex, stringToU8a } from '@polkadot/util';\nimport { toast } from 'react-toastify';\nimport { useWalletStore } from '../store/wallet';\nimport { config } from '../config/environment';\nimport { getApi } from './polkadot';\n/**\r\n * Fetch and prepare transactions for user signing\r\n */\nexport async function fetchPendingTransactions(userAddress) {\n  try {\n    const apiUrl = config.api.baseUrl;\n    const response = await axios.post(`${apiUrl}/transactions/sync-and-prepare/${userAddress}`);\n    console.log('API Response:', response.data);\n    if (response.data.transactions && response.data.transactions.length > 0) {\n      toast.info(`${response.data.transactions.length} transactions ready for signing`);\n    }\n    return response.data.transactions || [];\n  } catch (error) {\n    console.error('Failed to fetch pending transactions:', error);\n    toast.error('Failed to prepare transactions');\n    return [];\n  }\n}\n\n/**\r\n * Submit a shadow item with user signing\r\n * This is the proper Web3 way - user signs their own transaction\r\n */\nexport async function submitShadowItemWithUserSigning(transaction) {\n  const {\n    selectedAccount,\n    injector\n  } = useWalletStore.getState();\n  if (!selectedAccount || !injector) {\n    throw new Error('No wallet connected');\n  }\n\n  // In mock mode, simulate the transaction\n  if (config.features.mockMode) {\n    console.log('Mock: User signing shadow item transaction', transaction);\n    await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate signing delay\n    toast.success('Mock: Shadow item submitted successfully');\n    return '0x' + Math.random().toString(16).substr(2, 64);\n  }\n  const api = getApi();\n  return new Promise((resolve, reject) => {\n    let unsub;\n\n    // Check if shadow pallet exists\n    if (!api.tx.shadow) {\n      const error = new Error('Shadow pallet not available on this chain');\n      toast.error('Shadow pallet not found');\n      return reject(error);\n    }\n\n    // Get the args from the prepared transaction\n    const {\n      args\n    } = transaction.txData;\n    const [content, source, metadata] = args;\n\n    // Create timeout for the transaction\n    const timeout = setTimeout(() => {\n      if (unsub) unsub();\n      reject(new Error('Transaction timeout'));\n    }, 60000); // 60 second timeout\n\n    try {\n      // Detect how many arguments the chain expects\n      const expectedArgs = api.tx.shadow.submitShadowItem.meta.args.length;\n      console.log(`Chain expects ${expectedArgs} arguments for submitShadowItem`);\n\n      // Format content and metadata as hex\n      const contentHex = u8aToHex(stringToU8a(JSON.stringify(content)));\n      const metadataHex = u8aToHex(stringToU8a(metadata || ''));\n      let extrinsic;\n      if (expectedArgs === 4) {\n        // Old chain version expects 4 arguments: content, encrypted_key, source, metadata\n        console.log('Creating extrinsic with 4 arguments (including empty encrypted key for compatibility)');\n        extrinsic = api.tx.shadow.submitShadowItem(contentHex, '0x',\n        // Empty encrypted key for compatibility\n        source, metadataHex);\n      } else if (expectedArgs === 3) {\n        // New chain version expects 3 arguments: content, source, metadata\n        console.log('Creating extrinsic with 3 arguments (no encryption)');\n        extrinsic = api.tx.shadow.submitShadowItem(contentHex, source, metadataHex);\n      } else {\n        throw new Error(`Unexpected number of arguments for submitShadowItem: ${expectedArgs}`);\n      }\n      console.log('Submitting shadow item transaction');\n\n      // Sign and send the extrinsic\n      extrinsic.signAndSend(selectedAccount.address, {\n        signer: injector.signer\n      }, result => {\n        console.log(`Transaction status: ${result.status.type}`);\n        if (result.status.isInBlock) {\n          console.log(`Transaction included at blockHash ${result.status.asInBlock}`);\n          toast.info('Transaction included in block');\n        } else if (result.status.isFinalized) {\n          console.log(`Transaction finalized at blockHash ${result.status.asFinalized}`);\n          clearTimeout(timeout);\n\n          // Check for errors\n          let hasError = false;\n          result.events.forEach(({\n            phase,\n            event: {\n              data,\n              method,\n              section\n            }\n          }) => {\n            if (section === 'system' && method === 'ExtrinsicFailed') {\n              const [error] = data;\n              console.error('Transaction failed:', error.toString());\n              hasError = true;\n              toast.error('Transaction failed on chain');\n              reject(new Error('Transaction failed'));\n            } else if (section === 'shadow' && method === 'ShadowItemStored') {\n              console.log('Shadow item stored successfully');\n              toast.success('Shadow item stored on blockchain!');\n              toast.success('Shadow item stored on blockchain!');\n            }\n          });\n          if (!hasError) {\n            toast.success('Shadow item submitted successfully!');\n            if (unsub) unsub();\n            resolve(result.status.asFinalized.toString());\n          }\n        } else if (result.isError) {\n          clearTimeout(timeout);\n          console.error('Transaction error:', result);\n          toast.error('Transaction error');\n          if (unsub) unsub();\n          reject(new Error('Transaction error'));\n        }\n      }).then(unsubscribe => {\n        unsub = unsubscribe;\n      }).catch(error => {\n        clearTimeout(timeout);\n        console.error('Failed to submit transaction:', error);\n        toast.error(`Failed to submit: ${error.message}`);\n        reject(error);\n      });\n    } catch (error) {\n      clearTimeout(timeout);\n      console.error('Failed to create extrinsic:', error);\n      toast.error(`Failed to create transaction: ${error.message}`);\n      reject(error);\n    }\n  });\n}\n\n/**\r\n * Process all pending transactions\r\n * Allows user to sign multiple transactions in sequence\r\n */\nexport async function processAllPendingTransactions(userAddress, onProgress) {\n  const transactions = await fetchPendingTransactions(userAddress);\n  if (transactions.length === 0) {\n    toast.info('No new shadow items to submit');\n    return {\n      successful: 0,\n      failed: 0\n    };\n  }\n  let successful = 0;\n  let failed = 0;\n  toast.info(`Processing ${transactions.length} shadow items...`);\n  for (let i = 0; i < transactions.length; i++) {\n    const tx = transactions[i];\n    if (onProgress) {\n      onProgress(i + 1, transactions.length);\n    }\n    try {\n      await submitShadowItemWithUserSigning(tx);\n      successful++;\n    } catch (error) {\n      console.error(`Failed to submit transaction ${i + 1}:`, error);\n      failed++;\n\n      // Ask user if they want to continue after a failure\n      if (i < transactions.length - 1) {\n        const shouldContinue = window.confirm(`Transaction ${i + 1} failed. Continue with remaining ${transactions.length - i - 1} transactions?`);\n        if (!shouldContinue) {\n          break;\n        }\n      }\n    }\n  }\n\n  // Show summary\n  if (successful > 0 && failed === 0) {\n    toast.success(`Successfully submitted all ${successful} shadow items!`);\n  } else if (successful > 0 && failed > 0) {\n    toast.warning(`Submitted ${successful} items, ${failed} failed`);\n  } else if (failed > 0) {\n    toast.error(`Failed to submit ${failed} items`);\n  }\n  return {\n    successful,\n    failed\n  };\n}\n\n/**\r\n * Grant consent with user signing\r\n * User signs the consent transaction themselves\r\n */\n/**\r\n * Submit a shadow item with raw content \r\n * \r\n */\nexport async function submitShadowItemTransaction(transaction) {\n  const {\n    selectedAccount,\n    injector\n  } = useWalletStore.getState();\n  if (!selectedAccount || !injector) {\n    throw new Error('No wallet connected');\n  }\n\n  // In mock mode, simulate the transaction\n  if (config.features.mockMode) {\n    console.log('Mock: User signing shadow item transaction', transaction);\n    await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate signing delay\n    toast.success('Mock: Shadow item submitted successfully');\n    return '0x' + Math.random().toString(16).substr(2, 64);\n  }\n  const api = getApi();\n  return new Promise((resolve, reject) => {\n    let unsub;\n\n    // Check if shadow pallet exists\n    if (!api.tx.shadow) {\n      const error = new Error('Shadow pallet not available on this chain');\n      toast.error('Shadow pallet not found');\n      return reject(error);\n    }\n\n    // The transaction contains args that we need to use to construct the extrinsic\n    const {\n      args\n    } = transaction;\n    const [content, source, metadata] = args;\n\n    // Create timeout for the transaction\n    const timeout = setTimeout(() => {\n      if (unsub) unsub();\n      reject(new Error('Transaction timeout'));\n    }, 60000); // 60 second timeout\n\n    try {\n      // Detect how many arguments the chain expects\n      const expectedArgs = api.tx.shadow.submitShadowItem.meta.args.length;\n      console.log(`Chain expects ${expectedArgs} arguments for submitShadowItem`);\n\n      // Ensure content and metadata are properly formatted\n      const contentArg = typeof content === 'string' ? content.startsWith('0x') ? content : u8aToHex(stringToU8a(content)) : content;\n      const sourceArg = typeof source === 'string' ? source === 'GitHub' || source === 'github' ? 0 : 1 : source;\n      const metadataArg = typeof metadata === 'string' ? metadata.startsWith('0x') ? metadata : u8aToHex(stringToU8a(metadata)) : metadata;\n      let extrinsic;\n      if (expectedArgs === 4) {\n        // Old chain version expects 4 arguments: content, encrypted_key, source, metadata\n        console.log('Creating extrinsic with 4 arguments (including empty encrypted key for compatibility)');\n        const emptyEncryptedKey = '0x'; // Empty encrypted key for compatibility\n\n        console.log('Submitting shadow item with args:', {\n          content: contentArg.substring(0, 100) + '...',\n          encryptedKey: emptyEncryptedKey,\n          source: sourceArg,\n          metadata: metadataArg.substring(0, 100) + '...'\n        });\n        extrinsic = api.tx.shadow.submitShadowItem(contentArg, emptyEncryptedKey, sourceArg, metadataArg);\n      } else if (expectedArgs === 3) {\n        // New chain version expects 3 arguments: content, source, metadata\n        console.log('Creating extrinsic with 3 arguments (no encryption)');\n        console.log('Submitting shadow item with args:', {\n          content: contentArg.substring(0, 100) + '...',\n          source: sourceArg,\n          metadata: metadataArg.substring(0, 100) + '...'\n        });\n        extrinsic = api.tx.shadow.submitShadowItem(contentArg, sourceArg, metadataArg);\n      } else {\n        throw new Error(`Unexpected number of arguments for submitShadowItem: ${expectedArgs}`);\n      }\n      console.log('Submitting shadow item transaction');\n\n      // Sign and send the extrinsic\n      extrinsic.signAndSend(selectedAccount.address, {\n        signer: injector.signer\n      }, result => {\n        console.log(`Transaction status: ${result.status.type}`);\n        if (result.status.isInBlock) {\n          console.log(`Transaction included at blockHash ${result.status.asInBlock}`);\n          toast.info('Transaction included in block');\n        } else if (result.status.isFinalized) {\n          console.log(`Transaction finalized at blockHash ${result.status.asFinalized}`);\n          clearTimeout(timeout);\n\n          // Check for errors\n          let hasError = false;\n          result.events.forEach(({\n            phase,\n            event: {\n              data,\n              method,\n              section\n            }\n          }) => {\n            if (section === 'system' && method === 'ExtrinsicFailed') {\n              const [error] = data;\n              console.error('Transaction failed:', error.toString());\n              hasError = true;\n              toast.error('Transaction failed on chain');\n              reject(new Error('Transaction failed'));\n            } else if (section === 'shadow' && method === 'ShadowItemStored') {\n              console.log('Shadow item stored successfully');\n            }\n          });\n          if (!hasError) {\n            toast.success('Shadow item submitted successfully!');\n            if (unsub) unsub();\n            resolve(result.status.asFinalized.toString());\n          }\n        } else if (result.isError) {\n          clearTimeout(timeout);\n          console.error('Transaction error:', result);\n          toast.error('Transaction error');\n          if (unsub) unsub();\n          reject(new Error('Transaction error'));\n        }\n      }).then(unsubscribe => {\n        unsub = unsubscribe;\n      }).catch(error => {\n        clearTimeout(timeout);\n        console.error('Failed to submit transaction:', error);\n        toast.error(`Failed to submit: ${error.message}`);\n        reject(error);\n      });\n    } catch (error) {\n      clearTimeout(timeout);\n      console.error('Failed to create extrinsic:', error);\n      toast.error(`Failed to create transaction: ${error.message}`);\n      reject(error);\n    }\n  });\n}\nexport async function grantConsentWithUserSigning(messageHash, duration) {\n  const {\n    selectedAccount,\n    injector\n  } = useWalletStore.getState();\n  if (!selectedAccount || !injector) {\n    throw new Error('No wallet connected');\n  }\n\n  // In mock mode, simulate the consent\n  if (config.features.mockMode) {\n    console.log('Mock: User granting consent', {\n      messageHash,\n      duration\n    });\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // Store mock consent in localStorage\n    const mockConsent = {\n      grantedAt: Date.now(),\n      expiresAt: duration ? Date.now() + duration * 1000 : null,\n      messageHash\n    };\n    localStorage.setItem('shadowchain_mock_consent', JSON.stringify(mockConsent));\n    toast.success('Mock: Consent granted successfully');\n    return '0x' + Math.random().toString(16).substr(2, 64);\n  }\n  const api = getApi();\n  return new Promise((resolve, reject) => {\n    let unsub;\n\n    // Check if shadow pallet exists\n    if (!api.tx.shadow) {\n      const error = new Error('Shadow pallet not available');\n      toast.error('Shadow pallet not found');\n      return reject(error);\n    }\n    const timeout = setTimeout(() => {\n      if (unsub) unsub();\n      reject(new Error('Transaction timeout'));\n    }, 60000);\n    api.tx.shadow.grantConsent(messageHash, duration).signAndSend(selectedAccount.address, {\n      signer: injector.signer\n    }, result => {\n      console.log(`Consent transaction status: ${result.status.type}`);\n      if (result.status.isInBlock) {\n        toast.info('Consent transaction included in block');\n      } else if (result.status.isFinalized) {\n        clearTimeout(timeout);\n\n        // Check for errors\n        let hasError = false;\n        result.events.forEach(({\n          phase,\n          event: {\n            data,\n            method,\n            section\n          }\n        }) => {\n          if (section === 'system' && method === 'ExtrinsicFailed') {\n            hasError = true;\n            toast.error('Consent transaction failed');\n            reject(new Error('Consent transaction failed'));\n          } else if (section === 'shadow' && method === 'ConsentGranted') {\n            console.log('Consent granted successfully');\n          }\n        });\n        if (!hasError) {\n          toast.success('Consent granted successfully!');\n          if (unsub) unsub();\n          resolve(result.status.asFinalized.toString());\n        }\n      } else if (result.isError) {\n        clearTimeout(timeout);\n        toast.error('Consent transaction error');\n        if (unsub) unsub();\n        reject(new Error('Consent transaction error'));\n      }\n    }).then(unsubscribe => {\n      unsub = unsubscribe;\n    }).catch(error => {\n      clearTimeout(timeout);\n      console.error('Failed to grant consent:', error);\n      toast.error(`Failed to grant consent: ${error.message}`);\n      reject(error);\n    });\n  });\n}","map":{"version":3,"names":["axios","u8aToHex","stringToU8a","toast","useWalletStore","config","getApi","fetchPendingTransactions","userAddress","apiUrl","api","baseUrl","response","post","console","log","data","transactions","length","info","error","submitShadowItemWithUserSigning","transaction","selectedAccount","injector","getState","Error","features","mockMode","Promise","resolve","setTimeout","success","Math","random","toString","substr","reject","unsub","tx","shadow","args","txData","content","source","metadata","timeout","expectedArgs","submitShadowItem","meta","contentHex","JSON","stringify","metadataHex","extrinsic","signAndSend","address","signer","result","status","type","isInBlock","asInBlock","isFinalized","asFinalized","clearTimeout","hasError","events","forEach","phase","event","method","section","isError","then","unsubscribe","catch","message","processAllPendingTransactions","onProgress","successful","failed","i","shouldContinue","window","confirm","warning","submitShadowItemTransaction","contentArg","startsWith","sourceArg","metadataArg","emptyEncryptedKey","substring","encryptedKey","grantConsentWithUserSigning","messageHash","duration","mockConsent","grantedAt","Date","now","expiresAt","localStorage","setItem","grantConsent"],"sources":["c:/Users/Admin/Documents/Keiths/Polkadot/shadowchain/frontend/src/services/transactions.ts"],"sourcesContent":["/**\r\n * Transaction service for handling user-signed blockchain transactions\r\n * This implements the proper Web3 pattern where users sign their own transactions\r\n */\r\n\r\nimport axios from 'axios';\r\nimport { ApiPromise } from '@polkadot/api';\r\nimport { u8aToHex, stringToHex, stringToU8a } from '@polkadot/util';\r\nimport { toast } from 'react-toastify';\r\nimport { useWalletStore } from '../store/wallet';\r\nimport { config } from '../config/environment';\r\nimport { getApi } from './polkadot';\r\n\r\ninterface PendingTransaction {\r\n  id?: number;\r\n  source: 'GitHub' | 'Twitter';\r\n  content: any;\r\n  timestamp: number;\r\n  originalUrl?: string;\r\n  txData: {\r\n    method: string;\r\n    args: any[];\r\n  };\r\n}\r\n\r\ninterface ShadowItemTransaction {\r\n  method: string;\r\n  args: any[];\r\n}\r\n\r\n/**\r\n * Fetch and prepare transactions for user signing\r\n */\r\nexport async function fetchPendingTransactions(userAddress: string): Promise<PendingTransaction[]> {\r\n  try {\r\n    const apiUrl = config.api.baseUrl;\r\n    const response = await axios.post(`${apiUrl}/transactions/sync-and-prepare/${userAddress}`);\r\n\r\n    console.log('API Response:', response.data);\r\n    \r\n    if (response.data.transactions && response.data.transactions.length > 0) {\r\n      toast.info(`${response.data.transactions.length} transactions ready for signing`);\r\n    }\r\n    \r\n    return response.data.transactions || [];\r\n  } catch (error: any) {\r\n    console.error('Failed to fetch pending transactions:', error);\r\n    toast.error('Failed to prepare transactions');\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Submit a shadow item with user signing\r\n * This is the proper Web3 way - user signs their own transaction\r\n */\r\nexport async function submitShadowItemWithUserSigning(\r\n  transaction: PendingTransaction\r\n): Promise<string> {\r\n  const { selectedAccount, injector } = useWalletStore.getState();\r\n  \r\n  if (!selectedAccount || !injector) {\r\n    throw new Error('No wallet connected');\r\n  }\r\n\r\n  // In mock mode, simulate the transaction\r\n  if (config.features.mockMode) {\r\n    console.log('Mock: User signing shadow item transaction', transaction);\r\n    await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate signing delay\r\n    toast.success('Mock: Shadow item submitted successfully');\r\n    return '0x' + Math.random().toString(16).substr(2, 64);\r\n  }\r\n\r\n  const api = getApi();\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    let unsub: (() => void) | undefined;\r\n    \r\n    // Check if shadow pallet exists\r\n    if (!api.tx.shadow) {\r\n      const error = new Error('Shadow pallet not available on this chain');\r\n      toast.error('Shadow pallet not found');\r\n      return reject(error);\r\n    }\r\n    \r\n    // Get the args from the prepared transaction\r\n    const { args } = transaction.txData;\r\n    const [content, source, metadata] = args;\r\n    \r\n    // Create timeout for the transaction\r\n    const timeout = setTimeout(() => {\r\n      if (unsub) unsub();\r\n      reject(new Error('Transaction timeout'));\r\n    }, 60000); // 60 second timeout\r\n    \r\n    try {\r\n      // Detect how many arguments the chain expects\r\n      const expectedArgs = api.tx.shadow.submitShadowItem.meta.args.length;\r\n      console.log(`Chain expects ${expectedArgs} arguments for submitShadowItem`);\r\n      \r\n      // Format content and metadata as hex\r\n      const contentHex = u8aToHex(stringToU8a(JSON.stringify(content)));\r\n      const metadataHex = u8aToHex(stringToU8a(metadata || ''));\r\n      \r\n      let extrinsic: any;\r\n      \r\n      if (expectedArgs === 4) {\r\n        // Old chain version expects 4 arguments: content, encrypted_key, source, metadata\r\n        console.log('Creating extrinsic with 4 arguments (including empty encrypted key for compatibility)');\r\n        \r\n        extrinsic = api.tx.shadow.submitShadowItem(\r\n          contentHex,\r\n          '0x', // Empty encrypted key for compatibility\r\n          source,\r\n          metadataHex\r\n        );\r\n      } else if (expectedArgs === 3) {\r\n        // New chain version expects 3 arguments: content, source, metadata\r\n        console.log('Creating extrinsic with 3 arguments (no encryption)');\r\n        \r\n        extrinsic = api.tx.shadow.submitShadowItem(\r\n          contentHex,\r\n          source,\r\n          metadataHex\r\n        );\r\n      } else {\r\n        throw new Error(`Unexpected number of arguments for submitShadowItem: ${expectedArgs}`);\r\n      }\r\n      \r\n      console.log('Submitting shadow item transaction');\r\n      \r\n      // Sign and send the extrinsic\r\n      extrinsic.signAndSend(\r\n        selectedAccount.address,\r\n        { signer: injector.signer },\r\n        (result: any) => {\r\n          console.log(`Transaction status: ${result.status.type}`);\r\n          \r\n          if (result.status.isInBlock) {\r\n            console.log(`Transaction included at blockHash ${result.status.asInBlock}`);\r\n            toast.info('Transaction included in block');\r\n          } else if (result.status.isFinalized) {\r\n            console.log(`Transaction finalized at blockHash ${result.status.asFinalized}`);\r\n            clearTimeout(timeout);\r\n            \r\n            // Check for errors\r\n            let hasError = false;\r\n            result.events.forEach(({ phase, event: { data, method, section } }: any) => {\r\n              if (section === 'system' && method === 'ExtrinsicFailed') {\r\n                const [error] = data as any;\r\n                console.error('Transaction failed:', error.toString());\r\n                hasError = true;\r\n                toast.error('Transaction failed on chain');\r\n                reject(new Error('Transaction failed'));\r\n              } else if (section === 'shadow' && method === 'ShadowItemStored') {\r\n                console.log('Shadow item stored successfully');\r\n                toast.success('Shadow item stored on blockchain!');\r\n                toast.success('Shadow item stored on blockchain!');\r\n              }\r\n            });\r\n            \r\n            if (!hasError) {\r\n              toast.success('Shadow item submitted successfully!');\r\n              if (unsub) unsub();\r\n              resolve(result.status.asFinalized.toString());\r\n            }\r\n          } else if (result.isError) {\r\n            clearTimeout(timeout);\r\n            console.error('Transaction error:', result);\r\n            toast.error('Transaction error');\r\n            if (unsub) unsub();\r\n            reject(new Error('Transaction error'));\r\n          }\r\n        }\r\n      )\r\n      .then((unsubscribe: any) => {\r\n        unsub = unsubscribe;\r\n      })\r\n      .catch((error: any) => {\r\n        clearTimeout(timeout);\r\n        console.error('Failed to submit transaction:', error);\r\n        toast.error(`Failed to submit: ${error.message}`);\r\n        reject(error);\r\n      });\r\n    } catch (error: any) {\r\n      clearTimeout(timeout);\r\n      console.error('Failed to create extrinsic:', error);\r\n      toast.error(`Failed to create transaction: ${error.message}`);\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Process all pending transactions\r\n * Allows user to sign multiple transactions in sequence\r\n */\r\nexport async function processAllPendingTransactions(\r\n  userAddress: string,\r\n  onProgress?: (current: number, total: number) => void\r\n): Promise<{ successful: number; failed: number }> {\r\n  const transactions = await fetchPendingTransactions(userAddress);\r\n  \r\n  if (transactions.length === 0) {\r\n    toast.info('No new shadow items to submit');\r\n    return { successful: 0, failed: 0 };\r\n  }\r\n  \r\n  let successful = 0;\r\n  let failed = 0;\r\n  \r\n  toast.info(`Processing ${transactions.length} shadow items...`);\r\n  \r\n  for (let i = 0; i < transactions.length; i++) {\r\n    const tx = transactions[i];\r\n    \r\n    if (onProgress) {\r\n      onProgress(i + 1, transactions.length);\r\n    }\r\n    \r\n    try {\r\n      await submitShadowItemWithUserSigning(tx);\r\n      successful++;\r\n    } catch (error) {\r\n      console.error(`Failed to submit transaction ${i + 1}:`, error);\r\n      failed++;\r\n      \r\n      // Ask user if they want to continue after a failure\r\n      if (i < transactions.length - 1) {\r\n        const shouldContinue = window.confirm(\r\n          `Transaction ${i + 1} failed. Continue with remaining ${transactions.length - i - 1} transactions?`\r\n        );\r\n        if (!shouldContinue) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Show summary\r\n  if (successful > 0 && failed === 0) {\r\n    toast.success(`Successfully submitted all ${successful} shadow items!`);\r\n  } else if (successful > 0 && failed > 0) {\r\n    toast.warning(`Submitted ${successful} items, ${failed} failed`);\r\n  } else if (failed > 0) {\r\n    toast.error(`Failed to submit ${failed} items`);\r\n  }\r\n  \r\n  return { successful, failed };\r\n}\r\n\r\n/**\r\n * Grant consent with user signing\r\n * User signs the consent transaction themselves\r\n */\r\n/**\r\n * Submit a shadow item with raw content \r\n * \r\n */\r\nexport async function submitShadowItemTransaction(\r\n  transaction: ShadowItemTransaction\r\n): Promise<string> {\r\n  const { selectedAccount, injector } = useWalletStore.getState();\r\n  \r\n  if (!selectedAccount || !injector) {\r\n    throw new Error('No wallet connected');\r\n  }\r\n\r\n  // In mock mode, simulate the transaction\r\n  if (config.features.mockMode) {\r\n    console.log('Mock: User signing shadow item transaction', transaction);\r\n    await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate signing delay\r\n    toast.success('Mock: Shadow item submitted successfully');\r\n    return '0x' + Math.random().toString(16).substr(2, 64);\r\n  }\r\n\r\n  const api = getApi();\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    let unsub: (() => void) | undefined;\r\n    \r\n    // Check if shadow pallet exists\r\n    if (!api.tx.shadow) {\r\n      const error = new Error('Shadow pallet not available on this chain');\r\n      toast.error('Shadow pallet not found');\r\n      return reject(error);\r\n    }\r\n    \r\n    // The transaction contains args that we need to use to construct the extrinsic\r\n    const { args } = transaction;\r\n    const [content, source, metadata] = args;\r\n    \r\n    // Create timeout for the transaction\r\n    const timeout = setTimeout(() => {\r\n      if (unsub) unsub();\r\n      reject(new Error('Transaction timeout'));\r\n    }, 60000); // 60 second timeout\r\n    \r\n    try {\r\n      // Detect how many arguments the chain expects\r\n      const expectedArgs = api.tx.shadow.submitShadowItem.meta.args.length;\r\n      console.log(`Chain expects ${expectedArgs} arguments for submitShadowItem`);\r\n      \r\n      // Ensure content and metadata are properly formatted\r\n      const contentArg = typeof content === 'string'\r\n        ? content.startsWith('0x')\r\n          ? content\r\n          : u8aToHex(stringToU8a(content))\r\n        : content;\r\n        \r\n      const sourceArg = typeof source === 'string'\r\n        ? (source === 'GitHub' || source === 'github' ? 0 : 1)\r\n        : source;\r\n        \r\n      const metadataArg = typeof metadata === 'string'\r\n        ? metadata.startsWith('0x')\r\n          ? metadata\r\n          : u8aToHex(stringToU8a(metadata))\r\n        : metadata;\r\n      \r\n      let extrinsic: any;\r\n      \r\n      if (expectedArgs === 4) {\r\n        // Old chain version expects 4 arguments: content, encrypted_key, source, metadata\r\n        console.log('Creating extrinsic with 4 arguments (including empty encrypted key for compatibility)');\r\n        \r\n        const emptyEncryptedKey = '0x'; // Empty encrypted key for compatibility\r\n        \r\n        console.log('Submitting shadow item with args:', {\r\n          content: contentArg.substring(0, 100) + '...',\r\n          encryptedKey: emptyEncryptedKey,\r\n          source: sourceArg,\r\n          metadata: metadataArg.substring(0, 100) + '...'\r\n        });\r\n        \r\n        extrinsic = api.tx.shadow.submitShadowItem(\r\n          contentArg,\r\n          emptyEncryptedKey,\r\n          sourceArg,\r\n          metadataArg\r\n        );\r\n      } else if (expectedArgs === 3) {\r\n        // New chain version expects 3 arguments: content, source, metadata\r\n        console.log('Creating extrinsic with 3 arguments (no encryption)');\r\n        \r\n        console.log('Submitting shadow item with args:', {\r\n          content: contentArg.substring(0, 100) + '...',\r\n          source: sourceArg,\r\n          metadata: metadataArg.substring(0, 100) + '...'\r\n        });\r\n        \r\n        extrinsic = api.tx.shadow.submitShadowItem(\r\n          contentArg,\r\n          sourceArg,\r\n          metadataArg\r\n        );\r\n      } else {\r\n        throw new Error(`Unexpected number of arguments for submitShadowItem: ${expectedArgs}`);\r\n      }\r\n      \r\n      console.log('Submitting shadow item transaction');\r\n      \r\n      // Sign and send the extrinsic\r\n      extrinsic.signAndSend(\r\n          selectedAccount.address,\r\n          { signer: injector.signer },\r\n          (result: any) => {\r\n            console.log(`Transaction status: ${result.status.type}`);\r\n            \r\n            if (result.status.isInBlock) {\r\n              console.log(`Transaction included at blockHash ${result.status.asInBlock}`);\r\n              toast.info('Transaction included in block');\r\n            } else if (result.status.isFinalized) {\r\n              console.log(`Transaction finalized at blockHash ${result.status.asFinalized}`);\r\n              clearTimeout(timeout);\r\n              \r\n              // Check for errors\r\n              let hasError = false;\r\n              result.events.forEach(({ phase, event: { data, method, section } }: any) => {\r\n                if (section === 'system' && method === 'ExtrinsicFailed') {\r\n                  const [error] = data as any;\r\n                  console.error('Transaction failed:', error.toString());\r\n                  hasError = true;\r\n                  toast.error('Transaction failed on chain');\r\n                  reject(new Error('Transaction failed'));\r\n                } else if (section === 'shadow' && method === 'ShadowItemStored') {\r\n                  console.log('Shadow item stored successfully');\r\n                }\r\n              });\r\n              \r\n              if (!hasError) {\r\n                toast.success('Shadow item submitted successfully!');\r\n                if (unsub) unsub();\r\n                resolve(result.status.asFinalized.toString());\r\n              }\r\n            } else if (result.isError) {\r\n              clearTimeout(timeout);\r\n              console.error('Transaction error:', result);\r\n              toast.error('Transaction error');\r\n              if (unsub) unsub();\r\n              reject(new Error('Transaction error'));\r\n            }\r\n          }\r\n        )\r\n        .then((unsubscribe: any) => {\r\n          unsub = unsubscribe;\r\n        })\r\n        .catch((error: any) => {\r\n          clearTimeout(timeout);\r\n          console.error('Failed to submit transaction:', error);\r\n          toast.error(`Failed to submit: ${error.message}`);\r\n          reject(error);\r\n        });\r\n    } catch (error: any) {\r\n      clearTimeout(timeout);\r\n      console.error('Failed to create extrinsic:', error);\r\n      toast.error(`Failed to create transaction: ${error.message}`);\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n\r\nexport async function grantConsentWithUserSigning(\r\n  messageHash: string,\r\n  duration?: number\r\n): Promise<string> {\r\n  const { selectedAccount, injector } = useWalletStore.getState();\r\n  \r\n  if (!selectedAccount || !injector) {\r\n    throw new Error('No wallet connected');\r\n  }\r\n\r\n  // In mock mode, simulate the consent\r\n  if (config.features.mockMode) {\r\n    console.log('Mock: User granting consent', { messageHash, duration });\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n    \r\n    // Store mock consent in localStorage\r\n    const mockConsent = {\r\n      grantedAt: Date.now(),\r\n      expiresAt: duration ? Date.now() + duration * 1000 : null,\r\n      messageHash\r\n    };\r\n    localStorage.setItem('shadowchain_mock_consent', JSON.stringify(mockConsent));\r\n    \r\n    toast.success('Mock: Consent granted successfully');\r\n    return '0x' + Math.random().toString(16).substr(2, 64);\r\n  }\r\n\r\n  const api = getApi();\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    let unsub: (() => void) | undefined;\r\n    \r\n    // Check if shadow pallet exists\r\n    if (!api.tx.shadow) {\r\n      const error = new Error('Shadow pallet not available');\r\n      toast.error('Shadow pallet not found');\r\n      return reject(error);\r\n    }\r\n    \r\n    const timeout = setTimeout(() => {\r\n      if (unsub) unsub();\r\n      reject(new Error('Transaction timeout'));\r\n    }, 60000);\r\n    \r\n    api.tx.shadow\r\n      .grantConsent(messageHash, duration)\r\n      .signAndSend(\r\n        selectedAccount.address,\r\n        { signer: injector.signer },\r\n        (result) => {\r\n          console.log(`Consent transaction status: ${result.status.type}`);\r\n          \r\n          if (result.status.isInBlock) {\r\n            toast.info('Consent transaction included in block');\r\n          } else if (result.status.isFinalized) {\r\n            clearTimeout(timeout);\r\n            \r\n            // Check for errors\r\n            let hasError = false;\r\n            result.events.forEach(({ phase, event: { data, method, section } }) => {\r\n              if (section === 'system' && method === 'ExtrinsicFailed') {\r\n                hasError = true;\r\n                toast.error('Consent transaction failed');\r\n                reject(new Error('Consent transaction failed'));\r\n              } else if (section === 'shadow' && method === 'ConsentGranted') {\r\n                console.log('Consent granted successfully');\r\n              }\r\n            });\r\n            \r\n            if (!hasError) {\r\n              toast.success('Consent granted successfully!');\r\n              if (unsub) unsub();\r\n              resolve(result.status.asFinalized.toString());\r\n            }\r\n          } else if (result.isError) {\r\n            clearTimeout(timeout);\r\n            toast.error('Consent transaction error');\r\n            if (unsub) unsub();\r\n            reject(new Error('Consent transaction error'));\r\n          }\r\n        }\r\n      )\r\n      .then((unsubscribe) => {\r\n        unsub = unsubscribe;\r\n      })\r\n      .catch((error) => {\r\n        clearTimeout(timeout);\r\n        console.error('Failed to grant consent:', error);\r\n        toast.error(`Failed to grant consent: ${error.message}`);\r\n        reject(error);\r\n      });\r\n  });\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}