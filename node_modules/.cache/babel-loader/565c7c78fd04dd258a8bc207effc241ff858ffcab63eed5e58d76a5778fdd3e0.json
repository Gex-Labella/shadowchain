{"ast":null,"code":"import { DoNotConstruct, Json, Raw } from '@polkadot/types-codec';\nimport { constructTypeClass, createClassUnsafe, createTypeUnsafe } from '@polkadot/types-create';\nimport { assertReturn, BN_ZERO, formatBalance, isBn, isFunction, isNumber, isString, isU8a, lazyMethod, logger, objectSpread, stringCamelCase, stringify } from '@polkadot/util';\nimport { blake2AsU8a } from '@polkadot/util-crypto';\nimport { expandExtensionTypes, fallbackExtensions, findUnknownExtensions } from '../extrinsic/signedExtensions/index.js';\nimport { GenericEventData } from '../generic/Event.js';\nimport * as baseTypes from '../index.types.js';\nimport * as definitions from '../interfaces/definitions.js';\nimport { createCallFunction } from '../metadata/decorate/extrinsics/index.js';\nimport { decorateConstants, filterCallsSome, filterEventsSome } from '../metadata/decorate/index.js';\nimport { Metadata } from '../metadata/Metadata.js';\nimport { PortableRegistry } from '../metadata/PortableRegistry/index.js';\nimport { lazyVariants } from './lazy.js';\nconst DEFAULT_FIRST_CALL_IDX = new Uint8Array(2);\nconst l = logger('registry');\nfunction sortDecimalStrings(a, b) {\n  return parseInt(a, 10) - parseInt(b, 10);\n}\nfunction valueToString(v) {\n  return v.toString();\n}\nfunction getFieldArgs(lookup, fields) {\n  const count = fields.length;\n  const args = new Array(count);\n  for (let i = 0; i < count; i++) {\n    args[i] = lookup.getTypeDef(fields[i].type).type;\n  }\n  return args;\n}\nfunction clearRecord(record) {\n  const keys = Object.keys(record);\n  for (let i = 0, count = keys.length; i < count; i++) {\n    delete record[keys[i]];\n  }\n}\nfunction getVariantStringIdx({\n  index\n}) {\n  return index.toString();\n}\nfunction injectErrors(_, {\n  lookup,\n  pallets\n}, version, result) {\n  clearRecord(result);\n  for (let i = 0, count = pallets.length; i < count; i++) {\n    const {\n      errors,\n      index,\n      name\n    } = pallets[i];\n    if (errors.isSome) {\n      const sectionName = stringCamelCase(name);\n      lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, errors.unwrap(), getVariantStringIdx, ({\n        docs,\n        fields,\n        index,\n        name\n      }) => ({\n        args: getFieldArgs(lookup, fields),\n        docs: docs.map(valueToString),\n        fields,\n        index: index.toNumber(),\n        method: name.toString(),\n        name: name.toString(),\n        section: sectionName\n      })));\n    }\n  }\n}\nfunction injectEvents(registry, {\n  lookup,\n  pallets\n}, version, result) {\n  const filtered = pallets.filter(filterEventsSome);\n  clearRecord(result);\n  for (let i = 0, count = filtered.length; i < count; i++) {\n    const {\n      events,\n      index,\n      name\n    } = filtered[i];\n    lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, events.unwrap(), getVariantStringIdx, variant => {\n      const meta = registry.createType('EventMetadataLatest', objectSpread({}, variant, {\n        args: getFieldArgs(lookup, variant.fields)\n      }));\n      return class extends GenericEventData {\n        constructor(registry, value) {\n          super(registry, value, meta, stringCamelCase(name), variant.name.toString());\n        }\n      };\n    }));\n  }\n}\nfunction injectExtrinsics(registry, {\n  lookup,\n  pallets\n}, version, result, mapping) {\n  const filtered = pallets.filter(filterCallsSome);\n  clearRecord(result);\n  clearRecord(mapping);\n  for (let i = 0, count = filtered.length; i < count; i++) {\n    const {\n      calls,\n      index,\n      name\n    } = filtered[i];\n    const sectionIndex = version >= 12 ? index.toNumber() : i;\n    const sectionName = stringCamelCase(name);\n    const allCalls = calls.unwrap();\n    lazyMethod(result, sectionIndex, () => lazyVariants(lookup, allCalls, getVariantStringIdx, variant => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));\n    const {\n      path\n    } = registry.lookup.getSiType(allCalls.type);\n    // frame_system::pallet::Call / pallet_balances::pallet::Call / polkadot_runtime_parachains::configuration::pallet::Call /\n    const palletIdx = path.findIndex(v => v.eq('pallet'));\n    if (palletIdx !== -1) {\n      const name = stringCamelCase(path.slice(0, palletIdx).map((p, i) => i === 0\n      // frame_system || pallet_balances\n      ? p.replace(/^(frame|pallet)_/, '') : p).join(' '));\n      if (!mapping[name]) {\n        mapping[name] = [sectionName];\n      } else {\n        mapping[name].push(sectionName);\n      }\n    }\n  }\n}\nfunction extractProperties(registry, metadata) {\n  const original = registry.getChainProperties();\n  const constants = decorateConstants(registry, metadata.asLatest, metadata.version);\n  const ss58Format = constants['system'] && (constants['system']['sS58Prefix'] || constants['system']['ss58Prefix']);\n  if (!ss58Format) {\n    return original;\n  }\n  const {\n    isEthereum,\n    tokenDecimals,\n    tokenSymbol\n  } = original || {};\n  return registry.createTypeUnsafe('ChainProperties', [{\n    isEthereum,\n    ss58Format,\n    tokenDecimals,\n    tokenSymbol\n  }]);\n}\nexport class TypeRegistry {\n  __internal__chainProperties;\n  __internal__classes = new Map();\n  __internal__definitions = new Map();\n  __internal__firstCallIndex = null;\n  __internal__hasher = blake2AsU8a;\n  __internal__knownTypes = {};\n  __internal__lookup;\n  __internal__metadata;\n  __internal__metadataVersion = 0;\n  __internal__signedExtensions = fallbackExtensions;\n  __internal__unknownTypes = new Map();\n  __internal__userExtensions;\n  __internal__knownDefaults;\n  __internal__knownDefaultsEntries;\n  __internal__knownDefinitions;\n  __internal__metadataCalls = {};\n  __internal__metadataErrors = {};\n  __internal__metadataEvents = {};\n  __internal__moduleMap = {};\n  createdAtHash;\n  constructor(createdAtHash) {\n    this.__internal__knownDefaults = objectSpread({\n      Json,\n      Metadata,\n      PortableRegistry,\n      Raw\n    }, baseTypes);\n    this.__internal__knownDefaultsEntries = Object.entries(this.__internal__knownDefaults);\n    this.__internal__knownDefinitions = definitions;\n    const allKnown = Object.values(this.__internal__knownDefinitions);\n    for (let i = 0, count = allKnown.length; i < count; i++) {\n      this.register(allKnown[i].types);\n    }\n    if (createdAtHash) {\n      this.createdAtHash = this.createType('BlockHash', createdAtHash);\n    }\n  }\n  get chainDecimals() {\n    if (this.__internal__chainProperties?.tokenDecimals.isSome) {\n      const allDecimals = this.__internal__chainProperties.tokenDecimals.unwrap();\n      if (allDecimals.length) {\n        return allDecimals.map(b => b.toNumber());\n      }\n    }\n    return [12];\n  }\n  get chainIsEthereum() {\n    return this.__internal__chainProperties?.isEthereum.isTrue || false;\n  }\n  get chainSS58() {\n    return this.__internal__chainProperties?.ss58Format.isSome ? this.__internal__chainProperties.ss58Format.unwrap().toNumber() : undefined;\n  }\n  get chainTokens() {\n    if (this.__internal__chainProperties?.tokenSymbol.isSome) {\n      const allTokens = this.__internal__chainProperties.tokenSymbol.unwrap();\n      if (allTokens.length) {\n        return allTokens.map(valueToString);\n      }\n    }\n    return [formatBalance.getDefaults().unit];\n  }\n  get firstCallIndex() {\n    return this.__internal__firstCallIndex || DEFAULT_FIRST_CALL_IDX;\n  }\n  /**\n   * @description Returns true if the type is in a Compat format\n   */\n  isLookupType(value) {\n    return /Lookup\\d+$/.test(value);\n  }\n  /**\n   * @description Creates a lookup string from the supplied id\n   */\n  createLookupType(lookupId) {\n    return `Lookup${typeof lookupId === 'number' ? lookupId : lookupId.toNumber()}`;\n  }\n  get knownTypes() {\n    return this.__internal__knownTypes;\n  }\n  get lookup() {\n    return assertReturn(this.__internal__lookup, 'PortableRegistry has not been set on this registry');\n  }\n  get metadata() {\n    return assertReturn(this.__internal__metadata, 'Metadata has not been set on this registry');\n  }\n  get unknownTypes() {\n    return [...this.__internal__unknownTypes.keys()];\n  }\n  get signedExtensions() {\n    return this.__internal__signedExtensions;\n  }\n  clearCache() {\n    this.__internal__classes = new Map();\n  }\n  /**\n   * @describe Creates an instance of the class\n   */\n  createClass(type) {\n    return createClassUnsafe(this, type);\n  }\n  /**\n   * @describe Creates an instance of the class\n   */\n  createClassUnsafe(type) {\n    return createClassUnsafe(this, type);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createType(type, ...params) {\n    return createTypeUnsafe(this, type, params);\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createTypeUnsafe(type, params, options) {\n    return createTypeUnsafe(this, type, params, options);\n  }\n  // find a specific call\n  findMetaCall(callIndex) {\n    const [section, method] = [callIndex[0], callIndex[1]];\n    return assertReturn(this.__internal__metadataCalls[`${section}`] && this.__internal__metadataCalls[`${section}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section}, ${method}]/[${callIndex.toString()}]`);\n  }\n  // finds an error\n  findMetaError(errorIndex) {\n    const [section, method] = isU8a(errorIndex) ? [errorIndex[0], errorIndex[1]] : [errorIndex.index.toNumber(), isU8a(errorIndex.error) ? errorIndex.error[0] : errorIndex.error.toNumber()];\n    return assertReturn(this.__internal__metadataErrors[`${section}`] && this.__internal__metadataErrors[`${section}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section}, ${method}]/[${errorIndex.toString()}]`);\n  }\n  findMetaEvent(eventIndex) {\n    const [section, method] = [eventIndex[0], eventIndex[1]];\n    return assertReturn(this.__internal__metadataEvents[`${section}`] && this.__internal__metadataEvents[`${section}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section}, ${method}]/[${eventIndex.toString()}]`);\n  }\n  get(name, withUnknown, knownTypeDef) {\n    return this.getUnsafe(name, withUnknown, knownTypeDef);\n  }\n  getUnsafe(name, withUnknown, knownTypeDef) {\n    let Type = this.__internal__classes.get(name) || this.__internal__knownDefaults[name];\n    // we have not already created the type, attempt it\n    if (!Type) {\n      const definition = this.__internal__definitions.get(name);\n      let BaseType;\n      // we have a definition, so create the class now (lazily)\n      if (definition) {\n        BaseType = createClassUnsafe(this, definition);\n      } else if (knownTypeDef) {\n        BaseType = constructTypeClass(this, knownTypeDef);\n      } else if (withUnknown) {\n        l.warn(`Unable to resolve type ${name}, it will fail on construction`);\n        this.__internal__unknownTypes.set(name, true);\n        BaseType = DoNotConstruct.with(name);\n      }\n      if (BaseType) {\n        // NOTE If we didn't extend here, we would have strange artifacts. An example is\n        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128\n        // Additionally, we now pass through the registry, which is a link to ourselves\n        Type = class extends BaseType {};\n        this.__internal__classes.set(name, Type);\n        // In the case of lookups, we also want to store the actual class against\n        // the lookup name, instad of having to traverse again\n        if (knownTypeDef && isNumber(knownTypeDef.lookupIndex)) {\n          this.__internal__classes.set(this.createLookupType(knownTypeDef.lookupIndex), Type);\n        }\n      }\n    }\n    return Type;\n  }\n  getChainProperties() {\n    return this.__internal__chainProperties;\n  }\n  getClassName(Type) {\n    // we cannot rely on export order (anymore, since babel/core 7.15.8), so in the case of\n    // items such as u32 & U32, we get the lowercase versions here... not quite as optimal\n    // (previously this used to be a simple find & return)\n    const names = [];\n    for (const [name, Clazz] of this.__internal__knownDefaultsEntries) {\n      if (Type === Clazz) {\n        names.push(name);\n      }\n    }\n    for (const [name, Clazz] of this.__internal__classes.entries()) {\n      if (Type === Clazz) {\n        names.push(name);\n      }\n    }\n    return names.length\n    // both sort and reverse are done in-place\n    // ['U32', 'u32'] -> ['u32', 'U32']\n    ? names.sort().reverse()[0] : undefined;\n  }\n  getDefinition(typeName) {\n    return this.__internal__definitions.get(typeName);\n  }\n  getModuleInstances(specName, moduleName) {\n    return this.__internal__knownTypes?.typesBundle?.spec?.[specName.toString()]?.instances?.[moduleName] || this.__internal__moduleMap[moduleName];\n  }\n  getOrThrow(name) {\n    const Clazz = this.get(name);\n    if (!Clazz) {\n      throw new Error(`type ${name} not found`);\n    }\n    return Clazz;\n  }\n  getOrUnknown(name) {\n    return this.get(name, true);\n  }\n  getSignedExtensionExtra() {\n    return expandExtensionTypes(this.__internal__signedExtensions, 'payload', this.__internal__userExtensions);\n  }\n  getSignedExtensionTypes() {\n    return expandExtensionTypes(this.__internal__signedExtensions, 'extrinsic', this.__internal__userExtensions);\n  }\n  hasClass(name) {\n    return this.__internal__classes.has(name) || !!this.__internal__knownDefaults[name];\n  }\n  hasDef(name) {\n    return this.__internal__definitions.has(name);\n  }\n  hasType(name) {\n    return !this.__internal__unknownTypes.get(name) && (this.hasClass(name) || this.hasDef(name));\n  }\n  hash(data) {\n    return this.createType('CodecHash', this.__internal__hasher(data));\n  }\n  // eslint-disable-next-line no-dupe-class-members\n  register(arg1, arg2) {\n    // NOTE Constructors appear as functions here\n    if (isFunction(arg1)) {\n      this.__internal__classes.set(arg1.name, arg1);\n    } else if (isString(arg1)) {\n      if (!isFunction(arg2)) {\n        throw new Error(`Expected class definition passed to '${arg1}' registration`);\n      } else if (arg1 === arg2.toString()) {\n        throw new Error(`Unable to register circular ${arg1} === ${arg1}`);\n      }\n      this.__internal__classes.set(arg1, arg2);\n    } else {\n      this.__internal__registerObject(arg1);\n    }\n  }\n  __internal__registerObject = obj => {\n    const entries = Object.entries(obj);\n    for (let e = 0, count = entries.length; e < count; e++) {\n      const [name, type] = entries[e];\n      if (isFunction(type)) {\n        // This _looks_ a bit funny, but `typeof Clazz === 'function'\n        this.__internal__classes.set(name, type);\n      } else {\n        const def = isString(type) ? type : stringify(type);\n        if (name === def) {\n          throw new Error(`Unable to register circular ${name} === ${def}`);\n        }\n        // we already have this type, remove the classes registered for it\n        if (this.__internal__classes.has(name)) {\n          this.__internal__classes.delete(name);\n        }\n        this.__internal__definitions.set(name, def);\n      }\n    }\n  };\n  // sets the chain properties\n  setChainProperties(properties) {\n    if (properties) {\n      this.__internal__chainProperties = properties;\n    }\n  }\n  setHasher(hasher) {\n    this.__internal__hasher = hasher || blake2AsU8a;\n  }\n  setKnownTypes(knownTypes) {\n    this.__internal__knownTypes = knownTypes;\n  }\n  setLookup(lookup) {\n    this.__internal__lookup = lookup;\n    // register all applicable types found\n    lookup.register();\n  }\n  // register alias types alongside the portable/lookup setup\n  // (we don't combine this into setLookup since that would/could\n  // affect stand-along lookups, such as ABIs which don't have\n  // actual on-chain metadata)\n  __internal__registerLookup = lookup => {\n    // attach the lookup before we register any types\n    this.setLookup(lookup);\n    // we detect based on runtime configuration\n    let Weight = null;\n    if (this.hasType('SpWeightsWeightV2Weight')) {\n      // detection for WeightV2 type based on latest naming\n      const weightv2 = this.createType('SpWeightsWeightV2Weight');\n      Weight = weightv2.refTime && weightv2.proofSize\n      // with both refTime & proofSize we use as-is (WeightV2)\n      ? 'SpWeightsWeightV2Weight'\n      // fallback to WeightV1 (WeightV1.5 is a struct, single field)\n      : 'WeightV1';\n    } else if (!isBn(this.createType('Weight'))) {\n      // where we have an already-supplied BN override, we don't clobber\n      // it with our detected value (This protects against pre-defines\n      // where Weight may be aliassed to WeightV0, e.g. in early Kusama chains)\n      Weight = 'WeightV1';\n    }\n    if (Weight) {\n      // we have detected a version, adjust the definition\n      this.register({\n        Weight\n      });\n    }\n  };\n  // sets the metadata\n  setMetadata(metadata, signedExtensions, userExtensions, noInitWarn) {\n    this.__internal__metadata = metadata.asLatest;\n    this.__internal__metadataVersion = metadata.version;\n    this.__internal__firstCallIndex = null;\n    // attach the lookup at this point and register relevant types (before injecting)\n    this.__internal__registerLookup(this.__internal__metadata.lookup);\n    injectExtrinsics(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataCalls, this.__internal__moduleMap);\n    injectErrors(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataErrors);\n    injectEvents(this, this.__internal__metadata, this.__internal__metadataVersion, this.__internal__metadataEvents);\n    // set the default call index (the lowest section, the lowest method)\n    // in most chains this should be 0,0\n    const [defSection] = Object.keys(this.__internal__metadataCalls).sort(sortDecimalStrings);\n    if (defSection) {\n      const [defMethod] = Object.keys(this.__internal__metadataCalls[defSection]).sort(sortDecimalStrings);\n      if (defMethod) {\n        this.__internal__firstCallIndex = new Uint8Array([parseInt(defSection, 10), parseInt(defMethod, 10)]);\n      }\n    }\n    // setup the available extensions\n    this.setSignedExtensions(signedExtensions || (this.__internal__metadata.extrinsic.version.gt(BN_ZERO)\n    // FIXME Use the extension and their injected types\n    ? this.__internal__metadata.extrinsic.signedExtensions.map(({\n      identifier\n    }) => identifier.toString()) : fallbackExtensions), userExtensions, noInitWarn);\n    // setup the chain properties with format overrides\n    this.setChainProperties(extractProperties(this, metadata));\n  }\n  // sets the available signed extensions\n  setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions, noInitWarn) {\n    this.__internal__signedExtensions = signedExtensions;\n    this.__internal__userExtensions = userExtensions;\n    if (!noInitWarn) {\n      const unknown = findUnknownExtensions(this.__internal__signedExtensions, this.__internal__userExtensions);\n      if (unknown.length) {\n        l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}