{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, noop, objectSpread, stringify } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { DEFAULT_CAPACITY, LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2_500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5_000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n  Object.keys(record).forEach(key => {\n    if (cb) {\n      cb(record[key]);\n    }\n    delete record[key];\n  });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n  return {\n    bytesRecv: 0,\n    bytesSent: 0,\n    cached: 0,\n    errors: 0,\n    requests: 0,\n    subscriptions: 0,\n    timeout: 0\n  };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n  __internal__callCache;\n  __internal__coder;\n  __internal__endpoints;\n  __internal__headers;\n  __internal__eventemitter;\n  __internal__handlers = {};\n  __internal__isReadyPromise;\n  __internal__stats;\n  __internal__waitingForId = {};\n  __internal__autoConnectMs;\n  __internal__endpointIndex;\n  __internal__endpointStats;\n  __internal__isConnected = false;\n  __internal__subscriptions = {};\n  __internal__timeoutId = null;\n  __internal__websocket;\n  __internal__timeout;\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n   * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n   * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n   */\n  constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout, cacheCapacity) {\n    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    if (endpoints.length === 0) {\n      throw new Error('WsProvider requires at least one Endpoint');\n    }\n    endpoints.forEach(endpoint => {\n      if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n        throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n      }\n    });\n    this.__internal__callCache = new LRUCache(cacheCapacity || DEFAULT_CAPACITY);\n    this.__internal__eventemitter = new EventEmitter();\n    this.__internal__autoConnectMs = autoConnectMs || 0;\n    this.__internal__coder = new RpcCoder();\n    this.__internal__endpointIndex = -1;\n    this.__internal__endpoints = endpoints;\n    this.__internal__headers = headers;\n    this.__internal__websocket = null;\n    this.__internal__stats = {\n      active: {\n        requests: 0,\n        subscriptions: 0\n      },\n      total: defaultEndpointStats()\n    };\n    this.__internal__endpointStats = defaultEndpointStats();\n    this.__internal__timeout = timeout || DEFAULT_TIMEOUT_MS;\n    if (autoConnectMs && autoConnectMs > 0) {\n      this.connectWithRetry().catch(noop);\n    }\n    this.__internal__isReadyPromise = new Promise(resolve => {\n      this.__internal__eventemitter.once('connected', () => {\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n  get hasSubscriptions() {\n    return !!true;\n  }\n  /**\n   * @summary `true` when this provider supports clone()\n   */\n  get isClonable() {\n    return !!true;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n  get isConnected() {\n    return this.__internal__isConnected;\n  }\n  /**\n   * @description Promise that resolves the first time we are connected and loaded\n   */\n  get isReady() {\n    return this.__internal__isReadyPromise;\n  }\n  get endpoint() {\n    return this.__internal__endpoints[this.__internal__endpointIndex];\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n  clone() {\n    return new WsProvider(this.__internal__endpoints);\n  }\n  selectEndpointIndex(endpoints) {\n    return (this.__internal__endpointIndex + 1) % endpoints.length;\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async connect() {\n    if (this.__internal__websocket) {\n      throw new Error('WebSocket is already connected');\n    }\n    try {\n      this.__internal__endpointIndex = this.selectEndpointIndex(this.__internal__endpoints);\n      // the as here is Deno-specific - not available on the globalThis\n      this.__internal__websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(this.endpoint)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - WS may be an instance of ws, which supports options\n      : new WebSocket(this.endpoint, undefined, {\n        headers: this.__internal__headers\n      });\n      if (this.__internal__websocket) {\n        this.__internal__websocket.onclose = this.__internal__onSocketClose;\n        this.__internal__websocket.onerror = this.__internal__onSocketError;\n        this.__internal__websocket.onmessage = this.__internal__onSocketMessage;\n        this.__internal__websocket.onopen = this.__internal__onSocketOpen;\n      }\n      // timeout any handlers that have not had a response\n      this.__internal__timeoutId = setInterval(() => this.__internal__timeoutHandlers(), TIMEOUT_INTERVAL);\n    } catch (error) {\n      l.error(error);\n      this.__internal__emit('error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Connect, never throwing an error, but rather forcing a retry\n   */\n  async connectWithRetry() {\n    if (this.__internal__autoConnectMs > 0) {\n      try {\n        await this.connect();\n      } catch {\n        setTimeout(() => {\n          this.connectWithRetry().catch(noop);\n        }, this.__internal__autoConnectMs);\n      }\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing auto-connect logic\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async disconnect() {\n    // switch off autoConnect, we are in manual mode now\n    this.__internal__autoConnectMs = 0;\n    try {\n      if (this.__internal__websocket) {\n        // 1000 - Normal closure; the connection successfully completed\n        this.__internal__websocket.close(1000);\n      }\n    } catch (error) {\n      l.error(error);\n      this.__internal__emit('error', error);\n      throw error;\n    }\n  }\n  /**\n   * @description Returns the connection stats\n   */\n  get stats() {\n    return {\n      active: {\n        requests: Object.keys(this.__internal__handlers).length,\n        subscriptions: Object.keys(this.__internal__subscriptions).length\n      },\n      total: this.__internal__stats.total\n    };\n  }\n  get endpointStats() {\n    return this.__internal__endpointStats;\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   * @return unsubscribe function\n   */\n  on(type, sub) {\n    this.__internal__eventemitter.on(type, sub);\n    return () => {\n      this.__internal__eventemitter.removeListener(type, sub);\n    };\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded parameters as applicable for the method\n   * @param subscription Subscription details (internally used)\n   */\n  send(method, params, isCacheable, subscription) {\n    this.__internal__endpointStats.requests++;\n    this.__internal__stats.total.requests++;\n    const [id, body] = this.__internal__coder.encodeJson(method, params);\n    const cacheKey = isCacheable ? `${method}::${stringify(params)}` : '';\n    let resultPromise = isCacheable ? this.__internal__callCache.get(cacheKey) : null;\n    if (!resultPromise) {\n      resultPromise = this.__internal__send(id, body, method, params, subscription);\n      if (isCacheable) {\n        this.__internal__callCache.set(cacheKey, resultPromise);\n      }\n    } else {\n      this.__internal__endpointStats.cached++;\n      this.__internal__stats.total.cached++;\n    }\n    return resultPromise;\n  }\n  async __internal__send(id, body, method, params, subscription) {\n    return new Promise((resolve, reject) => {\n      try {\n        if (!this.isConnected || this.__internal__websocket === null) {\n          throw new Error('WebSocket is not connected');\n        }\n        const callback = (error, result) => {\n          error ? reject(error) : resolve(result);\n        };\n        l.debug(() => ['calling', method, body]);\n        this.__internal__handlers[id] = {\n          callback,\n          method,\n          params,\n          start: Date.now(),\n          subscription\n        };\n        const bytesSent = body.length;\n        this.__internal__endpointStats.bytesSent += bytesSent;\n        this.__internal__stats.total.bytesSent += bytesSent;\n        this.__internal__websocket.send(body);\n      } catch (error) {\n        this.__internal__endpointStats.errors++;\n        this.__internal__stats.total.errors++;\n        reject(error);\n      }\n    });\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n  subscribe(type, method, params, callback) {\n    this.__internal__endpointStats.subscriptions++;\n    this.__internal__stats.total.subscriptions++;\n    // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n    return this.send(method, params, false, {\n      callback,\n      type\n    });\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n  async unsubscribe(type, method, id) {\n    const subscription = `${type}::${id}`;\n    // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n    if (isUndefined(this.__internal__subscriptions[subscription])) {\n      l.debug(() => `Unable to find active subscription=${subscription}`);\n      return false;\n    }\n    delete this.__internal__subscriptions[subscription];\n    try {\n      return this.isConnected && !isNull(this.__internal__websocket) ? this.send(method, [id]) : true;\n    } catch {\n      return false;\n    }\n  }\n  __internal__emit = (type, ...args) => {\n    this.__internal__eventemitter.emit(type, ...args);\n  };\n  __internal__onSocketClose = event => {\n    const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n    if (this.__internal__autoConnectMs > 0) {\n      l.error(error.message);\n    }\n    this.__internal__isConnected = false;\n    if (this.__internal__websocket) {\n      this.__internal__websocket.onclose = null;\n      this.__internal__websocket.onerror = null;\n      this.__internal__websocket.onmessage = null;\n      this.__internal__websocket.onopen = null;\n      this.__internal__websocket = null;\n    }\n    if (this.__internal__timeoutId) {\n      clearInterval(this.__internal__timeoutId);\n      this.__internal__timeoutId = null;\n    }\n    // reject all hanging requests\n    eraseRecord(this.__internal__handlers, h => {\n      try {\n        h.callback(error, undefined);\n      } catch (err) {\n        // does not throw\n        l.error(err);\n      }\n    });\n    eraseRecord(this.__internal__waitingForId);\n    // Reset stats for active endpoint\n    this.__internal__endpointStats = defaultEndpointStats();\n    this.__internal__emit('disconnected');\n    if (this.__internal__autoConnectMs > 0) {\n      setTimeout(() => {\n        this.connectWithRetry().catch(noop);\n      }, this.__internal__autoConnectMs);\n    }\n  };\n  __internal__onSocketError = error => {\n    l.debug(() => ['socket error', error]);\n    this.__internal__emit('error', error);\n  };\n  __internal__onSocketMessage = message => {\n    l.debug(() => ['received', message.data]);\n    const bytesRecv = message.data.length;\n    this.__internal__endpointStats.bytesRecv += bytesRecv;\n    this.__internal__stats.total.bytesRecv += bytesRecv;\n    const response = JSON.parse(message.data);\n    return isUndefined(response.method) ? this.__internal__onSocketMessageResult(response) : this.__internal__onSocketMessageSubscribe(response);\n  };\n  __internal__onSocketMessageResult = response => {\n    const handler = this.__internal__handlers[response.id];\n    if (!handler) {\n      l.debug(() => `Unable to find handler for id=${response.id}`);\n      return;\n    }\n    try {\n      const {\n        method,\n        params,\n        subscription\n      } = handler;\n      const result = this.__internal__coder.decodeResponse(response);\n      // first send the result - in case of subs, we may have an update\n      // immediately if we have some queued results already\n      handler.callback(null, result);\n      if (subscription) {\n        const subId = `${subscription.type}::${result}`;\n        this.__internal__subscriptions[subId] = objectSpread({}, subscription, {\n          method,\n          params\n        });\n        // if we have a result waiting for this subscription already\n        if (this.__internal__waitingForId[subId]) {\n          this.__internal__onSocketMessageSubscribe(this.__internal__waitingForId[subId]);\n        }\n      }\n    } catch (error) {\n      this.__internal__endpointStats.errors++;\n      this.__internal__stats.total.errors++;\n      handler.callback(error, undefined);\n    }\n    delete this.__internal__handlers[response.id];\n  };\n  __internal__onSocketMessageSubscribe = response => {\n    if (!response.method) {\n      throw new Error('No method found in JSONRPC response');\n    }\n    const method = ALIASES[response.method] || response.method;\n    const subId = `${method}::${response.params.subscription}`;\n    const handler = this.__internal__subscriptions[subId];\n    if (!handler) {\n      // store the JSON, we could have out-of-order subid coming in\n      this.__internal__waitingForId[subId] = response;\n      l.debug(() => `Unable to find handler for subscription=${subId}`);\n      return;\n    }\n    // housekeeping\n    delete this.__internal__waitingForId[subId];\n    try {\n      const result = this.__internal__coder.decodeResponse(response);\n      handler.callback(null, result);\n    } catch (error) {\n      this.__internal__endpointStats.errors++;\n      this.__internal__stats.total.errors++;\n      handler.callback(error, undefined);\n    }\n  };\n  __internal__onSocketOpen = () => {\n    if (this.__internal__websocket === null) {\n      throw new Error('WebSocket cannot be null in onOpen');\n    }\n    l.debug(() => ['connected to', this.endpoint]);\n    this.__internal__isConnected = true;\n    this.__internal__resubscribe();\n    this.__internal__emit('connected');\n    return true;\n  };\n  __internal__resubscribe = () => {\n    const subscriptions = this.__internal__subscriptions;\n    this.__internal__subscriptions = {};\n    Promise.all(Object.keys(subscriptions).map(async id => {\n      const {\n        callback,\n        method,\n        params,\n        type\n      } = subscriptions[id];\n      // only re-create subscriptions which are not in author (only area where\n      // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n      // are not included (and will not be re-broadcast)\n      if (type.startsWith('author_')) {\n        return;\n      }\n      try {\n        await this.subscribe(type, method, params, callback);\n      } catch (error) {\n        l.error(error);\n      }\n    })).catch(l.error);\n  };\n  __internal__timeoutHandlers = () => {\n    const now = Date.now();\n    const ids = Object.keys(this.__internal__handlers);\n    for (let i = 0, count = ids.length; i < count; i++) {\n      const handler = this.__internal__handlers[ids[i]];\n      if (now - handler.start > this.__internal__timeout) {\n        try {\n          handler.callback(new Error(`No response received from RPC endpoint in ${this.__internal__timeout / 1000}s`), undefined);\n        } catch {\n          // ignore\n        }\n        this.__internal__endpointStats.timeout++;\n        this.__internal__stats.total.timeout++;\n        delete this.__internal__handlers[ids[i]];\n      }\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}