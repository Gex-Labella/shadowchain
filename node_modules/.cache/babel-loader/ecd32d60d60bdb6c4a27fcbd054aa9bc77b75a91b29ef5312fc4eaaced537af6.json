{"ast":null,"code":"/**\r\n * Frontend Crypto Service for Shadowchain\r\n * Handles X25519 key generation, storage, and decryption in the browser\r\n * Uses tweetnacl for cryptographic operations (pure JavaScript)\r\n */\n\nimport nacl from 'tweetnacl';\nimport naclUtil from 'tweetnacl-util';\nimport { Buffer } from 'buffer';\n\n// Ensure Buffer is available globally for compatibility\nif (typeof window !== 'undefined' && !window.Buffer) {\n  window.Buffer = Buffer;\n}\nclass CryptoService {\n  constructor() {\n    this.NONCE_LENGTH = nacl.secretbox.nonceLength;\n    this.KEY_LENGTH = nacl.secretbox.keyLength;\n    this.BOX_NONCE_LENGTH = nacl.box.nonceLength;\n    this.SALT_LENGTH = 16;\n    // For password hashing\n    this.currentKeyPair = null;\n  }\n  /**\r\n   * Generate a new X25519 keypair for encryption\r\n   */\n  async generateKeyPair() {\n    const keypair = nacl.box.keyPair();\n    return {\n      publicKey: naclUtil.encodeBase64(keypair.publicKey).replace(/\\//g, '_').replace(/\\+/g, '-'),\n      privateKey: naclUtil.encodeBase64(keypair.secretKey).replace(/\\//g, '_').replace(/\\+/g, '-')\n    };\n  }\n\n  /**\r\n   * Generate keypair from a seed (for deterministic key generation)\r\n   */\n  async generateKeyPairFromSeed(seed) {\n    if (seed.length !== 32) {\n      throw new Error(`Seed must be 32 bytes`);\n    }\n    const keypair = nacl.box.keyPair.fromSecretKey(seed);\n    return {\n      publicKey: naclUtil.encodeBase64(keypair.publicKey).replace(/\\//g, '_').replace(/\\+/g, '-'),\n      privateKey: naclUtil.encodeBase64(keypair.secretKey).replace(/\\//g, '_').replace(/\\+/g, '-')\n    };\n  }\n\n  /**\r\n   * Derive a key from password using PBKDF2-like approach\r\n   */\n  async deriveKeyFromPassword(password, salt) {\n    // Use a simple PBKDF2-like approach with nacl.hash\n    // This is a simplified version - in production, consider using a proper PBKDF2 implementation\n    const encoder = new TextEncoder();\n    const passwordBytes = encoder.encode(password);\n\n    // Combine password and salt\n    const combined = new Uint8Array(passwordBytes.length + salt.length);\n    combined.set(passwordBytes, 0);\n    combined.set(salt, passwordBytes.length);\n\n    // Hash multiple times for key stretching\n    let hash = nacl.hash(combined);\n    for (let i = 0; i < 1000; i++) {\n      hash = nacl.hash(hash);\n    }\n\n    // Take first 32 bytes for key\n    return hash.slice(0, 32);\n  }\n\n  /**\r\n   * Encrypt private key with password for secure storage\r\n   */\n  async encryptPrivateKey(privateKey, password) {\n    // Generate salt and nonce\n    const salt = nacl.randomBytes(this.SALT_LENGTH);\n    const nonce = nacl.randomBytes(this.NONCE_LENGTH);\n\n    // Derive key from password\n    const key = await this.deriveKeyFromPassword(password, salt);\n\n    // Decode private key from base64\n    const privateKeyBytes = naclUtil.decodeBase64(privateKey.replace(/_/g, '/').replace(/-/g, '+'));\n\n    // Encrypt private key\n    const encryptedKey = nacl.secretbox(privateKeyBytes, nonce, key);\n\n    // Clear sensitive data\n    key.fill(0);\n    privateKeyBytes.fill(0);\n    return {\n      encryptedKey: naclUtil.encodeBase64(encryptedKey),\n      salt: naclUtil.encodeBase64(salt),\n      nonce: naclUtil.encodeBase64(nonce)\n    };\n  }\n\n  /**\r\n   * Decrypt private key with password\r\n   */\n  async decryptPrivateKey(encryptedKey, password, salt, nonce) {\n    const saltBytes = naclUtil.decodeBase64(salt);\n    const nonceBytes = naclUtil.decodeBase64(nonce);\n    const encryptedKeyBytes = naclUtil.decodeBase64(encryptedKey);\n\n    // Derive key from password\n    const key = await this.deriveKeyFromPassword(password, saltBytes);\n    try {\n      // Decrypt private key\n      const privateKeyBytes = nacl.secretbox.open(encryptedKeyBytes, nonceBytes, key);\n      if (!privateKeyBytes) {\n        throw new Error('Failed to decrypt - invalid password');\n      }\n      const privateKey = naclUtil.encodeBase64(privateKeyBytes).replace(/\\//g, '_').replace(/\\+/g, '-');\n\n      // Clear sensitive data\n      privateKeyBytes.fill(0);\n      return privateKey;\n    } finally {\n      // Always clear the derived key\n      key.fill(0);\n    }\n  }\n\n  /**\r\n   * Store keypair securely in localStorage\r\n   */\n  async storeKeyPair(keyPair, password) {\n    const encrypted = await this.encryptPrivateKey(keyPair.privateKey, password);\n    const storedKeyPair = {\n      publicKey: keyPair.publicKey,\n      encryptedPrivateKey: encrypted.encryptedKey,\n      salt: encrypted.salt,\n      nonce: encrypted.nonce\n    };\n    localStorage.setItem('shadowchain_encryption_key', JSON.stringify(storedKeyPair));\n\n    // Also set as current keypair\n    this.currentKeyPair = keyPair;\n  }\n\n  /**\r\n   * Load keypair from localStorage\r\n   */\n  async loadKeyPair(password) {\n    const stored = localStorage.getItem('shadowchain_encryption_key');\n    if (!stored) return null;\n    try {\n      const storedKeyPair = JSON.parse(stored);\n      const privateKey = await this.decryptPrivateKey(storedKeyPair.encryptedPrivateKey, password, storedKeyPair.salt, storedKeyPair.nonce);\n      const keyPair = {\n        publicKey: storedKeyPair.publicKey,\n        privateKey\n      };\n\n      // Set as current keypair\n      this.currentKeyPair = keyPair;\n      return keyPair;\n    } catch (error) {\n      console.error('Failed to load keypair:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Check if a keypair exists in storage\r\n   */\n  hasStoredKeyPair() {\n    return localStorage.getItem('shadowchain_encryption_key') !== null;\n  }\n\n  /**\r\n   * Clear stored keypair\r\n   */\n  clearStoredKeyPair() {\n    localStorage.removeItem('shadowchain_encryption_key');\n    this.currentKeyPair = null;\n  }\n\n  /**\r\n   * Get current keypair (if loaded)\r\n   */\n  getCurrentKeyPair() {\n    return this.currentKeyPair;\n  }\n\n  /**\r\n   * Convert hex to Uint8Array\r\n   */\n  hexToUint8Array(hex) {\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n      bytes[i / 2] = parseInt(hex.substr(i, 2), 16);\n    }\n    return bytes;\n  }\n\n  /**\r\n   * Convert Uint8Array to hex\r\n   */\n  uint8ArrayToHex(bytes) {\n    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\r\n   * Decrypt symmetric key using private key\r\n   */\n  async decryptSymmetricKey(encryptedKey, publicKey, privateKey) {\n    const encryptedKeyBytes = this.hexToUint8Array(encryptedKey);\n    const privateKeyBytes = naclUtil.decodeBase64(privateKey.replace(/_/g, '/').replace(/-/g, '+'));\n\n    // Extract components from sealed box format\n    const ephemeralPublicKey = encryptedKeyBytes.slice(0, nacl.box.publicKeyLength);\n    const nonce = encryptedKeyBytes.slice(nacl.box.publicKeyLength, nacl.box.publicKeyLength + this.BOX_NONCE_LENGTH);\n    const ciphertext = encryptedKeyBytes.slice(nacl.box.publicKeyLength + this.BOX_NONCE_LENGTH);\n\n    // Decrypt using nacl.box.open\n    const decrypted = nacl.box.open(ciphertext, nonce, ephemeralPublicKey, privateKeyBytes);\n    if (!decrypted) {\n      throw new Error('Failed to decrypt symmetric key');\n    }\n\n    // Clear sensitive data\n    privateKeyBytes.fill(0);\n    return decrypted;\n  }\n\n  /**\r\n   * Decrypt content using XChaCha20-Poly1305\r\n   */\n  async decryptContent(ciphertext, nonce, symmetricKey) {\n    const ciphertextBytes = this.hexToUint8Array(ciphertext);\n    const nonceBytes = this.hexToUint8Array(nonce);\n    try {\n      // Use secretbox for symmetric decryption (XSalsa20-Poly1305)\n      const plaintext = nacl.secretbox.open(ciphertextBytes, nonceBytes, symmetricKey);\n      if (!plaintext) {\n        throw new Error('Failed to decrypt content');\n      }\n      return new TextDecoder().decode(plaintext);\n    } finally {\n      // Clear symmetric key\n      symmetricKey.fill(0);\n    }\n  }\n\n  /**\r\n   * Decrypt shadow item from blockchain\r\n   */\n  async decryptShadowItem(ciphertext, nonce, encryptedKey) {\n    if (!this.currentKeyPair) {\n      throw new Error('No keypair loaded. Please unlock your encryption keys.');\n    }\n    try {\n      // Decrypt the symmetric key\n      const symmetricKey = await this.decryptSymmetricKey(encryptedKey, this.currentKeyPair.publicKey, this.currentKeyPair.privateKey);\n\n      // Decrypt the content\n      const decryptedJson = await this.decryptContent(ciphertext, nonce, symmetricKey);\n\n      // Parse the decrypted content\n      const content = JSON.parse(decryptedJson);\n      return {\n        content: content.body || content.content || '',\n        timestamp: content.timestamp,\n        source: content.source\n      };\n    } catch (error) {\n      console.error('Failed to decrypt shadow item:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Create a signature message for key ownership proof\r\n   */\n  createKeyOwnershipMessage(polkadotAddress, encryptionPublicKey) {\n    return `I authorize Shadowchain to use encryption key ${encryptionPublicKey} for my account ${polkadotAddress}`;\n  }\n\n  /**\r\n   * Export keypair (encrypted)\r\n   */\n  async exportKeyPair(password) {\n    const stored = localStorage.getItem('shadowchain_encryption_key');\n    if (!stored) throw new Error('No keypair to export');\n    const exportData = {\n      version: 1,\n      timestamp: Date.now(),\n      data: JSON.parse(stored)\n    };\n\n    // Additional encryption layer for export\n    const exportPassword = `shadowchain_export_${password}`;\n    const exportString = JSON.stringify(exportData);\n    const encoder = new TextEncoder();\n    const exportBytes = encoder.encode(exportString);\n\n    // Generate salt and nonce for export\n    const salt = nacl.randomBytes(this.SALT_LENGTH);\n    const nonce = nacl.randomBytes(this.NONCE_LENGTH);\n\n    // Derive key from export password\n    const key = await this.deriveKeyFromPassword(exportPassword, salt);\n\n    // Encrypt the export data\n    const encrypted = nacl.secretbox(exportBytes, nonce, key);\n\n    // Clear sensitive data\n    key.fill(0);\n    return JSON.stringify({\n      type: 'shadowchain_keypair_export',\n      encrypted: naclUtil.encodeBase64(encrypted),\n      salt: naclUtil.encodeBase64(salt),\n      nonce: naclUtil.encodeBase64(nonce)\n    });\n  }\n\n  /**\r\n   * Import keypair\r\n   */\n  async importKeyPair(exportedData, password) {\n    try {\n      const parsed = JSON.parse(exportedData);\n      if (parsed.type !== 'shadowchain_keypair_export') {\n        throw new Error('Invalid export format');\n      }\n      const exportPassword = `shadowchain_export_${password}`;\n      const salt = naclUtil.decodeBase64(parsed.salt);\n      const nonce = naclUtil.decodeBase64(parsed.nonce);\n      const encrypted = naclUtil.decodeBase64(parsed.encrypted);\n\n      // Derive key from export password\n      const key = await this.deriveKeyFromPassword(exportPassword, salt);\n\n      // Decrypt the export data\n      const decrypted = nacl.secretbox.open(encrypted, nonce, key);\n      if (!decrypted) {\n        throw new Error('Failed to decrypt - invalid password');\n      }\n\n      // Clear sensitive data\n      key.fill(0);\n      const decoder = new TextDecoder();\n      const exportData = JSON.parse(decoder.decode(decrypted));\n\n      // Store the imported keypair\n      localStorage.setItem('shadowchain_encryption_key', JSON.stringify(exportData.data));\n\n      // Try to load it\n      await this.loadKeyPair(password);\n    } catch (error) {\n      throw new Error('Failed to import keypair: ' + error.message);\n    }\n  }\n\n  /**\r\n   * Generate a secure password hint (first and last 3 chars)\r\n   */\n  generatePasswordHint(password) {\n    if (password.length <= 6) return '*'.repeat(password.length);\n    return password.slice(0, 3) + '*'.repeat(password.length - 6) + password.slice(-3);\n  }\n\n  /**\r\n   * Check if stored keys exist and their status\r\n   */\n  async loadStoredKeys() {\n    const stored = localStorage.getItem('shadowchain_encryption_key');\n    if (!stored) {\n      return null;\n    }\n\n    // Keys exist but we need to check if they're unlocked (loaded in memory)\n    return {\n      unlocked: this.currentKeyPair !== null\n    };\n  }\n\n  /**\r\n   * Export keys for backup (simplified version for UI)\r\n   */\n  async exportKeys() {\n    const stored = localStorage.getItem('shadowchain_encryption_key');\n    if (!stored) {\n      return null;\n    }\n    try {\n      const storedKeyPair = JSON.parse(stored);\n      return {\n        publicKey: storedKeyPair.publicKey,\n        encryptedPrivateKey: storedKeyPair.encryptedPrivateKey,\n        salt: storedKeyPair.salt,\n        nonce: storedKeyPair.nonce\n      };\n    } catch (error) {\n      console.error('Failed to export keys:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Import keys from backup (simplified version for UI)\r\n   */\n  async importKeys(keys) {\n    try {\n      // Handle both full export format and simplified format\n      let storedKeyPair;\n      if (keys.salt && keys.nonce) {\n        // Direct import of encrypted keys\n        storedKeyPair = {\n          publicKey: keys.publicKey,\n          encryptedPrivateKey: keys.encryptedPrivateKey,\n          salt: keys.salt,\n          nonce: keys.nonce\n        };\n      } else {\n        // Legacy format or incomplete data\n        console.error('Invalid key format - missing salt or nonce');\n        return false;\n      }\n\n      // Store the imported keypair\n      localStorage.setItem('shadowchain_encryption_key', JSON.stringify(storedKeyPair));\n\n      // Don't automatically load - user will need to unlock with password\n      this.currentKeyPair = null;\n      return true;\n    } catch (error) {\n      console.error('Failed to import keys:', error);\n      return false;\n    }\n  }\n}\n\n// Export singleton instance\nexport const cryptoService = new CryptoService();","map":{"version":3,"names":["nacl","naclUtil","Buffer","window","CryptoService","constructor","NONCE_LENGTH","secretbox","nonceLength","KEY_LENGTH","keyLength","BOX_NONCE_LENGTH","box","SALT_LENGTH","currentKeyPair","generateKeyPair","keypair","keyPair","publicKey","encodeBase64","replace","privateKey","secretKey","generateKeyPairFromSeed","seed","length","Error","fromSecretKey","deriveKeyFromPassword","password","salt","encoder","TextEncoder","passwordBytes","encode","combined","Uint8Array","set","hash","i","slice","encryptPrivateKey","randomBytes","nonce","key","privateKeyBytes","decodeBase64","encryptedKey","fill","decryptPrivateKey","saltBytes","nonceBytes","encryptedKeyBytes","open","storeKeyPair","encrypted","storedKeyPair","encryptedPrivateKey","localStorage","setItem","JSON","stringify","loadKeyPair","stored","getItem","parse","error","console","hasStoredKeyPair","clearStoredKeyPair","removeItem","getCurrentKeyPair","hexToUint8Array","hex","bytes","parseInt","substr","uint8ArrayToHex","Array","from","map","b","toString","padStart","join","decryptSymmetricKey","ephemeralPublicKey","publicKeyLength","ciphertext","decrypted","decryptContent","symmetricKey","ciphertextBytes","plaintext","TextDecoder","decode","decryptShadowItem","decryptedJson","content","body","timestamp","source","createKeyOwnershipMessage","polkadotAddress","encryptionPublicKey","exportKeyPair","exportData","version","Date","now","data","exportPassword","exportString","exportBytes","type","importKeyPair","exportedData","parsed","decoder","message","generatePasswordHint","repeat","loadStoredKeys","unlocked","exportKeys","importKeys","keys","cryptoService"],"sources":["C:/Users/Admin/Documents/Keiths/Polkadot/shadowchain/frontend/src/services/crypto.ts"],"sourcesContent":["/**\r\n * Frontend Crypto Service for Shadowchain\r\n * Handles X25519 key generation, storage, and decryption in the browser\r\n * Uses tweetnacl for cryptographic operations (pure JavaScript)\r\n */\r\n\r\nimport nacl from 'tweetnacl';\r\nimport naclUtil from 'tweetnacl-util';\r\nimport { Buffer } from 'buffer';\r\n\r\n// Ensure Buffer is available globally for compatibility\r\nif (typeof window !== 'undefined' && !window.Buffer) {\r\n  window.Buffer = Buffer;\r\n}\r\n\r\nexport interface EncryptionKeyPair {\r\n  publicKey: string; // hex encoded\r\n  privateKey: string; // hex encoded\r\n}\r\n\r\nexport interface StoredKeyPair {\r\n  publicKey: string;\r\n  encryptedPrivateKey: string; // encrypted with password\r\n  salt: string;\r\n  nonce: string;\r\n}\r\n\r\nexport interface DecryptedContent {\r\n  content: string;\r\n  timestamp: number;\r\n  source: 'GitHub' | 'Twitter';\r\n}\r\n\r\nclass CryptoService {\r\n  private readonly NONCE_LENGTH = nacl.secretbox.nonceLength;\r\n  private readonly KEY_LENGTH = nacl.secretbox.keyLength;\r\n  private readonly BOX_NONCE_LENGTH = nacl.box.nonceLength;\r\n  private readonly SALT_LENGTH = 16; // For password hashing\r\n  private currentKeyPair: EncryptionKeyPair | null = null;\r\n\r\n  /**\r\n   * Generate a new X25519 keypair for encryption\r\n   */\r\n  async generateKeyPair(): Promise<EncryptionKeyPair> {\r\n    const keypair = nacl.box.keyPair();\r\n    \r\n    return {\r\n      publicKey: naclUtil.encodeBase64(keypair.publicKey).replace(/\\//g, '_').replace(/\\+/g, '-'),\r\n      privateKey: naclUtil.encodeBase64(keypair.secretKey).replace(/\\//g, '_').replace(/\\+/g, '-')\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate keypair from a seed (for deterministic key generation)\r\n   */\r\n  async generateKeyPairFromSeed(seed: Uint8Array): Promise<EncryptionKeyPair> {\r\n    if (seed.length !== 32) {\r\n      throw new Error(`Seed must be 32 bytes`);\r\n    }\r\n    \r\n    const keypair = nacl.box.keyPair.fromSecretKey(seed);\r\n    \r\n    return {\r\n      publicKey: naclUtil.encodeBase64(keypair.publicKey).replace(/\\//g, '_').replace(/\\+/g, '-'),\r\n      privateKey: naclUtil.encodeBase64(keypair.secretKey).replace(/\\//g, '_').replace(/\\+/g, '-')\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Derive a key from password using PBKDF2-like approach\r\n   */\r\n  private async deriveKeyFromPassword(password: string, salt: Uint8Array): Promise<Uint8Array> {\r\n    // Use a simple PBKDF2-like approach with nacl.hash\r\n    // This is a simplified version - in production, consider using a proper PBKDF2 implementation\r\n    const encoder = new TextEncoder();\r\n    const passwordBytes = encoder.encode(password);\r\n    \r\n    // Combine password and salt\r\n    const combined = new Uint8Array(passwordBytes.length + salt.length);\r\n    combined.set(passwordBytes, 0);\r\n    combined.set(salt, passwordBytes.length);\r\n    \r\n    // Hash multiple times for key stretching\r\n    let hash = nacl.hash(combined);\r\n    for (let i = 0; i < 1000; i++) {\r\n      hash = nacl.hash(hash);\r\n    }\r\n    \r\n    // Take first 32 bytes for key\r\n    return hash.slice(0, 32);\r\n  }\r\n\r\n  /**\r\n   * Encrypt private key with password for secure storage\r\n   */\r\n  async encryptPrivateKey(privateKey: string, password: string): Promise<{\r\n    encryptedKey: string;\r\n    salt: string;\r\n    nonce: string;\r\n  }> {\r\n    // Generate salt and nonce\r\n    const salt = nacl.randomBytes(this.SALT_LENGTH);\r\n    const nonce = nacl.randomBytes(this.NONCE_LENGTH);\r\n    \r\n    // Derive key from password\r\n    const key = await this.deriveKeyFromPassword(password, salt);\r\n    \r\n    // Decode private key from base64\r\n    const privateKeyBytes = naclUtil.decodeBase64(privateKey.replace(/_/g, '/').replace(/-/g, '+'));\r\n    \r\n    // Encrypt private key\r\n    const encryptedKey = nacl.secretbox(privateKeyBytes, nonce, key);\r\n    \r\n    // Clear sensitive data\r\n    key.fill(0);\r\n    privateKeyBytes.fill(0);\r\n    \r\n    return {\r\n      encryptedKey: naclUtil.encodeBase64(encryptedKey),\r\n      salt: naclUtil.encodeBase64(salt),\r\n      nonce: naclUtil.encodeBase64(nonce)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Decrypt private key with password\r\n   */\r\n  async decryptPrivateKey(\r\n    encryptedKey: string,\r\n    password: string,\r\n    salt: string,\r\n    nonce: string\r\n  ): Promise<string> {\r\n    const saltBytes = naclUtil.decodeBase64(salt);\r\n    const nonceBytes = naclUtil.decodeBase64(nonce);\r\n    const encryptedKeyBytes = naclUtil.decodeBase64(encryptedKey);\r\n    \r\n    // Derive key from password\r\n    const key = await this.deriveKeyFromPassword(password, saltBytes);\r\n    \r\n    try {\r\n      // Decrypt private key\r\n      const privateKeyBytes = nacl.secretbox.open(encryptedKeyBytes, nonceBytes, key);\r\n      \r\n      if (!privateKeyBytes) {\r\n        throw new Error('Failed to decrypt - invalid password');\r\n      }\r\n      \r\n      const privateKey = naclUtil.encodeBase64(privateKeyBytes).replace(/\\//g, '_').replace(/\\+/g, '-');\r\n      \r\n      // Clear sensitive data\r\n      privateKeyBytes.fill(0);\r\n      \r\n      return privateKey;\r\n    } finally {\r\n      // Always clear the derived key\r\n      key.fill(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Store keypair securely in localStorage\r\n   */\r\n  async storeKeyPair(keyPair: EncryptionKeyPair, password: string): Promise<void> {\r\n    const encrypted = await this.encryptPrivateKey(keyPair.privateKey, password);\r\n    \r\n    const storedKeyPair: StoredKeyPair = {\r\n      publicKey: keyPair.publicKey,\r\n      encryptedPrivateKey: encrypted.encryptedKey,\r\n      salt: encrypted.salt,\r\n      nonce: encrypted.nonce\r\n    };\r\n    \r\n    localStorage.setItem('shadowchain_encryption_key', JSON.stringify(storedKeyPair));\r\n    \r\n    // Also set as current keypair\r\n    this.currentKeyPair = keyPair;\r\n  }\r\n\r\n  /**\r\n   * Load keypair from localStorage\r\n   */\r\n  async loadKeyPair(password: string): Promise<EncryptionKeyPair | null> {\r\n    const stored = localStorage.getItem('shadowchain_encryption_key');\r\n    if (!stored) return null;\r\n    \r\n    try {\r\n      const storedKeyPair: StoredKeyPair = JSON.parse(stored);\r\n      \r\n      const privateKey = await this.decryptPrivateKey(\r\n        storedKeyPair.encryptedPrivateKey,\r\n        password,\r\n        storedKeyPair.salt,\r\n        storedKeyPair.nonce\r\n      );\r\n      \r\n      const keyPair = {\r\n        publicKey: storedKeyPair.publicKey,\r\n        privateKey\r\n      };\r\n      \r\n      // Set as current keypair\r\n      this.currentKeyPair = keyPair;\r\n      \r\n      return keyPair;\r\n    } catch (error) {\r\n      console.error('Failed to load keypair:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a keypair exists in storage\r\n   */\r\n  hasStoredKeyPair(): boolean {\r\n    return localStorage.getItem('shadowchain_encryption_key') !== null;\r\n  }\r\n\r\n  /**\r\n   * Clear stored keypair\r\n   */\r\n  clearStoredKeyPair(): void {\r\n    localStorage.removeItem('shadowchain_encryption_key');\r\n    this.currentKeyPair = null;\r\n  }\r\n\r\n  /**\r\n   * Get current keypair (if loaded)\r\n   */\r\n  getCurrentKeyPair(): EncryptionKeyPair | null {\r\n    return this.currentKeyPair;\r\n  }\r\n\r\n  /**\r\n   * Convert hex to Uint8Array\r\n   */\r\n  private hexToUint8Array(hex: string): Uint8Array {\r\n    const bytes = new Uint8Array(hex.length / 2);\r\n    for (let i = 0; i < hex.length; i += 2) {\r\n      bytes[i / 2] = parseInt(hex.substr(i, 2), 16);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Convert Uint8Array to hex\r\n   */\r\n  private uint8ArrayToHex(bytes: Uint8Array): string {\r\n    return Array.from(bytes)\r\n      .map(b => b.toString(16).padStart(2, '0'))\r\n      .join('');\r\n  }\r\n\r\n  /**\r\n   * Decrypt symmetric key using private key\r\n   */\r\n  async decryptSymmetricKey(\r\n    encryptedKey: string,\r\n    publicKey: string,\r\n    privateKey: string\r\n  ): Promise<Uint8Array> {\r\n    const encryptedKeyBytes = this.hexToUint8Array(encryptedKey);\r\n    const privateKeyBytes = naclUtil.decodeBase64(privateKey.replace(/_/g, '/').replace(/-/g, '+'));\r\n    \r\n    // Extract components from sealed box format\r\n    const ephemeralPublicKey = encryptedKeyBytes.slice(0, nacl.box.publicKeyLength);\r\n    const nonce = encryptedKeyBytes.slice(nacl.box.publicKeyLength, nacl.box.publicKeyLength + this.BOX_NONCE_LENGTH);\r\n    const ciphertext = encryptedKeyBytes.slice(nacl.box.publicKeyLength + this.BOX_NONCE_LENGTH);\r\n    \r\n    // Decrypt using nacl.box.open\r\n    const decrypted = nacl.box.open(ciphertext, nonce, ephemeralPublicKey, privateKeyBytes);\r\n    \r\n    if (!decrypted) {\r\n      throw new Error('Failed to decrypt symmetric key');\r\n    }\r\n    \r\n    // Clear sensitive data\r\n    privateKeyBytes.fill(0);\r\n    \r\n    return decrypted;\r\n  }\r\n\r\n  /**\r\n   * Decrypt content using XChaCha20-Poly1305\r\n   */\r\n  async decryptContent(\r\n    ciphertext: string,\r\n    nonce: string,\r\n    symmetricKey: Uint8Array\r\n  ): Promise<string> {\r\n    const ciphertextBytes = this.hexToUint8Array(ciphertext);\r\n    const nonceBytes = this.hexToUint8Array(nonce);\r\n    \r\n    try {\r\n      // Use secretbox for symmetric decryption (XSalsa20-Poly1305)\r\n      const plaintext = nacl.secretbox.open(ciphertextBytes, nonceBytes, symmetricKey);\r\n      \r\n      if (!plaintext) {\r\n        throw new Error('Failed to decrypt content');\r\n      }\r\n      \r\n      return new TextDecoder().decode(plaintext);\r\n    } finally {\r\n      // Clear symmetric key\r\n      symmetricKey.fill(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decrypt shadow item from blockchain\r\n   */\r\n  async decryptShadowItem(\r\n    ciphertext: string,\r\n    nonce: string,\r\n    encryptedKey: string\r\n  ): Promise<DecryptedContent | null> {\r\n    if (!this.currentKeyPair) {\r\n      throw new Error('No keypair loaded. Please unlock your encryption keys.');\r\n    }\r\n    \r\n    try {\r\n      // Decrypt the symmetric key\r\n      const symmetricKey = await this.decryptSymmetricKey(\r\n        encryptedKey,\r\n        this.currentKeyPair.publicKey,\r\n        this.currentKeyPair.privateKey\r\n      );\r\n      \r\n      // Decrypt the content\r\n      const decryptedJson = await this.decryptContent(ciphertext, nonce, symmetricKey);\r\n      \r\n      // Parse the decrypted content\r\n      const content = JSON.parse(decryptedJson);\r\n      \r\n      return {\r\n        content: content.body || content.content || '',\r\n        timestamp: content.timestamp,\r\n        source: content.source\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to decrypt shadow item:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a signature message for key ownership proof\r\n   */\r\n  createKeyOwnershipMessage(polkadotAddress: string, encryptionPublicKey: string): string {\r\n    return `I authorize Shadowchain to use encryption key ${encryptionPublicKey} for my account ${polkadotAddress}`;\r\n  }\r\n\r\n  /**\r\n   * Export keypair (encrypted)\r\n   */\r\n  async exportKeyPair(password: string): Promise<string> {\r\n    const stored = localStorage.getItem('shadowchain_encryption_key');\r\n    if (!stored) throw new Error('No keypair to export');\r\n    \r\n    const exportData = {\r\n      version: 1,\r\n      timestamp: Date.now(),\r\n      data: JSON.parse(stored)\r\n    };\r\n    \r\n    // Additional encryption layer for export\r\n    const exportPassword = `shadowchain_export_${password}`;\r\n    const exportString = JSON.stringify(exportData);\r\n    const encoder = new TextEncoder();\r\n    const exportBytes = encoder.encode(exportString);\r\n    \r\n    // Generate salt and nonce for export\r\n    const salt = nacl.randomBytes(this.SALT_LENGTH);\r\n    const nonce = nacl.randomBytes(this.NONCE_LENGTH);\r\n    \r\n    // Derive key from export password\r\n    const key = await this.deriveKeyFromPassword(exportPassword, salt);\r\n    \r\n    // Encrypt the export data\r\n    const encrypted = nacl.secretbox(exportBytes, nonce, key);\r\n    \r\n    // Clear sensitive data\r\n    key.fill(0);\r\n    \r\n    return JSON.stringify({\r\n      type: 'shadowchain_keypair_export',\r\n      encrypted: naclUtil.encodeBase64(encrypted),\r\n      salt: naclUtil.encodeBase64(salt),\r\n      nonce: naclUtil.encodeBase64(nonce)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Import keypair\r\n   */\r\n  async importKeyPair(exportedData: string, password: string): Promise<void> {\r\n    try {\r\n      const parsed = JSON.parse(exportedData);\r\n      if (parsed.type !== 'shadowchain_keypair_export') {\r\n        throw new Error('Invalid export format');\r\n      }\r\n      \r\n      const exportPassword = `shadowchain_export_${password}`;\r\n      const salt = naclUtil.decodeBase64(parsed.salt);\r\n      const nonce = naclUtil.decodeBase64(parsed.nonce);\r\n      const encrypted = naclUtil.decodeBase64(parsed.encrypted);\r\n      \r\n      // Derive key from export password\r\n      const key = await this.deriveKeyFromPassword(exportPassword, salt);\r\n      \r\n      // Decrypt the export data\r\n      const decrypted = nacl.secretbox.open(encrypted, nonce, key);\r\n      \r\n      if (!decrypted) {\r\n        throw new Error('Failed to decrypt - invalid password');\r\n      }\r\n      \r\n      // Clear sensitive data\r\n      key.fill(0);\r\n      \r\n      const decoder = new TextDecoder();\r\n      const exportData = JSON.parse(decoder.decode(decrypted));\r\n      \r\n      // Store the imported keypair\r\n      localStorage.setItem('shadowchain_encryption_key', JSON.stringify(exportData.data));\r\n      \r\n      // Try to load it\r\n      await this.loadKeyPair(password);\r\n    } catch (error) {\r\n      throw new Error('Failed to import keypair: ' + (error as Error).message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a secure password hint (first and last 3 chars)\r\n   */\r\n  generatePasswordHint(password: string): string {\r\n    if (password.length <= 6) return '*'.repeat(password.length);\r\n    return password.slice(0, 3) + '*'.repeat(password.length - 6) + password.slice(-3);\r\n  }\r\n\r\n  /**\r\n   * Check if stored keys exist and their status\r\n   */\r\n  async loadStoredKeys(): Promise<{ unlocked: boolean } | null> {\r\n    const stored = localStorage.getItem('shadowchain_encryption_key');\r\n    if (!stored) {\r\n      return null;\r\n    }\r\n\r\n    // Keys exist but we need to check if they're unlocked (loaded in memory)\r\n    return {\r\n      unlocked: this.currentKeyPair !== null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Export keys for backup (simplified version for UI)\r\n   */\r\n  async exportKeys(): Promise<{ publicKey: string; encryptedPrivateKey: string; salt: string; nonce: string } | null> {\r\n    const stored = localStorage.getItem('shadowchain_encryption_key');\r\n    if (!stored) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const storedKeyPair: StoredKeyPair = JSON.parse(stored);\r\n      return {\r\n        publicKey: storedKeyPair.publicKey,\r\n        encryptedPrivateKey: storedKeyPair.encryptedPrivateKey,\r\n        salt: storedKeyPair.salt,\r\n        nonce: storedKeyPair.nonce\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to export keys:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Import keys from backup (simplified version for UI)\r\n   */\r\n  async importKeys(keys: { publicKey: string; encryptedPrivateKey: string; salt?: string; nonce?: string }): Promise<boolean> {\r\n    try {\r\n      // Handle both full export format and simplified format\r\n      let storedKeyPair: StoredKeyPair;\r\n      \r\n      if (keys.salt && keys.nonce) {\r\n        // Direct import of encrypted keys\r\n        storedKeyPair = {\r\n          publicKey: keys.publicKey,\r\n          encryptedPrivateKey: keys.encryptedPrivateKey,\r\n          salt: keys.salt,\r\n          nonce: keys.nonce\r\n        };\r\n      } else {\r\n        // Legacy format or incomplete data\r\n        console.error('Invalid key format - missing salt or nonce');\r\n        return false;\r\n      }\r\n\r\n      // Store the imported keypair\r\n      localStorage.setItem('shadowchain_encryption_key', JSON.stringify(storedKeyPair));\r\n      \r\n      // Don't automatically load - user will need to unlock with password\r\n      this.currentKeyPair = null;\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to import keys:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const cryptoService = new CryptoService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}