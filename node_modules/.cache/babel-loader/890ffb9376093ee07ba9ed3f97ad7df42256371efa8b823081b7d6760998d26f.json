{"ast":null,"code":"import { isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\n/** @internal */\nfunction decodeU8aFixed(value, bitLength) {\n  const u8a = u8aToU8a(value);\n  const byteLength = bitLength / 8;\n  if (!u8a.length) {\n    return [new Uint8Array(byteLength), 0];\n  }\n  if (isU8a(value) ? u8a.length < byteLength : u8a.length !== byteLength) {\n    throw new Error(`Expected input with ${byteLength} bytes (${bitLength} bits), found ${u8a.length} bytes`);\n  }\n  return [u8a.subarray(0, byteLength), byteLength];\n}\n/**\n * @name U8aFixed\n * @description\n * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant\n * to be used directly, rather is should be subclassed with the specific lengths.\n */\nexport class U8aFixed extends Raw {\n  constructor(registry, value = new Uint8Array(), bitLength = 256) {\n    const [u8a, decodedLength] = decodeU8aFixed(value, bitLength);\n    super(registry, u8a, decodedLength);\n  }\n  static with(bitLength, typeName) {\n    return class extends U8aFixed {\n      constructor(registry, value) {\n        super(registry, value, bitLength);\n      }\n      toRawType() {\n        return typeName || super.toRawType();\n      }\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `[u8;${this.length}]`;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}