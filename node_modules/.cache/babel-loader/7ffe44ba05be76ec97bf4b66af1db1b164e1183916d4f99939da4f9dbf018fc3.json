{"ast":null,"code":"/**\n * @name u8aToNumber\n * @summary Creates a number from a Uint8Array object.\n */\nexport function u8aToNumber(value, {\n  isLe = true,\n  isNegative = false\n} = {}) {\n  // slice + reverse is expensive, however SCALE is LE by default so this is the path\n  // we are most interested in (the BE is added for the sake of being comprehensive)\n  if (!isLe) {\n    value = value.slice().reverse();\n  }\n  const count = value.length;\n  // When the value is a i{8, 16, 24, 32, 40, 40} values and the top-most bit\n  // indicates a signed value, we use a two's complement conversion. If one of these\n  // flags are not set, we just do a normal unsigned conversion (the same shortcut\n  // applies in both the u8aTo{BigInt, Bn} conversions as well)\n  if (isNegative && count && value[count - 1] & 0x80) {\n    switch (count) {\n      case 0:\n        return 0;\n      case 1:\n        return (value[0] ^ 0x0000_00ff) * -1 - 1;\n      case 2:\n        return (value[0] + (value[1] << 8) ^ 0x0000_ffff) * -1 - 1;\n      case 3:\n        return (value[0] + (value[1] << 8) + (value[2] << 16) ^ 0x00ff_ffff) * -1 - 1;\n      case 4:\n        // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n        // 32-bit, in the case where the top-most bit is set this yields a negative value\n        return (value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00 ^ 0xffff_ffff) * -1 - 1;\n      case 5:\n        return ((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00 ^ 0xffff_ffff) + (value[4] ^ 0xff) * 0x1_00_00_00_00) * -1 - 1;\n      case 6:\n        return ((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00 ^ 0xffff_ffff) + (value[4] + (value[5] << 8) ^ 0x0000_ffff) * 0x1_00_00_00_00) * -1 - 1;\n      default:\n        throw new Error('Value more than 48-bits cannot be reliably converted');\n    }\n  }\n  switch (count) {\n    case 0:\n      return 0;\n    case 1:\n      return value[0];\n    case 2:\n      return value[0] + (value[1] << 8);\n    case 3:\n      return value[0] + (value[1] << 8) + (value[2] << 16);\n    case 4:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00;\n    case 5:\n      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 0x1_00_00_00;\n    case 6:\n      return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 0x1_00_00_00;\n    default:\n      throw new Error('Value more than 48-bits cannot be reliably converted');\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}