{"ast":null,"code":"import { BN, bnToBn, bnToHex, bnToU8a, isString, isU8a, u8aToBn } from '@polkadot/util';\nconst BITLENGTH = 64;\nconst U8A_OPTS = {\n  bitLength: BITLENGTH,\n  isLe: true\n};\nfunction decodeDate(value) {\n  if (isU8a(value)) {\n    value = u8aToBn(value.subarray(0, BITLENGTH / 8));\n  } else if (value instanceof Date) {\n    return value;\n  } else if (isString(value)) {\n    value = new BN(value.toString(), 10, 'le');\n  }\n  return new Date(bnToBn(value).toNumber() * 1000);\n}\n/**\n * @name Date\n * @description\n * A wrapper around seconds/timestamps. Internally the representation only has\n * second precicion (aligning with Rust), so any numbers passed an/out are always\n * per-second. For any encoding/decoding the 1000 multiplier would be applied to\n * get it in line with JavaScript formats. It extends the base JS `Date` object\n * and has all the methods available that are applicable to any `Date`\n * @noInheritDoc\n */\nexport class CodecDate extends Date {\n  registry;\n  createdAtHash;\n  initialU8aLength = BITLENGTH / 8;\n  isStorageFallback;\n  constructor(registry, value = 0) {\n    super(decodeDate(value));\n    this.registry = registry;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return BITLENGTH / 8;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.getTime() === 0;\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n  bitLength() {\n    return BITLENGTH;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return decodeDate(other).getTime() === this.getTime();\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [this.toU8a()]\n    };\n  }\n  /**\n   * @description Returns a BigInt representation of the number\n   */\n  toBigInt() {\n    return BigInt(this.toNumber());\n  }\n  /**\n   * @description Returns the BN representation of the timestamp\n   */\n  toBn() {\n    return new BN(this.toNumber());\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex(isLe = false) {\n    return bnToHex(this.toBn(), {\n      bitLength: BITLENGTH,\n      isLe,\n      isNegative: false\n    });\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toISOString();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    // FIXME Return type should be number, but conflicts with Date.toJSON()\n    // which returns string\n    return this.toNumber();\n  }\n  /**\n   * @description Returns the number representation for the timestamp\n   */\n  toNumber() {\n    return Math.ceil(this.getTime() / 1000);\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Moment';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    // only included here since we do not inherit docs\n    return super.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a(_isBare) {\n    return bnToU8a(this.toNumber(), U8A_OPTS);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}