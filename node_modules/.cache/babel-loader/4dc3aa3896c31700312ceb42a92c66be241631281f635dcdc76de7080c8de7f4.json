{"ast":null,"code":"import { map, of, switchMap } from 'rxjs';\nimport { BN_ZERO, isFunction } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nimport { getImageHashBounded } from './util.js';\nfunction getUnrequestedTicket(status) {\n  return status.ticket || status.deposit;\n}\nfunction getRequestedTicket(status) {\n  return (status.maybeTicket || status.deposit).unwrapOrDefault();\n}\nfunction isDemocracyPreimage(api, imageOpt) {\n  return !!imageOpt && !api.query.democracy['dispatchQueue'];\n}\nfunction constructProposal(api, [bytes, proposer, balance, at]) {\n  let proposal;\n  try {\n    proposal = api.registry.createType('Call', bytes.toU8a(true));\n  } catch (error) {\n    console.error(error);\n  }\n  return {\n    at,\n    balance,\n    proposal,\n    proposer\n  };\n}\nfunction parseDemocracy(api, imageOpt) {\n  if (imageOpt.isNone) {\n    return;\n  }\n  if (isDemocracyPreimage(api, imageOpt)) {\n    const status = imageOpt.unwrap();\n    if (status.isMissing) {\n      return;\n    }\n    const {\n      data,\n      deposit,\n      provider,\n      since\n    } = status.asAvailable;\n    return constructProposal(api, [data, provider, deposit, since]);\n  }\n  return constructProposal(api, imageOpt.unwrap());\n}\nfunction parseImage(api, [proposalHash, status, bytes]) {\n  if (!status) {\n    return undefined;\n  }\n  const [proposer, balance] = status.isUnrequested ? getUnrequestedTicket(status.asUnrequested) : getRequestedTicket(status.asRequested);\n  let proposal;\n  if (bytes) {\n    try {\n      proposal = api.registry.createType('Call', bytes.toU8a(true));\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  return {\n    at: BN_ZERO,\n    balance,\n    proposal,\n    proposalHash,\n    proposer\n  };\n}\nfunction getDemocracyImages(api, bounded) {\n  const hashes = bounded.map(b => getImageHashBounded(b));\n  return api.query.democracy['preimages'].multi(hashes).pipe(map(images => images.map(imageOpt => parseDemocracy(api, imageOpt))));\n}\nfunction getImages(api, bounded) {\n  const hashes = bounded.map(b => getImageHashBounded(b));\n  const bytesType = api.registry.lookup.getTypeDef(api.query.preimage.preimageFor.creator.meta.type.asMap.key).type;\n  return api.query.preimage.statusFor.multi(hashes).pipe(switchMap(optStatus => {\n    const statuses = optStatus.map(o => o.unwrapOr(null));\n    const keys = statuses.map((s, i) => s ? bytesType === 'H256'\n    // first generation\n    ? hashes[i]\n    // current generation (H256,u32)\n    : s.isRequested ? [hashes[i], s.asRequested.len.unwrapOr(0)] : [hashes[i], s.asUnrequested.len] : null).filter(p => !!p);\n    return api.query.preimage.preimageFor.multi(keys).pipe(map(optBytes => {\n      let ptr = -1;\n      return statuses.map((s, i) => s ? [hashes[i], s, optBytes[++ptr].unwrapOr(null)] : [hashes[i], null, null]).map(v => parseImage(api, v));\n    }));\n  }));\n}\nexport function preimages(instanceId, api) {\n  return memo(instanceId, hashes => hashes.length ? isFunction(api.query.democracy['preimages']) ? getDemocracyImages(api, hashes) : isFunction(api.query.preimage.preimageFor) ? getImages(api, hashes) : of([]) : of([]));\n}\nexport const preimage = /*#__PURE__*/firstMemo((api, hash) => api.derive.democracy.preimages([hash]));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}