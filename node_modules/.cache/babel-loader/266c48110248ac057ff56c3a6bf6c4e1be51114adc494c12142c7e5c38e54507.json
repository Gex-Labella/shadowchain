{"ast":null,"code":"import { isPromise, objectSpread, u8aEq } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\nimport { documentReadyPromise } from './util.js';\nexport { packageInfo } from './packageInfo.js';\nexport { unwrapBytes, wrapBytes } from './wrapBytes.js';\nconst win = window;\nwin.injectedWeb3 = win.injectedWeb3 || {};\nlet isWeb3Injected = web3IsInjected();\nlet web3EnablePromise = null;\nexport { isWeb3Injected, web3EnablePromise };\n/** @internal true when anything has been injected and is available */\nfunction web3IsInjected() {\n  return Object.values(win.injectedWeb3).filter(({\n    connect,\n    enable\n  }) => !!(connect || enable)).length !== 0;\n}\n/** @internal throw a consistent error when not extensions have not been enabled */\nfunction throwError(method) {\n  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n}\n/** @internal map from Array<InjectedAccount> to Array<InjectedAccountWithMeta> */\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(({\n    address,\n    genesisHash,\n    name,\n    type\n  }) => ({\n    address: address.length === 42 ? address : encodeAddress(decodeAddress(address), ss58Format),\n    meta: {\n      genesisHash,\n      name,\n      source\n    },\n    type\n  }));\n}\n/** @internal filter accounts based on genesisHash and type of account */\nfunction filterAccounts(list, genesisHash, type) {\n  return list.filter(a => (!a.type || !type || type.includes(a.type)) && (!a.genesisHash || !genesisHash || a.genesisHash === genesisHash));\n}\n/** @internal retrieves all the extensions available on the window */\nfunction getWindowExtensions(originName) {\n  return Promise.all(Object.entries(win.injectedWeb3).map(([nameOrHash, {\n    connect,\n    enable,\n    version\n  }]) => Promise.resolve().then(() => connect\n  // new style, returning all info\n  ? connect(originName) : enable\n  // previous interface, leakages on name/version\n  ? enable(originName).then(e => objectSpread({\n    name: nameOrHash,\n    version: version || 'unknown'\n  }, e)) : Promise.reject(new Error('No connect(..) or enable(...) hook found'))).catch(({\n    message\n  }) => {\n    console.error(`Error initializing ${nameOrHash}: ${message}`);\n  }))).then(exts => exts.filter(e => !!e));\n}\n/** @internal Ensure the enable promise is resolved and filter by extensions */\nasync function filterEnable(caller, extensions) {\n  if (!web3EnablePromise) {\n    return throwError(caller);\n  }\n  const sources = await web3EnablePromise;\n  return sources.filter(({\n    name\n  }) => !extensions || extensions.includes(name));\n}\n/**\n * @summary Enables all the providers found on the injected window interface\n * @description\n * Enables all injected extensions that has been found on the page. This\n * should be called before making use of any other web3* functions.\n */\nexport function web3Enable(originName, compatInits = []) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n  const initCompat = compatInits.length ? Promise.all(compatInits.map(c => c().catch(() => false))) : Promise.resolve([true]);\n  web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName).then(values => values.map(e => {\n    // if we don't have an accounts subscriber, add a single-shot version\n    if (!e.accounts.subscribe) {\n      e.accounts.subscribe = cb => {\n        e.accounts.get().then(cb).catch(console.error);\n        return () => {\n          // no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n    return e;\n  })).catch(() => []).then(values => {\n    const names = values.map(({\n      name,\n      version\n    }) => `${name}/${version}`);\n    isWeb3Injected = web3IsInjected();\n    console.info(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n    return values;\n  })));\n  return web3EnablePromise;\n}\n/**\n * @summary Retrieves all the accounts across all providers\n * @description\n * This returns the full list of account available (across all extensions) to\n * the page. Filtering options are available of a per-extension, per type and\n * per-genesisHash basis. Optionally the accounts can be encoded with the provided\n * ss58Format\n */\nexport async function web3Accounts({\n  accountType,\n  extensions,\n  genesisHash,\n  ss58Format\n} = {}) {\n  const accounts = [];\n  const sources = await filterEnable('web3Accounts', extensions);\n  const retrieved = await Promise.all(sources.map(async ({\n    accounts,\n    name: source\n  }) => {\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format);\n    } catch {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  console.info(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}`);\n  return accounts;\n}\n/**\n * @summary Subscribes to all the accounts across all providers\n * @description\n * This is the subscription version of the web3Accounts interface with\n * updates as to when new accounts do become available. The list of filtering\n * options are the same as for the web3Accounts interface.\n */\nexport async function web3AccountsSubscribe(cb, {\n  accountType,\n  extensions,\n  genesisHash,\n  ss58Format\n} = {}) {\n  const sources = await filterEnable('web3AccountsSubscribe', extensions);\n  const accounts = {};\n  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {\n    result.push(...mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format));\n    return result;\n  }, []));\n  const unsubs = sources.map(({\n    accounts: {\n      subscribe\n    },\n    name: source\n  }) => subscribe(result => {\n    accounts[source] = result;\n    try {\n      const result = triggerUpdate();\n      if (result && isPromise(result)) {\n        result.catch(console.error);\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }));\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n}\n/**\n * @summary Finds a specific provider based on the name\n * @description\n * This retrieves a specific source (extension) based on the name. In most\n * cases it should not be needed to call it directly (e.g. it is used internally\n * by calls such as web3FromAddress) but would allow operation on a specific\n * known extension.\n */\nexport async function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(({\n    name\n  }) => name === source);\n  if (!found) {\n    throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n  }\n  return found;\n}\n/**\n * @summary Find a specific provider that provides a specific address\n * @description\n * Based on an address, return the provider that has makes this address\n * available to the page.\n */\nexport async function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n  const accounts = await web3Accounts();\n  let found;\n  if (address) {\n    const accountU8a = decodeAddress(address);\n    found = accounts.find(account => u8aEq(decodeAddress(account.address), accountU8a));\n  }\n  if (!found) {\n    throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n  }\n  return web3FromSource(found.meta.source);\n}\n/**\n * @summary List all providers exposed by one source\n * @description\n * For extensions that supply RPC providers, this call would return the list\n * of RPC providers that any extension may supply.\n */\nexport async function web3ListRpcProviders(source) {\n  const {\n    provider\n  } = await web3FromSource(source);\n  if (!provider) {\n    console.warn(`Extension ${source} does not expose any provider`);\n    return null;\n  }\n  return provider.listProviders();\n}\n/**\n * @summary Start an RPC provider provider by a specific source\n * @description\n * For extensions that supply RPC providers, this call would return an\n * enabled provider (initialized with the specific key) from the\n * specified extension source.\n */\nexport async function web3UseRpcProvider(source, key) {\n  const {\n    provider\n  } = await web3FromSource(source);\n  if (!provider) {\n    throw new Error(`Extension ${source} does not expose any provider`);\n  }\n  const meta = await provider.startProvider(key);\n  return {\n    meta,\n    provider\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}