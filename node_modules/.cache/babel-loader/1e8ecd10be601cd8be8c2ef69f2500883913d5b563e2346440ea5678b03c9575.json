{"ast":null,"code":"import { combineLatest, map, mergeMap, of, switchMap } from 'rxjs';\nimport { memo, unwrapBlockNumber } from '../util/index.js';\nexport function createBlockNumberDerive(fn) {\n  return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));\n}\n/** @internal */\nfunction getAuthorDetailsWithAt(header, queryAt) {\n  const validators = queryAt.session?.validators ? queryAt.session.validators() : of(null);\n  // nimbus consensus stores the session key of the block author in header logs\n  const {\n    logs: [log]\n  } = header.digest;\n  const loggedAuthor = log && (log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1] || log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1]);\n  if (loggedAuthor) {\n    // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key\n    if (queryAt['authorMapping']?.['mappingWithDeposit']) {\n      return combineLatest([of(header), validators, queryAt['authorMapping']['mappingWithDeposit'](loggedAuthor).pipe(map(o => o.unwrapOr({\n        account: null\n      }).account))]);\n    }\n    // fall back to session and parachain staking pallets, if available (ie: manta, calamari), to map session (nimbus) key to author (collator) key\n    if (queryAt['parachainStaking']?.['selectedCandidates'] && queryAt.session?.nextKeys) {\n      const loggedHex = loggedAuthor.toHex();\n      return combineLatest([of(header), validators, queryAt['parachainStaking']['selectedCandidates']().pipe(mergeMap(selectedCandidates => combineLatest([of(selectedCandidates), queryAt.session.nextKeys.multi(selectedCandidates).pipe(map(nextKeys => nextKeys.findIndex(o => o.unwrapOrDefault().nimbus.toHex() === loggedHex)))])), map(([selectedCandidates, index]) => index === -1 ? null : selectedCandidates[index]))]);\n    }\n  }\n  // normal operation, non-mapping\n  return combineLatest([of(header), validators, of(null)]);\n}\nexport function getAuthorDetails(api, header, blockHash) {\n  // For on-chain state, we need to retrieve it as per the start\n  // of the block being constructed, i.e. session validators would\n  // be at the point of the block construction, not when all operations\n  // has been supplied.\n  //\n  // However for the first block (no parentHash available), we would\n  // just use the as-is\n  return api.queryAt(header.parentHash.isEmpty ? blockHash || header.hash : header.parentHash).pipe(switchMap(queryAt => getAuthorDetailsWithAt(header, queryAt)));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}