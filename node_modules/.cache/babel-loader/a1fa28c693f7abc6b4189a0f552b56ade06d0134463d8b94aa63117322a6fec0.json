{"ast":null,"code":"import { sanitize, Struct } from '@polkadot/types-codec';\nimport { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';\nimport { assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';\nconst l = logger('PortableRegistry');\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n};\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n};\nconst PATHS_ALIAS = splitNamespace([\n// full matching on exact names...\n// these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress',\n// ethereum overrides (Frontier, Moonbeam, Polkadot claims)\n'fp_account::AccountId20', 'account::AccountId20', 'polkadot_runtime_common::claims::EthereumAddress',\n// weights 2 is a structure, however for 1.5. with a single field it\n// should be flatenned (can appear in Compact<Weight> extrinsics)\n'frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight',\n// wildcard matching in place...\n// these have a specific encoding or logic, use a wildcard for {pallet, darwinia}_democracy\n'*_democracy::vote::Vote', '*_conviction_voting::vote::Vote', '*_identity::types::Data',\n// these are opaque Vec<u8> wrappers\n'sp_core::OpaqueMetadata', 'sp_core::OpaquePeerId', 'sp_core::offchain::OpaqueMultiaddr',\n// shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*',\n// runtime\n'*_runtime::RuntimeCall', '*_runtime::RuntimeEvent',\n// ink!\n'ink::env::types::*', 'ink::primitives::types::*', 'ink_env::types::*', 'ink_primitives::types::*']);\nconst PATHS_SET = splitNamespace(['pallet_identity::types::BitFlags']);\nconst BITVEC_NS_LSB = ['bitvec::order::Lsb0', 'BitOrderLsb0'];\nconst BITVEC_NS_MSB = ['bitvec::order::Msb0', 'BitOrderMsb0'];\nconst BITVEC_NS = [...BITVEC_NS_LSB, ...BITVEC_NS_MSB];\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedBTreeSet', 'BoundedVec', 'Box', 'BTreeMap', 'BTreeSet', 'Cow', 'Option', 'Range', 'RangeInclusive', 'Result', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque'];\nconst RESERVED = [\n// JS reserved words\n'entries', 'keys', 'new', 'size',\n// exposed by all Codec objects\n'hash', 'registry'];\nconst PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];\n/** @internal Converts a Text[] into string[] (used as part of definitions) */\nfunction sanitizeDocs(docs) {\n  const count = docs.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    result[i] = docs[i].toString();\n  }\n  return result;\n}\n/** @internal Split a namespace with :: into individual parts */\nfunction splitNamespace(values) {\n  const count = values.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    result[i] = values[i].split('::');\n  }\n  return result;\n}\n/** @internal Match a namespace based on parts (alongside wildcards) */\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n    if (a === '*' || a === b) {\n      return true;\n    }\n    if (a.includes('*') && a.includes('_') && b.includes('_')) {\n      let suba = a.split('_');\n      let subb = b.split('_');\n      // match initial *'s to multiples if we have a match for the other\n      if (suba[0] === '*') {\n        const indexOf = subb.indexOf(suba[1]);\n        if (indexOf !== -1) {\n          suba = suba.slice(1);\n          subb = subb.slice(indexOf);\n        }\n      }\n      // check for * matches at the end, adjust accordingly\n      if (suba.length === 2 && suba[1] === '*' && suba[0] === subb[0]) {\n        return true;\n      }\n      return matchParts(suba, subb);\n    }\n    return false;\n  });\n}\n/** @internal check if the path matches the PATHS_ALIAS (with wildcards) */\nfunction getAliasPath({\n  def,\n  path\n}) {\n  // specific logic for weights - we override when non-complex struct\n  // (as applied in Weight 1.5 where we also have `Compact<{ refTime: u64 }>)\n  if (['frame_support::weights::weight_v2::Weight', 'sp_weights::weight_v2::Weight'].includes(path.join('::'))) {\n    return !def.isComposite || def.asComposite.fields.length === 1 ? 'WeightV1' : null;\n  }\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PATHS_ALIAS.some(a => matchParts(a, path)) ? path[path.length - 1].toString() : null;\n}\n/** @internal Converts a type name into a JS-API compatible name */\nfunction extractNameFlat(portable, lookupIndex, params, path, isInternal = false) {\n  const count = path.length;\n  // if we have no path or determined as a wrapper, we just skip it\n  if (count === 0 || WRAPPERS.includes(path[count - 1].toString())) {\n    return null;\n  }\n  const camels = new Array(count);\n  const lowers = new Array(count);\n  // initially just create arrays of the camelCase and lowercase path\n  // parts - we will check these to extract the final values. While\n  // we have 2 loops here, we also don't do the same operation twice\n  for (let i = 0; i < count; i++) {\n    const c = stringPascalCase(isInternal ? path[i].replace('pallet_', '') : path[i]);\n    const l = c.toLowerCase();\n    camels[i] = c;\n    lowers[i] = l;\n  }\n  let name = '';\n  for (let i = 0; i < count; i++) {\n    const l = lowers[i];\n    // Remove ::{generic, misc, pallet, traits, types}::\n    if (i !== 1 || !PATH_RM_INDEX_1.includes(l)) {\n      // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n      // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n      if (l !== lowers[i + 1]) {\n        name += camels[i];\n      }\n    }\n  }\n  // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin\n  if (camels[1] === 'RawOrigin' && count === 2 && params.length === 2 && params[1].type.isSome) {\n    const instanceType = portable[params[1].type.unwrap().toNumber()];\n    if (instanceType.type.path.length === 2) {\n      name = `${name}${instanceType.type.path[1].toString()}`;\n    }\n  }\n  return {\n    lookupIndex,\n    name,\n    params\n  };\n}\n/** @internal Alias for extractNameFlat with PortableType as a last parameter */\nfunction extractName(portable, lookupIndex, {\n  type: {\n    params,\n    path\n  }\n}) {\n  return extractNameFlat(portable, lookupIndex, params, path);\n}\n/** @internal Check for dupes from a specific index onwards */\nfunction nextDupeMatches(name, startAt, names) {\n  const result = [names[startAt]];\n  for (let i = startAt + 1, count = names.length; i < count; i++) {\n    const v = names[i];\n    if (v.name === name) {\n      result.push(v);\n    }\n  }\n  return result;\n}\n/** @internal Checks to see if a type is a full duplicate (with all params matching) */\nfunction rewriteDupes(input, rewrite) {\n  const count = input.length;\n  for (let i = 0; i < count; i++) {\n    const a = input[i];\n    for (let j = i + 1; j < count; j++) {\n      const b = input[j];\n      // if the indexes are not the same and the names match, we have a dupe\n      if (a.lookupIndex !== b.lookupIndex && a.name === b.name) {\n        return false;\n      }\n    }\n  }\n  // add all the adjusted values to the rewite map\n  for (let i = 0; i < count; i++) {\n    const p = input[i];\n    rewrite[p.lookupIndex] = p.name;\n  }\n  return true;\n}\n/** @internal Find duplicates and adjust the names based on parameters */\nfunction removeDupeNames(lookup, portable, names) {\n  const rewrite = {};\n  return names.map((original, startAt) => {\n    const {\n      lookupIndex,\n      name,\n      params\n    } = original;\n    if (!name) {\n      // the name is empty (this is not expected, but have a failsafe)\n      return null;\n    } else if (rewrite[lookupIndex]) {\n      // we have already rewritten this one, we can skip it\n      return original;\n    }\n    // those where the name is matching starting from this index\n    const allSame = nextDupeMatches(name, startAt, names);\n    // we only have one, so all ok\n    if (allSame.length === 1) {\n      return original;\n    }\n    // are there param differences between matching names\n    const anyDiff = allSame.some(o => params.length !== o.params.length || params.some((p, index) => !p.name.eq(o.params[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== o.params[index].type.unwrapOr(TYPE_UNWRAP).toNumber()));\n    // everything matches, we can combine these\n    if (!anyDiff) {\n      return original;\n    }\n    // TODO We probably want to attach all the indexes with differences,\n    // not just the first\n    // find the first parameter that yields differences\n    const paramIdx = params.findIndex(({\n      type\n    }, index) => allSame.every(({\n      params\n    }, aIndex) => params[index].type.isSome && (aIndex === 0 || !params[index].type.eq(type))));\n    // No param found that is different\n    if (paramIdx === -1) {\n      return original;\n    }\n    // see if using the param type helps\n    const sameCount = allSame.length;\n    const adjusted = new Array(sameCount);\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < sameCount; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      // if it is not a primitive and it doesn't have a path, we really cannot\n      // do anything at this point\n      if (!def.isPrimitive && !path.length) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: def.isPrimitive ? `${name}${def.asPrimitive.toString()}` : `${name}${path[path.length - 1].toString()}`\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    // TODO This is duplicated from the section just above...\n    // ... we certainly need a better solution here\n    //\n    // Last-ditch effort to use the full type path - ugly\n    // loop through all, specifically checking that index where the\n    // first param yields differences\n    for (let i = 0; i < sameCount; i++) {\n      const {\n        lookupIndex,\n        name,\n        params\n      } = allSame[i];\n      const {\n        def,\n        path\n      } = lookup.getSiType(params[paramIdx].type.unwrap());\n      const flat = extractNameFlat(portable, lookupIndex, params, path, true);\n      if (def.isPrimitive || !flat) {\n        return null;\n      }\n      adjusted[i] = {\n        lookupIndex,\n        name: `${name}${flat.name}`\n      };\n    }\n    // check to see if the adjusted names have no issues\n    if (rewriteDupes(adjusted, rewrite)) {\n      return original;\n    }\n    return null;\n  }).filter(n => !!n).map(({\n    lookupIndex,\n    name,\n    params\n  }) => ({\n    lookupIndex,\n    name: rewrite[lookupIndex] || name,\n    params\n  }));\n}\n/** @internal Detect on-chain types (AccountId/Signature) as set as the default */\nfunction registerTypes(lookup, lookups, names, params) {\n  // Register the types we extracted\n  lookup.registry.register(lookups);\n  // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [addrParam,, sigParam] = params.SpRuntimeUncheckedExtrinsic;\n    const siAddress = lookup.getSiType(addrParam.type.unwrap());\n    const siSignature = lookup.getSiType(sigParam.type.unwrap());\n    const nsSignature = siSignature.path.join('::');\n    let nsAccountId = siAddress.path.join('::');\n    const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';\n    // With multiaddress, we check the first type param again\n    if (isMultiAddress) {\n      // AccountId, AccountIndex\n      const [idParam] = siAddress.params;\n      nsAccountId = lookup.getSiType(idParam.type.unwrap()).path.join('::');\n    }\n    lookup.registry.register({\n      // known: account::AccountId20, fp_account::AccountId20, primitive_types::H160\n      AccountId: nsAccountId.endsWith('::AccountId20') || nsAccountId.endsWith('::H160') ? 'AccountId20' : 'AccountId32',\n      Address: isMultiAddress ? 'MultiAddress' : 'AccountId',\n      ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature) ? 'MultiSignature' : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'\n    });\n  }\n}\n/**\n * @internal Extracts aliases based on what we know the runtime config looks like in a\n * Substrate chain. Specifically we want to have access to the Call and Event params\n **/\nfunction extractAliases(params, isContract) {\n  const hasParams = Object.keys(params).some(k => !k.startsWith('Pallet'));\n  const alias = {};\n  if (params.SpRuntimeUncheckedExtrinsic) {\n    // Address, Call, Signature, Extra\n    const [, {\n      type\n    }] = params.SpRuntimeUncheckedExtrinsic;\n    alias[type.unwrap().toNumber()] = 'Call';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');\n  }\n  if (params.FrameSystemEventRecord) {\n    // Event, Topic\n    const [{\n      type\n    }] = params.FrameSystemEventRecord;\n    alias[type.unwrap().toNumber()] = 'Event';\n  } else if (hasParams && !isContract) {\n    l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');\n  }\n  return alias;\n}\n/** @internal Extracts all the intreresting type information for this registry */\nfunction extractTypeInfo(lookup, portable) {\n  const nameInfo = [];\n  const types = {};\n  for (let i = 0, count = portable.length; i < count; i++) {\n    const type = portable[i];\n    const lookupIndex = type.id.toNumber();\n    const extracted = extractName(portable, lookupIndex, portable[i]);\n    if (extracted) {\n      nameInfo.push(extracted);\n    }\n    types[lookupIndex] = type;\n  }\n  const lookups = {};\n  const names = {};\n  const params = {};\n  const dedup = removeDupeNames(lookup, portable, nameInfo);\n  for (let i = 0, count = dedup.length; i < count; i++) {\n    const {\n      lookupIndex,\n      name,\n      params: p\n    } = dedup[i];\n    names[lookupIndex] = name;\n    lookups[name] = lookup.registry.createLookupType(lookupIndex);\n    params[name] = p;\n  }\n  return {\n    lookups,\n    names,\n    params,\n    types\n  };\n}\nexport class PortableRegistry extends Struct {\n  __internal__alias;\n  __internal__lookups;\n  __internal__names;\n  __internal__params;\n  __internal__typeDefs = {};\n  __internal__types;\n  constructor(registry, value, isContract) {\n    // const timeStart = performance.now()\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    const {\n      lookups,\n      names,\n      params,\n      types\n    } = extractTypeInfo(this, this.types);\n    this.__internal__alias = extractAliases(params, isContract);\n    this.__internal__lookups = lookups;\n    this.__internal__names = names;\n    this.__internal__params = params;\n    this.__internal__types = types;\n    // console.log('PortableRegistry', `${(performance.now() - timeStart).toFixed(2)}ms`)\n  }\n  /**\n   * @description Returns all the available type names for this chain\n   **/\n  get names() {\n    return Object.values(this.__internal__names).sort();\n  }\n  /**\n   * @description Returns all the available parameterized types for this chain\n   **/\n  get paramTypes() {\n    return this.__internal__params;\n  }\n  /**\n   * @description The types of the registry\n   */\n  get types() {\n    return this.getT('types');\n  }\n  /**\n   * @description Register all available types into the registry (generally for internal usage)\n   */\n  register() {\n    registerTypes(this, this.__internal__lookups, this.__internal__names, this.__internal__params);\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n  getName(lookupId) {\n    return this.__internal__names[this.__internal__getLookupId(lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n  getSiType(lookupId) {\n    // NOTE catch-22 - this may already be used as part of the constructor, so\n    // ensure that we have actually initialized it correctly\n    const found = (this.__internal__types || this.types)[this.__internal__getLookupId(lookupId)];\n    if (!found) {\n      throw new Error(`PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    }\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n  getTypeDef(lookupId) {\n    const lookupIndex = this.__internal__getLookupId(lookupId);\n    if (!this.__internal__typeDefs[lookupIndex]) {\n      const lookupName = this.__internal__names[lookupIndex];\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      };\n      // Set named items since we will get into circular lookups along the way\n      if (lookupName) {\n        this.__internal__typeDefs[lookupIndex] = empty;\n      }\n      const extracted = this.__internal__extract(this.getSiType(lookupId), lookupIndex);\n      // For non-named items, we only set this right at the end\n      if (!lookupName) {\n        this.__internal__typeDefs[lookupIndex] = empty;\n      }\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          this.__internal__typeDefs[lookupIndex][k] = extracted[k];\n        }\n      });\n      // don't set lookupName on lower-level, we want to always direct to the type\n      if (extracted.info === TypeDefInfo.Plain) {\n        this.__internal__typeDefs[lookupIndex].lookupNameRoot = this.__internal__typeDefs[lookupIndex].lookupName;\n        delete this.__internal__typeDefs[lookupIndex].lookupName;\n      }\n    }\n    return this.__internal__typeDefs[lookupIndex];\n  }\n  /**\n   * @description For a specific field, perform adjustments to not have built-in conflicts\n   */\n  sanitizeField(name) {\n    let nameField = null;\n    let nameOrig = null;\n    if (name.isSome) {\n      nameField = stringCamelCase(name.unwrap());\n      if (nameField.includes('#')) {\n        nameOrig = nameField;\n        nameField = nameOrig.replace(/#/g, '_');\n      } else if (RESERVED.includes(nameField)) {\n        nameOrig = nameField;\n        nameField = `${nameField}_`;\n      }\n    }\n    return [nameField, nameOrig];\n  }\n  /** @internal Creates a TypeDef based on an internal lookupId */\n  __internal__createSiDef(lookupId) {\n    const typeDef = this.getTypeDef(lookupId);\n    const lookupIndex = lookupId.toNumber();\n    // Setup for a lookup on complex types\n    return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n      docs: typeDef.docs,\n      info: TypeDefInfo.Si,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      type: this.registry.createLookupType(lookupId)\n    } : typeDef;\n  }\n  /** @internal Converts a lookupId input to the actual lookup index */\n  __internal__getLookupId(lookupId) {\n    if (isString(lookupId)) {\n      if (!this.registry.isLookupType(lookupId)) {\n        throw new Error(`PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n      }\n      return parseInt(lookupId.replace('Lookup', ''), 10);\n    } else if (isNumber(lookupId)) {\n      return lookupId;\n    }\n    return lookupId.toNumber();\n  }\n  /** @internal Converts a type into a TypeDef for Codec usage */\n  __internal__extract(type, lookupIndex) {\n    const namespace = type.path.join('::');\n    let typeDef;\n    const aliasType = this.__internal__alias[lookupIndex] || getAliasPath(type);\n    try {\n      if (aliasType) {\n        typeDef = this.__internal__extractAliasPath(lookupIndex, aliasType);\n      } else {\n        switch (type.def.type) {\n          case 'Array':\n            typeDef = this.__internal__extractArray(lookupIndex, type.def.asArray);\n            break;\n          case 'BitSequence':\n            typeDef = this.__internal__extractBitSequence(lookupIndex, type.def.asBitSequence);\n            break;\n          case 'Compact':\n            typeDef = this.__internal__extractCompact(lookupIndex, type.def.asCompact);\n            break;\n          case 'Composite':\n            typeDef = this.__internal__extractComposite(lookupIndex, type, type.def.asComposite);\n            break;\n          case 'HistoricMetaCompat':\n            typeDef = this.__internal__extractHistoric(lookupIndex, type.def.asHistoricMetaCompat);\n            break;\n          case 'Primitive':\n            typeDef = this.__internal__extractPrimitive(lookupIndex, type);\n            break;\n          case 'Sequence':\n            typeDef = this.__internal__extractSequence(lookupIndex, type.def.asSequence);\n            break;\n          case 'Tuple':\n            typeDef = this.__internal__extractTuple(lookupIndex, type.def.asTuple);\n            break;\n          case 'Variant':\n            typeDef = this.__internal__extractVariant(lookupIndex, type, type.def.asVariant);\n            break;\n          default:\n            assertUnreachable(type.def.type);\n        }\n      }\n    } catch (error) {\n      throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n    }\n    return objectSpread({\n      docs: sanitizeDocs(type.docs),\n      namespace\n    }, typeDef);\n  }\n  /** @internal Extracts a ScaleInfo Array into TypeDef.VecFixed */\n  __internal__extractArray(_, {\n    len,\n    type\n  }) {\n    const length = len.toNumber();\n    if (length > 2048) {\n      throw new Error('Only support for [Type; <length>], where length <= 2048');\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.VecFixed,\n      length,\n      sub: this.__internal__createSiDef(type)\n    });\n  }\n  /** @internal Extracts a ScaleInfo BitSequence into TypeDef.Plain */\n  __internal__extractBitSequence(_, {\n    bitOrderType,\n    bitStoreType\n  }) {\n    // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine\n    // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly\n    const a = this.__internal__createSiDef(bitOrderType);\n    const b = this.__internal__createSiDef(bitStoreType);\n    const [bitOrder, bitStore] = BITVEC_NS.includes(a.namespace || '') ? [a, b] : [b, a];\n    if (!bitOrder.namespace || !BITVEC_NS.includes(bitOrder.namespace)) {\n      throw new Error(`Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n    } else if (bitStore.info !== TypeDefInfo.Plain || bitStore.type !== 'u8') {\n      throw new Error(`Only u8 bitStore is currently supported, found ${bitStore.type}`);\n    }\n    const isLsb = BITVEC_NS_LSB.includes(bitOrder.namespace);\n    if (!isLsb) {\n      // TODO To remove this limitation, we need to pass an extra info flag\n      // through to the TypeDef (Here we could potentially re-use something\n      // like index (???) to indicate and ensure we use it to pass to the\n      // BitVec constructor - which does handle this type)\n      //\n      // See https://github.com/polkadot-js/api/issues/5588\n      // throw new Error(`Only LSB BitVec is currently supported, found ${bitOrder.namespace}`);\n    }\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'BitVec'\n    };\n  }\n  /** @internal Extracts a ScaleInfo Compact into TypeDef.Compact */\n  __internal__extractCompact(_, {\n    type\n  }) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Compact,\n      sub: this.__internal__createSiDef(type)\n    });\n  }\n  /** @internal Extracts a ScaleInfo Composite into TypeDef.{BTree*, Range*, Wrapper*} */\n  __internal__extractComposite(lookupIndex, {\n    params,\n    path\n  }, {\n    fields\n  }) {\n    if (path.length) {\n      const pathFirst = path[0].toString();\n      const pathLast = path[path.length - 1].toString();\n      if (path.length === 1 && pathFirst === 'BTreeMap') {\n        if (params.length !== 2) {\n          throw new Error(`BTreeMap requires 2 parameters, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.BTreeMap,\n          sub: params.map(({\n            type\n          }) => this.__internal__createSiDef(type.unwrap()))\n        });\n      } else if (path.length === 1 && pathFirst === 'BTreeSet') {\n        if (params.length !== 1) {\n          throw new Error(`BTreeSet requires 1 parameter, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.BTreeSet,\n          sub: this.__internal__createSiDef(params[0].type.unwrap())\n        });\n      } else if (['Range', 'RangeInclusive'].includes(pathFirst)) {\n        if (params.length !== 1) {\n          throw new Error(`Range requires 1 parameter, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: pathFirst === 'Range' ? TypeDefInfo.Range : TypeDefInfo.RangeInclusive,\n          sub: this.__internal__createSiDef(params[0].type.unwrap()),\n          type: pathFirst\n        });\n      } else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {\n        if (params.length !== 1) {\n          throw new Error(`WrapperOpaque requires 1 parameter, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: pathLast === 'WrapperKeepOpaque' ? TypeDefInfo.WrapperKeepOpaque : TypeDefInfo.WrapperOpaque,\n          sub: this.__internal__createSiDef(params[0].type.unwrap()),\n          type: pathLast\n        });\n      }\n    }\n    return PATHS_SET.some(p => matchParts(p, path)) ? this.__internal__extractCompositeSet(lookupIndex, params, fields) : this.__internal__extractFields(lookupIndex, fields);\n  }\n  /** @internal Extracts a ScaleInfo CompositeSet into TypeDef.Set */\n  __internal__extractCompositeSet(_, params, fields) {\n    if (params.length !== 1 || fields.length !== 1) {\n      throw new Error('Set handling expects param/field as single entries');\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Set,\n      length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),\n      sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n        index,\n        name\n      }) => ({\n        // This will be an issue > 2^53 - 1 ... don't have those (yet)\n        index: index.toNumber(),\n        info: TypeDefInfo.Plain,\n        name: name.toString(),\n        type: 'Null'\n      }))\n    });\n  }\n  /** @internal Extracts ScaleInfo enum/struct fields into TypeDef.{Struct, Tuple} */\n  __internal__extractFields(lookupIndex, fields) {\n    let isStruct = true;\n    let isTuple = true;\n    const count = fields.length;\n    for (let f = 0; f < count; f++) {\n      const {\n        name\n      } = fields[f];\n      isStruct = isStruct && name.isSome;\n      isTuple = isTuple && name.isNone;\n    }\n    if (!isTuple && !isStruct) {\n      throw new Error('Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n    }\n    if (count === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    } else if (isTuple && count === 1) {\n      const typeDef = this.__internal__createSiDef(fields[0].type);\n      return objectSpread({}, typeDef, lookupIndex === -1 ? null : {\n        lookupIndex,\n        lookupName: this.__internal__names[lookupIndex],\n        lookupNameRoot: typeDef.lookupName\n      }, fields[0].typeName.isSome ? {\n        typeName: sanitize(fields[0].typeName.unwrap())\n      } : null);\n    }\n    const [sub, alias] = this.__internal__extractFieldsAlias(fields);\n    return withTypeString(this.registry, objectSpread({\n      info: isTuple // Tuple check first\n      ? TypeDefInfo.Tuple : TypeDefInfo.Struct,\n      sub\n    }, alias.size ? {\n      alias\n    } : null, lookupIndex === -1 ? null : {\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex]\n    }));\n  }\n  /** @internal Apply field aliassed (with no JS conflicts) */\n  __internal__extractFieldsAlias(fields) {\n    const alias = new Map();\n    const count = fields.length;\n    const sub = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const {\n        docs,\n        name,\n        type,\n        typeName\n      } = fields[i];\n      const typeDef = this.__internal__createSiDef(type);\n      if (name.isNone) {\n        sub[i] = typeDef;\n      } else {\n        const [nameField, nameOrig] = this.sanitizeField(name);\n        if (nameField && nameOrig) {\n          alias.set(nameField, nameOrig);\n        }\n        sub[i] = objectSpread({\n          docs: sanitizeDocs(docs),\n          name: nameField\n        }, typeDef, typeName.isSome ? {\n          typeName: sanitize(typeName.unwrap())\n        } : null);\n      }\n    }\n    return [sub, alias];\n  }\n  /** @internal Extracts an internal Historic (pre V14) type  */\n  __internal__extractHistoric(_, type) {\n    return objectSpread({\n      displayName: type.toString(),\n      isFromSi: true\n    }, getTypeDef(type));\n  }\n  /** @internal Extracts a ScaleInfo Primitive into TypeDef.Plain */\n  __internal__extractPrimitive(_, type) {\n    const typeStr = type.def.asPrimitive.type.toString();\n    return {\n      info: TypeDefInfo.Plain,\n      type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n    };\n  }\n  /** @internal Applies an alias path onto the TypeDef */\n  __internal__extractAliasPath(_, type) {\n    return {\n      info: TypeDefInfo.Plain,\n      type\n    };\n  }\n  /** @internal Extracts a ScaleInfo Sequence into TypeDef.Vec (with Bytes shortcut) */\n  __internal__extractSequence(lookupIndex, {\n    type\n  }) {\n    const sub = this.__internal__createSiDef(type);\n    if (sub.type === 'u8') {\n      return {\n        info: TypeDefInfo.Plain,\n        type: 'Bytes'\n      };\n    }\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Vec,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n  /** @internal Extracts a ScaleInfo Tuple into TypeDef.Tuple */\n  __internal__extractTuple(lookupIndex, ids) {\n    if (ids.length === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    } else if (ids.length === 1) {\n      return this.getTypeDef(ids[0]);\n    }\n    const sub = ids.map(t => this.__internal__createSiDef(t));\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Tuple,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n  /** @internal Extracts a ScaleInfo Variant into TypeDef.{Option, Result, Enum} */\n  __internal__extractVariant(lookupIndex, {\n    params,\n    path\n  }, {\n    variants\n  }) {\n    if (path.length) {\n      const specialVariant = path[0].toString();\n      if (specialVariant === 'Option') {\n        if (params.length !== 1) {\n          throw new Error(`Option requires 1 parameter, found ${params.length}`);\n        }\n        // NOTE This is opt-in (unhandled), not by default\n        // if (sub.type === 'bool') {\n        //   return withTypeString(this.registry, {\n        //     info: TypeDefInfo.Plain,\n        //     type: 'OptionBool'\n        //   });\n        // }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.Option,\n          sub: this.__internal__createSiDef(params[0].type.unwrap())\n        });\n      } else if (specialVariant === 'Result') {\n        if (params.length !== 2) {\n          throw new Error(`Result requires 2 parameters, found ${params.length}`);\n        }\n        return withTypeString(this.registry, {\n          info: TypeDefInfo.Result,\n          sub: params.map(({\n            type\n          }, index) => objectSpread({\n            name: ['Ok', 'Error'][index]\n          }, this.__internal__createSiDef(type.unwrap())))\n        });\n      }\n    }\n    if (variants.length === 0) {\n      return {\n        info: TypeDefInfo.Null,\n        type: 'Null'\n      };\n    }\n    return this.__internal__extractVariantEnum(lookupIndex, variants);\n  }\n  /** @internal Extracts a ScaleInfo Variant into TypeDef.Enum */\n  __internal__extractVariantEnum(lookupIndex, variants) {\n    const sub = [];\n    // we may get entries out of order, arrange them first before creating with gaps filled\n    // NOTE: Since we mutate, use a copy of the array as an input\n    variants.slice().sort((a, b) => a.index.cmp(b.index)).forEach(({\n      fields,\n      index: bnIndex,\n      name\n    }) => {\n      const index = bnIndex.toNumber();\n      while (sub.length !== index) {\n        sub.push({\n          index: sub.length,\n          info: TypeDefInfo.Null,\n          name: `__Unused${sub.length}`,\n          type: 'Null'\n        });\n      }\n      sub.push(objectSpread(this.__internal__extractFields(-1, fields), {\n        index,\n        name: name.toString()\n      }));\n    });\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Enum,\n      lookupIndex,\n      lookupName: this.__internal__names[lookupIndex],\n      sub\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}