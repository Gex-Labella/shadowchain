{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction, objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nfunction zeroBalance(api) {\n  return api.registry.createType('Balance');\n}\nfunction getBalance(api, [freeBalance, reservedBalance, frozenFeeOrFrozen, frozenMiscOrFlags], accType) {\n  const votingBalance = api.registry.createType('Balance', freeBalance.toBn());\n  if (accType.isFrameAccountData) {\n    return {\n      frameSystemAccountInfo: {\n        flags: frozenMiscOrFlags,\n        frozen: frozenFeeOrFrozen\n      },\n      freeBalance,\n      frozenFee: api.registry.createType('Balance', 0),\n      frozenMisc: api.registry.createType('Balance', 0),\n      reservedBalance,\n      votingBalance\n    };\n  }\n  return {\n    freeBalance,\n    frozenFee: frozenFeeOrFrozen,\n    frozenMisc: frozenMiscOrFlags,\n    reservedBalance,\n    votingBalance\n  };\n}\nfunction calcBalances(api, [accountId, [accountNonce, [primary, ...additional], accType]]) {\n  return objectSpread({\n    accountId,\n    accountNonce,\n    additional: additional.map(b => getBalance(api, b, accType))\n  }, getBalance(api, primary, accType));\n}\nfunction queryBalancesFree(api, accountId) {\n  return combineLatest([api.query.balances['freeBalance'](accountId), api.query.balances['reservedBalance'](accountId), api.query.system['accountNonce'](accountId)]).pipe(map(([freeBalance, reservedBalance, accountNonce]) => [accountNonce, [[freeBalance, reservedBalance, zeroBalance(api), zeroBalance(api)]], {\n    isFrameAccountData: false\n  }]));\n}\nfunction queryNonceOnly(api, accountId) {\n  const fill = nonce => [nonce, [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]], {\n    isFrameAccountData: false\n  }];\n  return isFunction(api.query.system.account) ? api.query.system.account(accountId).pipe(map(({\n    nonce\n  }) => fill(nonce))) : isFunction(api.query.system['accountNonce']) ? api.query.system['accountNonce'](accountId).pipe(map(nonce => fill(nonce))) : of(fill(api.registry.createType('Index')));\n}\nfunction queryBalancesAccount(api, accountId, modules = ['balances']) {\n  const balances = modules.map(m => api.derive[m]?.customAccount || api.query[m]?.account).filter(q => isFunction(q));\n  const extract = (nonce, data) => [nonce, data.map(({\n    feeFrozen,\n    free,\n    miscFrozen,\n    reserved\n  }) => [free, reserved, feeFrozen, miscFrozen]), {\n    isFrameAccountData: false\n  }];\n  // NOTE this is for the first case where we do have instances specified\n  return balances.length ? isFunction(api.query.system.account) ? combineLatest([api.query.system.account(accountId), ...balances.map(c => c(accountId))]).pipe(map(([{\n    nonce\n  }, ...balances]) => extract(nonce, balances))) : combineLatest([api.query.system['accountNonce'](accountId), ...balances.map(c => c(accountId))]).pipe(map(([nonce, ...balances]) => extract(nonce, balances))) : queryNonceOnly(api, accountId);\n}\nfunction querySystemAccount(api, accountId) {\n  // AccountInfo is current, support old, eg. Edgeware\n  return api.query.system.account(accountId).pipe(map(infoOrTuple => {\n    const data = infoOrTuple.nonce ? infoOrTuple.data : infoOrTuple[1];\n    const nonce = infoOrTuple.nonce || infoOrTuple[0];\n    if (!data || data.isEmpty) {\n      return [nonce, [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]], {\n        isFrameAccountData: false\n      }];\n    }\n    const isFrameType = !!infoOrTuple.data.frozen;\n    if (isFrameType) {\n      const {\n        flags,\n        free,\n        frozen,\n        reserved\n      } = data;\n      return [nonce, [[free, reserved, frozen, flags]], {\n        isFrameAccountData: true\n      }];\n    } else {\n      const {\n        feeFrozen,\n        free,\n        miscFrozen,\n        reserved\n      } = data;\n      return [nonce, [[free, reserved, feeFrozen, miscFrozen]], {\n        isFrameAccountData: false\n      }];\n    }\n  }));\n}\n/**\n * @name account\n * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.\n * @returns An object containing the results of various balance queries\n * @example\n * <BR>\n *\n * ```javascript\n * const ALICE = 'F7Hs';\n *\n * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {\n *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);\n * });\n * ```\n */\nexport function account(instanceId, api) {\n  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, 'balances');\n  const nonDefaultBalances = balanceInstances && balanceInstances[0] !== 'balances';\n  return memo(instanceId, address => api.derive.accounts.accountId(address).pipe(switchMap(accountId => accountId ? combineLatest([of(accountId), nonDefaultBalances ? queryBalancesAccount(api, accountId, balanceInstances) : isFunction(api.query.system?.account) ? querySystemAccount(api, accountId) : isFunction(api.query.balances?.account) ? queryBalancesAccount(api, accountId) : isFunction(api.query.balances?.['freeBalance']) ? queryBalancesFree(api, accountId) : queryNonceOnly(api, accountId)]) : of([api.registry.createType('AccountId'), [api.registry.createType('Index'), [[zeroBalance(api), zeroBalance(api), zeroBalance(api), zeroBalance(api)]], {\n    isFrameAccountData: false\n  }]])), map(result => calcBalances(api, result))));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}