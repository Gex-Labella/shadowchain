{"ast":null,"code":"import { flattenUniq } from './flattenUniq.js';\nimport { validateTypes } from './validateTypes.js';\n/** @internal */\nfunction extractTypes(lookup, types) {\n  return types.map(({\n    type\n  }) => lookup.getTypeDef(type).type);\n}\n/** @internal */\nfunction extractFieldTypes(lookup, type) {\n  return lookup.getSiType(type).def.asVariant.variants.map(({\n    fields\n  }) => extractTypes(lookup, fields));\n}\n/** @internal */\nfunction getPalletNames({\n  lookup,\n  pallets\n}) {\n  return pallets.reduce((all, {\n    calls,\n    constants,\n    events,\n    storage\n  }) => {\n    all.push([extractTypes(lookup, constants)]);\n    if (calls.isSome) {\n      all.push(extractFieldTypes(lookup, calls.unwrap().type));\n    }\n    if (events.isSome) {\n      all.push(extractFieldTypes(lookup, events.unwrap().type));\n    }\n    if (storage.isSome) {\n      all.push(storage.unwrap().items.map(({\n        type\n      }) => {\n        if (type.isPlain) {\n          return [lookup.getTypeDef(type.asPlain).type];\n        }\n        const {\n          hashers,\n          key,\n          value\n        } = type.asMap;\n        return hashers.length === 1 ? [lookup.getTypeDef(value).type, lookup.getTypeDef(key).type] : [lookup.getTypeDef(value).type, ...lookup.getSiType(key).def.asTuple.map(t => lookup.getTypeDef(t).type)];\n      }));\n    }\n    return all;\n  }, []);\n}\n/** @internal */\nexport function getUniqTypes(registry, meta, throwError) {\n  return validateTypes(registry, throwError, flattenUniq(getPalletNames(meta)));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}