{"ast":null,"code":"import { map, of } from 'rxjs';\nimport { BN_ZERO } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { filterCachedEras, getEraMultiCache, setEraMultiCache } from './cache.js';\nimport { erasHistoricApply, filterEras } from './util.js';\nconst CACHE_KEY = 'eraPoints';\nfunction mapValidators({\n  individual\n}) {\n  return [...individual.entries()].filter(([, points]) => points.gt(BN_ZERO)).reduce((result, [validatorId, points]) => {\n    result[validatorId.toString()] = points;\n    return result;\n  }, {});\n}\nfunction mapPoints(eras, points) {\n  return eras.map((era, index) => ({\n    era,\n    eraPoints: points[index].total,\n    validators: mapValidators(points[index])\n  }));\n}\nexport function _erasPoints(instanceId, api) {\n  return memo(instanceId, (eras, withActive) => {\n    if (!eras.length) {\n      return of([]);\n    }\n    const cached = getEraMultiCache(CACHE_KEY, eras, withActive);\n    const remaining = filterEras(eras, cached);\n    return !remaining.length ? of(cached) : api.query.staking.erasRewardPoints.multi(remaining).pipe(map(p => filterCachedEras(eras, cached, setEraMultiCache(CACHE_KEY, withActive, mapPoints(remaining, p)))));\n  });\n}\nexport const erasPoints = /*#__PURE__*/erasHistoricApply('_erasPoints');","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}