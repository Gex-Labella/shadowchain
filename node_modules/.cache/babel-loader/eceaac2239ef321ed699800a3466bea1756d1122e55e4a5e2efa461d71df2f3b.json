{"ast":null,"code":"import { Observable, publishReplay, refCount } from 'rxjs';\nimport { rpcDefinitions } from '@polkadot/types';\nimport { hexToU8a, isFunction, isNull, isUndefined, lazyMethod, logger, memoize, objectSpread, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { drr, refCountDelay } from './util/index.js';\nexport { packageInfo } from './packageInfo.js';\nexport * from './util/index.js';\nconst l = logger('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n};\n/** @internal */\nfunction logErrorMessage(method, {\n  noErrorLog,\n  params,\n  type\n}, error) {\n  if (noErrorLog) {\n    return;\n  }\n  l.error(`${method}(${params.map(({\n    isOptional,\n    name,\n    type\n  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ')}): ${type}:: ${error.message}`);\n}\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\nexport class RpcCore {\n  __internal__instanceId;\n  __internal__isPedantic;\n  __internal__registryDefault;\n  __internal__storageCache = new Map();\n  __internal__storageCacheHits = 0;\n  __internal__storageCacheSize = 0;\n  __internal__getBlockRegistry;\n  __internal__getBlockHash;\n  mapping = new Map();\n  provider;\n  sections = [];\n  /**\n   * @constructor\n   * Default constructor for the core RPC handler\n   * @param  {ProviderInterface} provider An API provider using any of the supported providers (HTTP, SC or WebSocket)\n   */\n  constructor(instanceId, registry, {\n    isPedantic = true,\n    provider,\n    userRpc = {}\n  }) {\n    if (!provider || !isFunction(provider.send)) {\n      throw new Error('Expected Provider to API create');\n    }\n    this.__internal__instanceId = instanceId;\n    this.__internal__isPedantic = isPedantic;\n    this.__internal__registryDefault = registry;\n    this.provider = provider;\n    const sectionNames = Object.keys(rpcDefinitions);\n    // these are the base keys (i.e. part of jsonrpc)\n    this.sections.push(...sectionNames);\n    // decorate all interfaces, defined and user on this instance\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Returns the underlying core stats, including those from teh provider\n   */\n  get stats() {\n    const stats = this.provider.stats;\n    return stats ? {\n      ...stats,\n      core: {\n        cacheHits: this.__internal__storageCacheHits,\n        cacheSize: this.__internal__storageCacheSize\n      }\n    } : undefined;\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n  setRegistrySwap(registrySwap) {\n    this.__internal__getBlockRegistry = memoize(registrySwap, {\n      getInstanceId: () => this.__internal__instanceId\n    });\n  }\n  /**\n   * @description Sets a function to resolve block hash from block number\n   */\n  setResolveBlockHash(resolveBlockHash) {\n    this.__internal__getBlockHash = memoize(resolveBlockHash, {\n      getInstanceId: () => this.__internal__instanceId\n    });\n  }\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(k => !this.sections.includes(k)));\n    for (let s = 0, scount = this.sections.length; s < scount; s++) {\n      const section = this.sections[s];\n      const defs = objectSpread({}, rpcDefinitions[section], userRpc[section]);\n      const methods = Object.keys(defs);\n      for (let m = 0, mcount = methods.length; m < mcount; m++) {\n        const method = methods[m];\n        const def = defs[method];\n        const jsonrpc = def.endpoint || `${section}_${method}`;\n        if (!this.mapping.has(jsonrpc)) {\n          const isSubscription = !!def.pubsub;\n          if (!this[section]) {\n            this[section] = {};\n          }\n          this.mapping.set(jsonrpc, objectSpread({}, def, {\n            isSubscription,\n            jsonrpc,\n            method,\n            section\n          }));\n          lazyMethod(this[section], method, () => isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def));\n        }\n      }\n    }\n  }\n  _memomize(creator, def) {\n    const memoOpts = {\n      getInstanceId: () => this.__internal__instanceId\n    };\n    const memoized = memoize(creator(true), memoOpts);\n    memoized.raw = memoize(creator(false), memoOpts);\n    memoized.meta = def;\n    return memoized;\n  }\n  _formatResult(isScale, registry, blockHash, method, def, params, result) {\n    return isScale ? this._formatOutput(registry, blockHash, method, def, params, result) : result;\n  }\n  _createMethodSend(section, method, def) {\n    const rpcName = def.endpoint || `${section}_${method}`;\n    const hashIndex = def.params.findIndex(({\n      isHistoric\n    }) => isHistoric);\n    let memoized = null;\n    // execute the RPC call, doing a registry swap for historic as applicable\n    const callWithRegistry = async (isScale, values) => {\n      const blockId = hashIndex === -1 ? null : values[hashIndex];\n      const blockHash = blockId && def.params[hashIndex].type === 'BlockNumber' ? await this.__internal__getBlockHash?.(blockId) : blockId;\n      const {\n        registry\n      } = isScale && blockHash && this.__internal__getBlockRegistry ? await this.__internal__getBlockRegistry(u8aToU8a(blockHash)) : {\n        registry: this.__internal__registryDefault\n      };\n      const params = this._formatParams(registry, null, def, values);\n      // only cache .at(<blockHash>) queries, e.g. where valid blockHash was supplied\n      const result = await this.provider.send(rpcName, params.map(p => p.toJSON()), !!blockHash);\n      return this._formatResult(isScale, registry, blockHash, method, def, params, result);\n    };\n    const creator = isScale => (...values) => {\n      const isDelayed = isScale && hashIndex !== -1 && !!values[hashIndex];\n      return new Observable(observer => {\n        callWithRegistry(isScale, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          // delete old results from cache\n          if (isScale) {\n            memoized?.unmemoize(...values);\n          } else {\n            memoized?.raw.unmemoize(...values);\n          }\n        };\n      }).pipe(\n      // eslint-disable-next-line deprecation/deprecation\n      publishReplay(1),\n      // create a Replay(1)\n      isDelayed ? refCountDelay() // Unsubscribe after delay\n      // eslint-disable-next-line deprecation/deprecation\n      : refCount());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  // create a subscriptor, it subscribes once and resolves with the id as subscribe\n  _createSubscriber({\n    paramsJson,\n    subName,\n    subType,\n    update\n  }, errorHandler) {\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n  _createMethodSubscribe(section, method, def) {\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n    let memoized = null;\n    const creator = isScale => (...values) => {\n      return new Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n        const registry = this.__internal__registryDefault;\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n        try {\n          const params = this._formatParams(registry, null, def, values);\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n            try {\n              observer.next(this._formatResult(isScale, registry, null, method, def, params, result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n          subscriptionPromise = this._createSubscriber({\n            paramsJson: params.map(p => p.toJSON()),\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        }\n        // Teardown logic\n        return () => {\n          // Delete from cache, so old results don't hang around\n          if (isScale) {\n            memoized?.unmemoize(...values);\n          } else {\n            memoized?.raw.unmemoize(...values);\n          }\n          // Unsubscribe from provider\n          subscriptionPromise.then(subscriptionId => isNull(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe(drr());\n    };\n    memoized = this._memomize(creator, def);\n    return memoized;\n  }\n  _formatParams(registry, blockHash, def, inputs) {\n    const count = inputs.length;\n    const reqCount = def.params.filter(({\n      isOptional\n    }) => !isOptional).length;\n    if (count < reqCount || count > def.params.length) {\n      throw new Error(`Expected ${def.params.length} parameters${reqCount === def.params.length ? '' : ` (${def.params.length - reqCount} optional)`}, ${count} found instead`);\n    }\n    const params = new Array(count);\n    for (let i = 0; i < count; i++) {\n      params[i] = registry.createTypeUnsafe(def.params[i].type, [inputs[i]], {\n        blockHash\n      });\n    }\n    return params;\n  }\n  _formatOutput(registry, blockHash, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n      return this._formatStorageData(registry, blockHash, key, result);\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, result.block, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const jsonSet = result;\n      const count = jsonSet.length;\n      const mapped = new Array(count);\n      for (let i = 0; i < count; i++) {\n        const {\n          block,\n          changes\n        } = jsonSet[i];\n        mapped[i] = [registry.createType('BlockHash', block), this._formatStorageSet(registry, block, params[0], changes)];\n      }\n      // we only query at a specific block, not a range - flatten\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n    return registry.createTypeUnsafe(rpc.type, [result], {\n      blockHash\n    });\n  }\n  _formatStorageData(registry, blockHash, key, value) {\n    const isEmpty = isNull(value);\n    // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n    const input = isEmpty ? null : isTreatAsHex(key) ? value : u8aToU8a(value);\n    return this._newType(registry, blockHash, key, input, isEmpty);\n  }\n  _formatStorageSet(registry, blockHash, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const count = keys.length;\n    const withCache = count !== 1;\n    const values = new Array(count);\n    // multiple return values (via state.storage subscription), decode the\n    // values one at a time, all based on the supplied query types\n    for (let i = 0; i < count; i++) {\n      values[i] = this._formatStorageSetEntry(registry, blockHash, keys[i], changes, withCache, i);\n    }\n    return values;\n  }\n  _formatStorageSetEntry(registry, blockHash, key, changes, withCache, entryIndex) {\n    const hexKey = key.toHex();\n    const found = changes.find(([key]) => key === hexKey);\n    const isNotFound = isUndefined(found);\n    // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n    if (isNotFound && withCache) {\n      const cached = this.__internal__storageCache.get(hexKey);\n      if (cached) {\n        this.__internal__storageCacheHits++;\n        return cached;\n      }\n    }\n    const value = isNotFound ? null : found[1];\n    const isEmpty = isNull(value);\n    const input = isEmpty || isTreatAsHex(key) ? value : u8aToU8a(value);\n    const codec = this._newType(registry, blockHash, key, input, isEmpty, entryIndex);\n    // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n    this.__internal__storageCache.set(hexKey, codec);\n    this.__internal__storageCacheSize++;\n    return codec;\n  }\n  _newType(registry, blockHash, key, input, isEmpty, entryIndex = -1) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const entryNum = entryIndex === -1 ? '' : ` entry ${entryIndex}:`;\n    try {\n      return registry.createTypeUnsafe(type, [isEmpty ? meta.fallback\n      // For old-style Linkage, we add an empty linkage at the end\n      ? type.includes('Linkage<') ? u8aConcat(hexToU8a(meta.fallback.toHex()), new Uint8Array(2)) : hexToU8a(meta.fallback.toHex()) : undefined : meta.modifier.isOptional ? registry.createTypeUnsafe(type, [input], {\n        blockHash,\n        isPedantic: this.__internal__isPedantic\n      }) : input], {\n        blockHash,\n        isFallback: isEmpty && !!meta.fallback,\n        isOptional: meta.modifier.isOptional,\n        isPedantic: this.__internal__isPedantic && !meta.modifier.isOptional\n      });\n    } catch (error) {\n      throw new Error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}: ${error.message}`);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}