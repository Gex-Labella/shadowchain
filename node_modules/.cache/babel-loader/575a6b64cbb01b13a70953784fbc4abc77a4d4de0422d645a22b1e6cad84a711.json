{"ast":null,"code":"import { u8aEq } from '@polkadot/util';\nimport { jsonDecryptData } from '@polkadot/util-crypto';\nimport { PAIR_DIV, PAIR_HDR, PUB_LENGTH, SEC_LENGTH, SEED_LENGTH } from './defaults.js';\nconst SEED_OFFSET = PAIR_HDR.length;\n/**\n * Decode a pair, taking into account the generation-specific formats and headers\n *\n * For divisor/headers, don't rely on the magic being static. These will\n * change between generations, aka with the long-awaited 4th generation\n * of the format. The external decode interface is the only way to use and decode these.\n **/\nexport function decodePair(passphrase, encrypted, _encType) {\n  const encType = Array.isArray(_encType) || _encType === undefined ? _encType : [_encType];\n  const decrypted = jsonDecryptData(encrypted, passphrase, encType);\n  const header = decrypted.subarray(0, PAIR_HDR.length);\n  // check the start header (generations 1-3)\n  if (!u8aEq(header, PAIR_HDR)) {\n    throw new Error('Invalid encoding header found in body');\n  }\n  // setup for generation 3 format\n  let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n  let divOffset = SEED_OFFSET + SEC_LENGTH;\n  let divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n  // old-style (generation 1 & 2), we have the seed here\n  if (!u8aEq(divider, PAIR_DIV)) {\n    divOffset = SEED_OFFSET + SEED_LENGTH;\n    secretKey = decrypted.subarray(SEED_OFFSET, divOffset);\n    divider = decrypted.subarray(divOffset, divOffset + PAIR_DIV.length);\n    // check the divisior at this point (already checked for generation 3)\n    if (!u8aEq(divider, PAIR_DIV)) {\n      throw new Error('Invalid encoding divider found in body');\n    }\n  }\n  const pubOffset = divOffset + PAIR_DIV.length;\n  const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}