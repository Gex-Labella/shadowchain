{"ast":null,"code":"import { hexToU8a, isHex, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, ed25519PairFromSeed as ed25519FromSeed, encodeAddress, ethereumEncode, hdEthereum, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, secp256k1PairFromSeed as secp256k1FromSeed, sr25519PairFromSeed as sr25519FromSeed } from '@polkadot/util-crypto';\nimport { createPair } from './pair/index.js';\nimport { DEV_PHRASE } from './defaults.js';\nimport { Pairs } from './pairs.js';\nconst PairFromSeed = {\n  ecdsa: seed => secp256k1FromSeed(seed),\n  ed25519: seed => ed25519FromSeed(seed),\n  ethereum: seed => secp256k1FromSeed(seed),\n  sr25519: seed => sr25519FromSeed(seed)\n};\nfunction pairToPublic({\n  publicKey\n}) {\n  return publicKey;\n}\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\nexport class Keyring {\n  #pairs;\n  #type;\n  #ss58;\n  decodeAddress = decodeAddress;\n  constructor(options = {}) {\n    options.type = options.type || 'ed25519';\n    if (!['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined')) {\n      throw new Error(`Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);\n    }\n    this.#pairs = new Pairs();\n    this.#ss58 = options.ss58Format;\n    this.#type = options.type;\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n  get pairs() {\n    return this.getPairs();\n  }\n  /**\n   * @description retrieve the publicKeys (alias for getPublicKeys)\n   */\n  get publicKeys() {\n    return this.getPublicKeys();\n  }\n  /**\n   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n   */\n  get type() {\n    return this.#type;\n  }\n  /**\n   * @name addPair\n   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   */\n  addPair(pair) {\n    return this.#pairs.add(pair);\n  }\n  /**\n   * @name addFromAddress\n   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally\n   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from them that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n    const publicKey = this.decodeAddress(address, ignoreChecksum);\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, encoded, encType));\n  }\n  /**\n   * @name addFromJson\n   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromJson(json, ignoreChecksum) {\n    return this.addPair(this.createFromJson(json, ignoreChecksum));\n  }\n  /**\n   * @name addFromMnemonic\n   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n   * argument and a metadata argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromMnemonic(mnemonic, meta = {}, type = this.type, wordlist) {\n    return this.addFromUri(mnemonic, meta, type, wordlist);\n  }\n  /**\n   * @name addFromPair\n   * @summary Stores an account created from an explicit publicKey/secreteKey combination\n   */\n  addFromPair(pair, meta = {}, type = this.type) {\n    return this.addPair(this.createFromPair(pair, meta, type));\n  }\n  /**\n   * @name addFromSeed\n   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n  addFromSeed(seed, meta = {}, type = this.type) {\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, PairFromSeed[type](seed), meta, null));\n  }\n  /**\n   * @name addFromUri\n   * @summary Creates an account via an suri\n   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n   */\n  addFromUri(suri, meta = {}, type = this.type, wordlist) {\n    return this.addPair(this.createFromUri(suri, meta, type, wordlist));\n  }\n  /**\n   * @name createFromJson\n   * @description Creates a pair from a JSON keyfile\n   */\n  createFromJson({\n    address,\n    encoded,\n    encoding: {\n      content,\n      type,\n      version\n    },\n    meta\n  }, ignoreChecksum) {\n    if (version === '3' && content[0] !== 'pkcs8') {\n      throw new Error(`Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);\n    }\n    const cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n    const encType = !Array.isArray(type) ? [type] : type;\n    if (!['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType)) {\n      throw new Error(`Unknown crypto type ${cryptoType}`);\n    }\n    // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs\n    const publicKey = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);\n    const decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, decoded, encType);\n  }\n  /**\n   * @name createFromPair\n   * @summary Creates a pair from an explicit publicKey/secreteKey combination\n   */\n  createFromPair(pair, meta = {}, type = this.type) {\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, pair, meta, null);\n  }\n  /**\n   * @name createFromUri\n   * @summary Creates a Keypair from an suri\n   * @description This creates a pair from the suri, but does not add it to the keyring\n   */\n  createFromUri(_suri, meta = {}, type = this.type, wordlist) {\n    // here we only aut-add the dev phrase if we have a hard-derived path\n    const suri = _suri.startsWith('//') ? `${DEV_PHRASE}${_suri}` : _suri;\n    const {\n      derivePath,\n      password,\n      path,\n      phrase\n    } = keyExtractSuri(suri);\n    let seed;\n    const isPhraseHex = isHex(phrase, 256);\n    if (isPhraseHex) {\n      seed = hexToU8a(phrase);\n    } else {\n      const parts = phrase.split(' ');\n      if ([12, 15, 18, 21, 24].includes(parts.length)) {\n        seed = type === 'ethereum' ? mnemonicToLegacySeed(phrase, '', false, 64) : mnemonicToMiniSecret(phrase, password, wordlist);\n      } else {\n        if (phrase.length > 32) {\n          throw new Error('specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n        }\n        seed = stringToU8a(phrase.padEnd(32));\n      }\n    }\n    const derived = type === 'ethereum' ? isPhraseHex ? PairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once\n    : hdEthereum(seed, derivePath.substring(1)) : keyFromPath(PairFromSeed[type](seed), path, type);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, derived, meta, null);\n  }\n  /**\n   * @name encodeAddress\n   * @description Encodes the input into an ss58 representation\n   */\n  encodeAddress = (address, ss58Format) => {\n    return this.type === 'ethereum' ? ethereumEncode(address) : encodeAddress(address, ss58Format ?? this.#ss58);\n  };\n  /**\n   * @name getPair\n   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n   * @description Returns a keyring pair value from the keyring pair dictionary by performing\n   * a key lookup using the provided account address or public key (after decoding it).\n   */\n  getPair(address) {\n    return this.#pairs.get(address);\n  }\n  /**\n   * @name getPairs\n   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n   */\n  getPairs() {\n    return this.#pairs.all();\n  }\n  /**\n   * @name getPublicKeys\n   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n   */\n  getPublicKeys() {\n    return this.#pairs.all().map(pairToPublic);\n  }\n  /**\n   * @name removePair\n   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n   */\n  removePair(address) {\n    this.#pairs.remove(address);\n  }\n  /**\n   * @name setSS58Format;\n   * @description Sets the ss58 format for the keyring\n   */\n  setSS58Format(ss58) {\n    this.#ss58 = ss58;\n  }\n  /**\n   * @name toJson\n   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n   * @description Returns a JSON object containing the metadata associated with an account\n   * when valid address or public key and when the account passphrase is provided if the account secret\n   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n   * may backup their account to a JSON file that contains this information.\n   */\n  toJson(address, passphrase) {\n    return this.#pairs.get(address).toJson(passphrase);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}