{"ast":null,"code":"import { u8aToHex } from '@polkadot/util';\n/** @internal */\nfunction formatFailure(registry, fn, _result, {\n  message\n}, u8a, i, count, Type, key) {\n  let type = '';\n  try {\n    type = `: ${new Type(registry).toRawType()}`;\n  } catch {\n    // ignore\n  }\n  // This is extra debugging info (we most-probably want this in in some way, shape or form,\n  // but at this point not quite sure how to include and format it (it can be quite massive)\n  // console.error(JSON.stringify(result, null, 2));\n  return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}â€¦${key ? ` on ${key}` : ''} (index ${i + 1}/${count})${type}:: ${message}`;\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, [Types, keys]) {\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, [Types, keys]) {\n  const count = result.length;\n  let offset = 0;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Types[i](registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = [keys[i], value];\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n  }\n  return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n  const count = result.length;\n  let offset = startAt;\n  let i = 0;\n  try {\n    while (i < count) {\n      const value = new Type(registry, u8a.subarray(offset));\n      offset += value.initialU8aLength || value.encodedLength;\n      result[i] = value;\n      i++;\n    }\n  } catch (error) {\n    throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n  }\n  return [offset, offset - startAt];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}