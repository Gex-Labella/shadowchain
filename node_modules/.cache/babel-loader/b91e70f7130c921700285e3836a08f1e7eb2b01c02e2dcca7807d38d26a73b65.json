{"ast":null,"code":"import { getTypeDef } from '@polkadot/types-create';\nimport { createFunction } from './createFunction.js';\nfunction findSiPrimitive(registry, type) {\n  const prim = type.toLowerCase();\n  return registry.lookup.types.find(t => t.type.def.isPrimitive && t.type.def.asPrimitive.toString().toLowerCase() === prim || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);\n}\nfunction findSiType(registry, type) {\n  let portable = findSiPrimitive(registry, type);\n  // some types are either Sequence or Arrays, cater for these\n  // specifically (these all come from the base substrate known keys)\n  if (!portable && (type === 'Bytes' || type.startsWith('[u8;'))) {\n    const u8 = findSiPrimitive(registry, 'u8');\n    if (u8) {\n      if (type === 'Bytes') {\n        portable = registry.lookup.types.find(t => t.type.def.isSequence && t.type.def.asSequence.type.eq(u8.id) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(type));\n      } else {\n        const td = getTypeDef(type);\n        portable = registry.lookup.types.find(t => t.type.def.isArray && t.type.def.asArray.eq({\n          len: td.length,\n          type: u8.id\n        }) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(type));\n      }\n    }\n  }\n  if (!portable) {\n    // Not fatal, however if this happens the storage key using this\n    // type will not return valid values, rather it will most probably\n    // be decoded incorrectly\n    console.warn(`Unable to map ${type} to a lookup index`);\n  }\n  return portable;\n}\n/** @internal */\nexport function createRuntimeFunction({\n  method,\n  prefix,\n  section\n}, key, {\n  docs,\n  type\n}) {\n  return registry => createFunction(registry, {\n    meta: registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n      docs: registry.createTypeUnsafe('Vec<Text>', [[docs]]),\n      modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', ['Required']),\n      name: registry.createTypeUnsafe('Text', [method]),\n      toJSON: () => key,\n      type: registry.createTypeUnsafe('StorageEntryTypeLatest', [{\n        Plain: findSiType(registry, type)?.id || 0\n      }])\n    }]),\n    method,\n    prefix,\n    section\n  }, {\n    key,\n    skipHashing: true\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}