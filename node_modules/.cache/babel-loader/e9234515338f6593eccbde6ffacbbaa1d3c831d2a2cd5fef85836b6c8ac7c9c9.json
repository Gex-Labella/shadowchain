{"ast":null,"code":"import { bnToBn } from '@polkadot/util';\nimport { typesChain } from './chain/index.js';\nimport { typesSpec } from './spec/index.js';\nimport { upgrades } from './upgrades/index.js';\n/**\n * @description Perform the callback function using the stringified spec/chain\n * @internal\n * */\nfunction withNames(chainName, specName, fn) {\n  return fn(chainName.toString(), specName.toString());\n}\n/**\n * @descriptionFflatten a VersionedType[] into a Record<string, string>\n * @internal\n * */\nfunction filterVersions(versions = [], specVersion) {\n  return versions.filter(({\n    minmax: [min, max]\n  }) => (min === undefined || min === null || specVersion >= min) && (max === undefined || max === null || specVersion <= max)).reduce((result, {\n    types\n  }) => ({\n    ...result,\n    ...types\n  }), {});\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable signed extensions (ready for registration)\n */\nexport function getSpecExtensions({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    ...(knownTypes.typesBundle?.spec?.[s]?.signedExtensions ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.signedExtensions ?? {})\n  }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable types (ready for registration)\n */\nexport function getSpecTypes({\n  knownTypes\n}, chainName, specName, specVersion) {\n  const _specVersion = bnToBn(specVersion).toNumber();\n  return withNames(chainName, specName, (c, s) => ({\n    // The order here is always, based on -\n    //   - spec then chain\n    //   - typesBundle takes higher precedence\n    //   - types is the final catch-all override\n    ...filterVersions(typesSpec[s], _specVersion),\n    ...filterVersions(typesChain[c], _specVersion),\n    ...filterVersions(knownTypes.typesBundle?.spec?.[s]?.types, _specVersion),\n    ...filterVersions(knownTypes.typesBundle?.chain?.[c]?.types, _specVersion),\n    ...(knownTypes.typesSpec?.[s] ?? {}),\n    ...(knownTypes.typesChain?.[c] ?? {}),\n    ...(knownTypes.types ?? {})\n  }));\n}\n/**\n * @description Based on the chain or spec, return the hasher used\n */\nexport function getSpecHasher({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => knownTypes.hasher || knownTypes.typesBundle?.chain?.[c]?.hasher || knownTypes.typesBundle?.spec?.[s]?.hasher || null);\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable rpc definitions (ready for registration)\n */\nexport function getSpecRpc({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    ...(knownTypes.typesBundle?.spec?.[s]?.rpc ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.rpc ?? {})\n  }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable runtime definitions (ready for registration)\n */\nexport function getSpecRuntime({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    ...(knownTypes.typesBundle?.spec?.[s]?.runtime ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.runtime ?? {})\n  }));\n}\n/**\n * @description Based on the chain and runtimeVersion, get the applicable alias definitions (ready for registration)\n */\nexport function getSpecAlias({\n  knownTypes\n}, chainName, specName) {\n  return withNames(chainName, specName, (c, s) => ({\n    // as per versions, first spec, then chain then finally non-versioned\n    ...(knownTypes.typesBundle?.spec?.[s]?.alias ?? {}),\n    ...(knownTypes.typesBundle?.chain?.[c]?.alias ?? {}),\n    ...(knownTypes.typesAlias ?? {})\n  }));\n}\n/**\n * @description Returns a version record for known chains where upgrades are being tracked\n */\nexport function getUpgradeVersion(genesisHash, blockNumber) {\n  const known = upgrades.find(u => genesisHash.eq(u.genesisHash));\n  return known ? [known.versions.reduce((last, version) => {\n    return blockNumber.gt(version.blockNumber) ? version : last;\n  }, undefined), known.versions.find(version => blockNumber.lte(version.blockNumber))] : [undefined, undefined];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}