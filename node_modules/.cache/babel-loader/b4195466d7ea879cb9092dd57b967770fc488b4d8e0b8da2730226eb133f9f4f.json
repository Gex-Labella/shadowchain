{"ast":null,"code":"import { Raw } from '@polkadot/types-codec';\nimport { compactAddLength, compactStripLength, isUndefined, objectSpread, stringCamelCase, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getSiName } from '../../util/index.js';\nimport { getHasher } from './getHasher.js';\nexport const NO_RAW_ARGS = {\n  args: [],\n  hashers: [],\n  keys: []\n};\n/** @internal */\nfunction filterDefined(a) {\n  return !isUndefined(a);\n}\n/** @internal */\nfunction assertArgs({\n  method,\n  section\n}, {\n  args,\n  keys\n}) {\n  if (!Array.isArray(args)) {\n    throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments`);\n  } else if (args.filter(filterDefined).length !== keys.length) {\n    throw new Error(`Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`);\n  }\n}\n/** @internal */\nexport function createKeyRawParts(registry, itemFn, {\n  args,\n  hashers,\n  keys\n}) {\n  const count = keys.length;\n  const extra = new Array(count);\n  for (let i = 0; i < count; i++) {\n    extra[i] = getHasher(hashers[i])(registry.createTypeUnsafe(registry.createLookupType(keys[i]), [args[i]]).toU8a());\n  }\n  return [[xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128)], extra];\n}\n/** @internal */\nexport function createKeyInspect(registry, itemFn, args) {\n  assertArgs(itemFn, args);\n  const {\n    meta\n  } = itemFn;\n  const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n  let types = [];\n  if (meta.type.isMap) {\n    const {\n      hashers,\n      key\n    } = meta.type.asMap;\n    types = hashers.length === 1 ? [`${hashers[0].type}(${getSiName(registry.lookup, key)})`] : registry.lookup.getSiType(key).def.asTuple.map((k, i) => `${hashers[i].type}(${getSiName(registry.lookup, k)})`);\n  }\n  const names = ['module', 'method'].concat(...args.args.map((_, i) => types[i]));\n  return {\n    inner: prefix.concat(...extra).map((v, i) => ({\n      name: names[i],\n      outer: [v]\n    }))\n  };\n}\n/** @internal */\nexport function createKeyRaw(registry, itemFn, args) {\n  const [prefix, extra] = createKeyRawParts(registry, itemFn, args);\n  return u8aConcat(...prefix, ...extra);\n}\n/** @internal */\nfunction createKey(registry, itemFn, args) {\n  assertArgs(itemFn, args);\n  // always add the length prefix (underlying it is Bytes)\n  return compactAddLength(createKeyRaw(registry, itemFn, args));\n}\n/** @internal */\nfunction createStorageInspect(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  return (...args) => {\n    if (type.isPlain) {\n      return options.skipHashing ? {\n        inner: [],\n        name: 'wellKnown',\n        outer: [u8aToU8a(options.key)]\n      } : createKeyInspect(registry, itemFn, NO_RAW_ARGS);\n    }\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    return hashers.length === 1 ? createKeyInspect(registry, itemFn, {\n      args,\n      hashers,\n      keys: [key]\n    }) : createKeyInspect(registry, itemFn, {\n      args,\n      hashers,\n      keys: registry.lookup.getSiType(key).def.asTuple\n    });\n  };\n}\n/** @internal */\nfunction createStorageFn(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  let cacheKey = null;\n  // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n  return (...args) => {\n    if (type.isPlain) {\n      if (!cacheKey) {\n        cacheKey = options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, NO_RAW_ARGS);\n      }\n      return cacheKey;\n    }\n    const {\n      hashers,\n      key\n    } = type.asMap;\n    return hashers.length === 1 ? createKey(registry, itemFn, {\n      args,\n      hashers,\n      keys: [key]\n    }) : createKey(registry, itemFn, {\n      args,\n      hashers,\n      keys: registry.lookup.getSiType(key).def.asTuple\n    });\n  };\n}\n/** @internal */\nfunction createWithMeta(registry, itemFn, options) {\n  const {\n    meta,\n    method,\n    prefix,\n    section\n  } = itemFn;\n  const storageFn = createStorageFn(registry, itemFn, options);\n  storageFn.inspect = createStorageInspect(registry, itemFn, options);\n  storageFn.meta = meta;\n  storageFn.method = stringCamelCase(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section;\n  // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n  storageFn.toJSON = () => objectSpread({\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  }, meta.toJSON());\n  return storageFn;\n}\n/** @internal */\nfunction extendHeadMeta(registry, {\n  meta: {\n    docs,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n  const meta = registry.createTypeUnsafe('StorageEntryMetadataLatest', [{\n    docs,\n    fallback: registry.createTypeUnsafe('Bytes', []),\n    modifier: registry.createTypeUnsafe('StorageEntryModifierLatest', [1]),\n    // required\n    name,\n    type: registry.createTypeUnsafe('StorageEntryTypeLatest', [type.asMap.key, 0])\n  }]);\n  iterFn.meta = meta;\n  const fn = (...args) => registry.createTypeUnsafe('StorageKey', [iterFn(...args), {\n    method,\n    section\n  }]);\n  fn.meta = meta;\n  return fn;\n}\n/** @internal */\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    if (args.length && (type.isPlain || args.length >= type.asMap.hashers.length)) {\n      throw new Error(`Iteration of ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);\n    }\n    if (args.length) {\n      if (type.isMap) {\n        const {\n          hashers,\n          key\n        } = type.asMap;\n        const keysVec = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;\n        return new Raw(registry, createKeyRaw(registry, itemFn, {\n          args,\n          hashers: hashers.slice(0, args.length),\n          keys: keysVec.slice(0, args.length)\n        }));\n      }\n    }\n    return new Raw(registry, createKeyRaw(registry, itemFn, NO_RAW_ARGS));\n  });\n  return storageFn;\n}\n/** @internal */\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const storageFn = createWithMeta(registry, itemFn, options);\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n  return storageFn;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}