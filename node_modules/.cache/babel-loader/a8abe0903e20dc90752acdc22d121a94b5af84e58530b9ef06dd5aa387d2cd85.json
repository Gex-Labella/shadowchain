{"ast":null,"code":"import { BN, BN_BILLION, BN_HUNDRED, BN_MILLION, BN_QUINTILL, bnToBn, bnToHex, bnToU8a, formatBalance, formatNumber, hexToBn, isBigInt, isBn, isFunction, isHex, isNumber, isObject, isString, isU8a, u8aToBn, u8aToNumber } from '@polkadot/util';\nexport const DEFAULT_UINT_BITS = 64;\nconst MAX_NUMBER_BITS = 52;\nconst MUL_P = new BN(1_00_00);\nconst FORMATTERS = [['Perquintill', BN_QUINTILL], ['Perbill', BN_BILLION], ['Permill', BN_MILLION], ['Percent', BN_HUNDRED]];\nfunction isToBn(value) {\n  return isFunction(value.toBn);\n}\nfunction toPercentage(value, divisor) {\n  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;\n}\n/** @internal */\nfunction decodeAbstractInt(value, isNegative) {\n  if (isNumber(value)) {\n    if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n      throw new Error('Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1');\n    }\n    return value;\n  } else if (isString(value)) {\n    if (isHex(value, -1, true)) {\n      return hexToBn(value, {\n        isLe: false,\n        isNegative\n      }).toString();\n    }\n    if (value.includes('.') || value.includes(',') || value.includes('e')) {\n      throw new Error('String should not contain decimal points or scientific notation');\n    }\n    return value;\n  } else if (isBn(value) || isBigInt(value)) {\n    return value.toString();\n  } else if (isObject(value)) {\n    if (isToBn(value)) {\n      return value.toBn().toString();\n    }\n    // Allow the construction from an object with a single top-level key. This means that\n    // single key objects can be treated equivalently to numbers, assuming they meet the\n    // specific requirements. (This is useful in Weights 1.5 where Objects are compact)\n    const keys = Object.keys(value);\n    if (keys.length !== 1) {\n      throw new Error('Unable to construct number from multi-key object');\n    }\n    return decodeAbstractInt(value[keys[0]], isNegative);\n  } else if (!value) {\n    return 0;\n  }\n  throw new Error(`Unable to create BN from unknown type ${typeof value}`);\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\nexport class AbstractInt extends BN {\n  registry;\n  encodedLength;\n  isUnsigned;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__bitLength;\n  constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {\n    // Construct via a string/number, which will be passed in the BN constructor.\n    // It would be ideal to actually return a BN, but there is an issue:\n    // https://github.com/indutny/bn.js/issues/206\n    super(\n    // shortcut isU8a as used in SCALE decoding\n    isU8a(value) ? bitLength <= 48 ? u8aToNumber(value.subarray(0, bitLength / 8), {\n      isNegative: isSigned\n    }) : u8aToBn(value.subarray(0, bitLength / 8), {\n      isLe: true,\n      isNegative: isSigned\n    }).toString() : decodeAbstractInt(value, isSigned));\n    this.registry = registry;\n    this.__internal__bitLength = bitLength;\n    this.encodedLength = this.__internal__bitLength / 8;\n    this.initialU8aLength = this.__internal__bitLength / 8;\n    this.isUnsigned = !isSigned;\n    const isNegative = this.isNeg();\n    const maxBits = bitLength - (isSigned && !isNegative ? 1 : 0);\n    if (isNegative && !isSigned) {\n      throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);\n    } else if (super.bitLength() > maxBits) {\n      throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);\n    }\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is a zero value (align elsewhere)\n   */\n  get isEmpty() {\n    return this.isZero();\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n  bitLength() {\n    return this.__internal__bitLength;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  eq(other) {\n    // Here we are actually overriding the built-in .eq to take care of both\n    // number and BN inputs (no `.eqn` needed) - numbers will be converted\n    return super.eq(isHex(other) ? hexToBn(other.toString(), {\n      isLe: false,\n      isNegative: !this.isUnsigned\n    }) : bnToBn(other));\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      outer: [this.toU8a()]\n    };\n  }\n  /**\n   * @description True if this value is the max of the type\n   */\n  isMax() {\n    const u8a = this.toU8a().filter(b => b === 0xff);\n    return u8a.length === this.__internal__bitLength / 8;\n  }\n  /**\n   * @description Returns a BigInt representation of the number\n   */\n  toBigInt() {\n    return BigInt(this.toString());\n  }\n  /**\n   * @description Returns the BN representation of the number. (Compatibility)\n   */\n  toBn() {\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex(isLe = false) {\n    // For display/JSON, this is BE, for compare, use isLe\n    return bnToHex(this, {\n      bitLength: this.bitLength(),\n      isLe,\n      isNegative: !this.isUnsigned\n    });\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(_isExpanded) {\n    const rawType = this.toRawType();\n    if (rawType === 'Balance') {\n      return this.isMax() ? 'everything'\n      // FIXME In the case of multiples we need some way of detecting which instance this belongs\n      // to. as it stands we will always format (incorrectly) against the first token defined\n      : formatBalance(this, {\n        decimals: this.registry.chainDecimals[0],\n        withSi: true,\n        withUnit: this.registry.chainTokens[0]\n      });\n    }\n    const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];\n    return divisor ? toPercentage(this, divisor) : formatNumber(this);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON(onlyHex = false) {\n    // FIXME this return type should by string | number, however BN returns string\n    // Options here are\n    //   - super.bitLength() - the actual used bits, use hex when close to MAX_SAFE_INTEGER\n    //   - this.__internal__bitLength - the max used bits, use hex when larger than native Rust type\n    return onlyHex || this.__internal__bitLength > 128 || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();\n  }\n  /**\n   * @description Returns the value in a primitive form, either number when <= 52 bits, or string otherwise\n   */\n  toPrimitive() {\n    return super.bitLength() > MAX_NUMBER_BITS ? this.toString() : this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    // NOTE In the case of balances, which have a special meaning on the UI\n    // and can be interpreted differently, return a specific value for it so\n    // underlying it always matches (no matter which length it actually is)\n    return this instanceof this.registry.createClassUnsafe('Balance') ? 'Balance' : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   * @param base The base to use for the conversion\n   */\n  toString(base) {\n    // only included here since we do not inherit docs\n    return super.toString(base);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   */\n  toU8a(_isBare) {\n    return bnToU8a(this, {\n      bitLength: this.bitLength(),\n      isLe: true,\n      isNegative: !this.isUnsigned\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}