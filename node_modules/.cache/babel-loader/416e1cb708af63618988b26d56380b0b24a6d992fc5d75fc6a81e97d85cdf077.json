{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nfunction rewardDestinationCompat(rewardDestination) {\n  // We ensure the type is an Option by checking if isSome is a boolean. When isSome doesn't exist it will always return undefined.\n  return typeof rewardDestination.isSome === 'boolean' ? rewardDestination.unwrapOr(null) : rewardDestination;\n}\nfunction filterClaimedRewards(api, cl) {\n  return api.registry.createType('Vec<u32>', cl.filter(c => c !== -1));\n}\nfunction filterRewards(stashIds, eras, claimedRewards, stakersOverview) {\n  const claimedData = {};\n  const overviewData = {};\n  const ids = stashIds.map(i => i.toString());\n  claimedRewards.forEach(([keys, rewards]) => {\n    const id = keys.args[1].toString();\n    const era = keys.args[0].toNumber();\n    if (ids.includes(id)) {\n      if (claimedData[id]) {\n        claimedData[id].set(era, rewards.toArray());\n      } else {\n        claimedData[id] = new Map();\n        claimedData[id].set(era, rewards.toArray());\n      }\n    }\n  });\n  stakersOverview.forEach(([keys, overview]) => {\n    const id = keys.args[1].toString();\n    const era = keys.args[0].toNumber();\n    if (ids.includes(id) && overview.isSome) {\n      if (overviewData[id]) {\n        overviewData[id].set(era, overview.unwrap().pageCount);\n      } else {\n        overviewData[id] = new Map();\n        overviewData[id].set(era, overview.unwrap().pageCount);\n      }\n    }\n  });\n  return stashIds.map(id => {\n    const rewardsPerEra = claimedData[id.toString()];\n    const overviewPerEra = overviewData[id.toString()];\n    return eras.map(era => {\n      if (rewardsPerEra && rewardsPerEra.has(era) && overviewPerEra && overviewPerEra.has(era)) {\n        const rewards = rewardsPerEra.get(era);\n        const pageCount = overviewPerEra.get(era);\n        return rewards.length === pageCount.toNumber() ? era : -1;\n      }\n      return -1;\n    });\n  });\n}\nfunction parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers) {\n  return {\n    accountId: stashId,\n    claimedRewardsEras: filterClaimedRewards(api, claimedRewards),\n    controllerId: controllerIdOpt?.unwrapOr(null) || null,\n    exposureEraStakers,\n    exposureMeta,\n    exposurePaged: exposure,\n    nominators: nominatorsOpt.isSome ? nominatorsOpt.unwrap().targets : [],\n    rewardDestination: rewardDestinationCompat(rewardDestinationOpts),\n    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),\n    stashId,\n    validatorPrefs\n  };\n}\nfunction getLedgers(api, optIds, {\n  withLedger = false\n}) {\n  const ids = optIds.filter(o => withLedger && !!o && o.isSome).map(o => o.unwrap());\n  const emptyLed = api.registry.createType('Option<StakingLedger>');\n  return (ids.length ? combineLatest(ids.map(s => api.query.staking.ledger(s))) : of([])).pipe(map(optLedgers => {\n    let offset = -1;\n    return optIds.map(o => o && o.isSome ? optLedgers[++offset] || emptyLed : emptyLed);\n  }));\n}\nfunction getStashInfo(api, stashIds, activeEra, {\n  withClaimedRewardsEras,\n  withController,\n  withDestination,\n  withExposure,\n  withExposureErasStakersLegacy,\n  withExposureMeta,\n  withLedger,\n  withNominations,\n  withPrefs\n}, page) {\n  const emptyNoms = api.registry.createType('Option<Nominations>');\n  const emptyRewa = api.registry.createType('RewardDestination');\n  const emptyExpoEraStakers = api.registry.createType('Exposure');\n  const emptyPrefs = api.registry.createType('ValidatorPrefs');\n  // The reason we don't explicitly make the actual types is for compatibility. If the chain doesn't have the noted type it will fail\n  // on construction. Therefore we just make an empty option.\n  const emptyExpo = api.registry.createType('Option<Null>');\n  const emptyExpoMeta = api.registry.createType('Option<Null>');\n  const emptyClaimedRewards = [-1];\n  const depth = Number(api.consts.staking.historyDepth.toNumber());\n  const eras = new Array(depth).fill(0).map((_, idx) => {\n    if (idx === 0) {\n      return activeEra.toNumber() - 1;\n    }\n    return activeEra.toNumber() - idx - 1;\n  });\n  return combineLatest([withController || withLedger ? combineLatest(stashIds.map(s => api.query.staking.bonded(s))) : of(stashIds.map(() => null)), withNominations ? combineLatest(stashIds.map(s => api.query.staking.nominators(s))) : of(stashIds.map(() => emptyNoms)), withDestination ? combineLatest(stashIds.map(s => api.query.staking.payee(s))) : of(stashIds.map(() => emptyRewa)), withPrefs ? combineLatest(stashIds.map(s => api.query.staking.validators(s))) : of(stashIds.map(() => emptyPrefs)), withExposure && api.query.staking.erasStakersPaged ? combineLatest(stashIds.map(s => api.query.staking.erasStakersPaged(activeEra, s, page))) : of(stashIds.map(() => emptyExpo)), withExposureMeta && api.query.staking.erasStakersOverview ? combineLatest(stashIds.map(s => api.query.staking.erasStakersOverview(activeEra, s))) : of(stashIds.map(() => emptyExpoMeta)), withClaimedRewardsEras && api.query.staking.claimedRewards ? combineLatest([api.query.staking.claimedRewards.entries(), api.query.staking.erasStakersOverview.entries()]).pipe(map(([rewardsStorageVec, overviewStorageVec]) => filterRewards(stashIds, eras, rewardsStorageVec, overviewStorageVec))) : of(stashIds.map(() => emptyClaimedRewards)), withExposureErasStakersLegacy && api.query.staking.erasStakers ? combineLatest(stashIds.map(s => api.query.staking.erasStakers(activeEra, s))) : of(stashIds.map(() => emptyExpoEraStakers))]);\n}\nfunction getBatch(api, activeEra, stashIds, flags, page) {\n  return getStashInfo(api, stashIds, activeEra, flags, page).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers]) => getLedgers(api, controllerIdOpt, flags).pipe(map(stakingLedgerOpts => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index]))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and all relevant details\n */\nexport const query = /*#__PURE__*/firstMemo((api, accountId, flags, page) => api.derive.staking.queryMulti([accountId], flags, page));\nexport function queryMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, flags, page) => api.derive.session.indexes().pipe(switchMap(({\n    activeEra\n  }) => {\n    const stashIds = accountIds.map(a => api.registry.createType('AccountId', a));\n    const p = page || 0;\n    return stashIds.length ? getBatch(api, activeEra, stashIds, flags, p) : of([]);\n  })));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}