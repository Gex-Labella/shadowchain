{"ast":null,"code":"import { isBoolean, isHex, isObject, isU8a, isUndefined, objectProperties, stringCamelCase, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareMap, decodeU8aStruct, mapToTypeMap, typesToMap } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n  return d;\n}\n/** @internal */\nfunction decodeStructFromObject(registry, [Types, keys], value, jsonMap) {\n  let jsonObj;\n  const typeofArray = Array.isArray(value);\n  const typeofMap = value instanceof Map;\n  const count = keys.length;\n  if (!typeofArray && !typeofMap && !isObject(value)) {\n    throw new Error(`Struct: Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object, map or array`);\n  } else if (typeofArray && value.length !== count) {\n    throw new Error(`Struct: Unable to map ${stringify(value)} array to object with known keys ${keys.join(', ')}`);\n  }\n  const raw = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const key = keys[i];\n    const jsonKey = jsonMap.get(key) || key;\n    const Type = Types[i];\n    let assign;\n    try {\n      if (typeofArray) {\n        assign = value[i];\n      } else if (typeofMap) {\n        assign = jsonKey && value.get(jsonKey);\n      } else {\n        assign = jsonKey && value[jsonKey];\n        if (isUndefined(assign)) {\n          if (isUndefined(jsonObj)) {\n            const entries = Object.entries(value);\n            jsonObj = {};\n            for (let e = 0, ecount = entries.length; e < ecount; e++) {\n              jsonObj[stringCamelCase(entries[e][0])] = entries[e][1];\n            }\n          }\n          assign = jsonKey && jsonObj[jsonKey];\n        }\n      }\n      raw[i] = [key, assign instanceof Type ? assign : new Type(registry, assign)];\n    } catch (error) {\n      let type = Type.name;\n      try {\n        type = new Type(registry).toRawType();\n      } catch {\n        // ignore\n      }\n      throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);\n    }\n  }\n  return [raw, 0];\n}\n/**\n * @name Struct\n * @description\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\n * values in the constructor and it manages the decoding. It is important that the constructor\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\n * it needs to decoded in the specific defined order.\n * @noInheritDoc\n */\nexport class Struct extends Map {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__jsonMap;\n  __internal__Types;\n  constructor(registry, Types, value, jsonMap = new Map(), {\n    definition,\n    setDefinition = noopSetDefinition\n  } = {}) {\n    const typeMap = definition || setDefinition(mapToTypeMap(registry, Types));\n    const [decoded, decodedLength] = isU8a(value) || isHex(value) ? decodeU8aStruct(registry, new Array(typeMap[0].length), u8aToU8a(value), typeMap) : value instanceof Struct ? [value, 0] : decodeStructFromObject(registry, typeMap, value || {}, jsonMap);\n    super(decoded);\n    this.initialU8aLength = decodedLength;\n    this.registry = registry;\n    this.__internal__jsonMap = jsonMap;\n    this.__internal__Types = typeMap;\n  }\n  static with(Types, jsonMap) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Struct {\n      static {\n        const keys = Object.keys(Types);\n        objectProperties(this.prototype, keys, (k, _, self) => self.get(k));\n      }\n      constructor(registry, value) {\n        super(registry, Types, value, jsonMap, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The available keys for this struct\n   */\n  get defKeys() {\n    return this.__internal__Types[1];\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    for (const v of this.values()) {\n      if (!v.isEmpty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let total = 0;\n    for (const v of this.values()) {\n      total += v.encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Returns the Type description of the structure\n   */\n  get Type() {\n    const result = {};\n    const [Types, keys] = this.__internal__Types;\n    for (let i = 0, count = keys.length; i < count; i++) {\n      result[keys[i]] = new Types[i](this.registry).toRawType();\n    }\n    return result;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a specific names entry in the structure\n   * @param key The name of the entry to retrieve\n   */\n  get(key) {\n    return super.get(key);\n  }\n  /**\n   * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\n   */\n  getAtIndex(index) {\n    return this.toArray()[index];\n  }\n  /**\n   * @description Returns the a types value by name\n   */\n  getT(key) {\n    return super.get(key);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect(isBare) {\n    const inner = [];\n    for (const [k, v] of this.entries()) {\n      inner.push({\n        ...v.inspect(!isBare || isBoolean(isBare) ? isBare : isBare[k]),\n        name: stringCamelCase(k)\n      });\n    }\n    return {\n      inner\n    };\n  }\n  /**\n   * @description Converts the Object to an standard JavaScript Array\n   */\n  toArray() {\n    return [...this.values()];\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      json[k] = v.toHuman(isExtended, disableAscii);\n    }\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      // Here we pull out the entry against the JSON mapping (if supplied)\n      // since this representation goes over RPC and needs to be correct\n      json[this.__internal__jsonMap.get(k) || k] = v.toJSON();\n    }\n    return json;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      json[k] = v.toPrimitive(disableAscii);\n    }\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return stringify(typesToMap(this.registry, this.__internal__Types));\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = [];\n    for (const [k, v] of this.entries()) {\n      encoded.push(v.toU8a(!isBare || isBoolean(isBare) ? isBare : isBare[k]));\n    }\n    return u8aConcatStrict(encoded);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}