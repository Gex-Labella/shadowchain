{"ast":null,"code":"import { catchError, EMPTY, tap } from 'rxjs';\nimport { isFunction, nextTick } from '@polkadot/util';\nexport function promiseTracker(resolve, reject) {\n  let isCompleted = false;\n  return {\n    reject: error => {\n      if (!isCompleted) {\n        isCompleted = true;\n        reject(error);\n      }\n      return EMPTY;\n    },\n    resolve: value => {\n      if (!isCompleted) {\n        isCompleted = true;\n        resolve(value);\n      }\n    }\n  };\n}\nfunction extractArgs(args, needsCallback) {\n  const actualArgs = args.slice();\n  // If the last arg is a function, we pop it, put it into callback.\n  // actualArgs will then hold the actual arguments to be passed to `method`\n  const callback = args.length && isFunction(args[args.length - 1]) ? actualArgs.pop() : undefined;\n  // When we need a subscription, ensure that a valid callback is actually passed\n  if (needsCallback && !isFunction(callback)) {\n    throw new Error('Expected a callback to be passed with subscriptions');\n  }\n  return [actualArgs, callback];\n}\nfunction decorateCall(method, args) {\n  return new Promise((resolve, reject) => {\n    // single result tracker - either reject with Error or resolve with Codec result\n    const tracker = promiseTracker(resolve, reject);\n    // encoding errors reject immediately, any result unsubscribes and resolves\n    const subscription = method(...args).pipe(catchError(error => tracker.reject(error))).subscribe(result => {\n      tracker.resolve(result);\n      nextTick(() => subscription.unsubscribe());\n    });\n  });\n}\nfunction decorateSubscribe(method, args, resultCb) {\n  return new Promise((resolve, reject) => {\n    // either reject with error or resolve with unsubscribe callback\n    const tracker = promiseTracker(resolve, reject);\n    // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback\n    const subscription = method(...args).pipe(catchError(error => tracker.reject(error)), tap(() => tracker.resolve(() => subscription.unsubscribe()))).subscribe(result => {\n      // queue result (back of queue to clear current)\n      nextTick(() => resultCb(result));\n    });\n  });\n}\n/**\n * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent\n */\nexport function toPromiseMethod(method, options) {\n  const needsCallback = !!(options?.methodName && options.methodName.includes('subscribe'));\n  return function (...args) {\n    const [actualArgs, resultCb] = extractArgs(args, needsCallback);\n    return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall(options?.overrideNoSub || method, actualArgs);\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}