{"ast":null,"code":"import { map, of } from 'rxjs';\nimport { objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nimport { didUpdateToBool } from './util.js';\nfunction parseActive(id, active) {\n  const found = active.find(([paraId]) => paraId === id);\n  if (found && found[1].isSome) {\n    const [collatorId, retriable] = found[1].unwrap();\n    return objectSpread({\n      collatorId\n    }, retriable.isWithRetries ? {\n      isRetriable: true,\n      retries: retriable.asWithRetries.toNumber()\n    } : {\n      isRetriable: false,\n      retries: 0\n    });\n  }\n  return null;\n}\nfunction parseCollators(id, collatorQueue) {\n  return collatorQueue.map(queue => {\n    const found = queue.find(([paraId]) => paraId === id);\n    return found ? found[1] : null;\n  });\n}\nfunction parse(id, [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue]) {\n  if (info.isNone) {\n    return null;\n  }\n  return {\n    active: parseActive(id, active),\n    didUpdate: didUpdateToBool(didUpdate, id),\n    heads,\n    id,\n    info: objectSpread({\n      id\n    }, info.unwrap()),\n    pendingSwapId: pendingSwap.unwrapOr(null),\n    relayDispatchQueue,\n    retryCollators: parseCollators(id, retryQueue),\n    selectedCollators: parseCollators(id, selectedThreads)\n  };\n}\nexport function info(instanceId, api) {\n  return memo(instanceId, id => api.query['registrar'] && api.query['parachains'] ? api.queryMulti([api.query['registrar']['active'], api.query['registrar']['retryQueue'], api.query['registrar']['selectedThreads'], api.query['parachains']['didUpdate'], [api.query['registrar']['paras'], id], [api.query['registrar']['pendingSwap'], id], [api.query['parachains']['heads'], id], [api.query['parachains']['relayDispatchQueue'], id]]).pipe(map(result => parse(api.registry.createType('ParaId', id), result))) : of(null));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}