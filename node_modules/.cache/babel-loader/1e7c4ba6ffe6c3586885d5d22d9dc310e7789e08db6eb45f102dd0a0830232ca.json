{"ast":null,"code":"const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\nalias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false), alias('VecDeque<', 'Vec<', false),\n// <T::Balance as HasCompact>\ncleanupCompact(),\n// Change BoundedVec<Type, Size> to Vec<Type>\nremoveExtensions('Bounded', true),\n// Change WeakVec<Type> to Vec<Type>\nremoveExtensions('Weak', false),\n// Remove all the trait prefixes\nremoveTraits(),\n// remove PairOf<T> -> (T, T)\nremovePairOf(),\n// remove boxing, `Box<Proposal>` -> `Proposal`\nremoveWrap('Box<'),\n// remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\nremoveGenerics(),\n// alias String -> Text (compat with jsonrpc methods)\nalias('String', 'Text'),\n// alias Vec<u8> -> Bytes\nalias('Vec<u8>', 'Bytes'), alias('&\\\\[u8\\\\]', 'Bytes'), alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n// alias RawAddress -> Address\nalias('RawAddress', 'Address'),\n// lookups, mapped to Address/AccountId as appropriate in runtime\nalias('Lookup::Source', 'LookupSource'), alias('Lookup::Target', 'LookupTarget'),\n// HACK duplication between contracts & primitives, however contracts prefixed with exec\nalias('exec::StorageKey', 'ContractStorageKey'),\n// flattens tuples with one value, `(AccountId)` -> `AccountId`\nflattenSingleTuple(),\n// converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\nremoveColons(),\n// remove all trailing spaces - this should always be the last\ntrim()];\nexport function trim() {\n  return value => value.trim();\n}\nexport function findClosing(value, start) {\n  let depth = 0;\n  for (let i = start, count = value.length; i < count; i++) {\n    if (value[i] === '>') {\n      if (!depth) {\n        return i;\n      }\n      depth--;\n    } else if (value[i] === '<') {\n      depth++;\n    }\n  }\n  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\nexport function alias(src, dest, withChecks = true) {\n  const from = new RegExp(`(^${src}|${BOX_PRECEDING.map(box => `\\\\${box}${src}`).join('|')})`, 'g');\n  const to = src => {\n    from.lastIndex = 0;\n    return withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest;\n  };\n  return value => value.replace(from, to);\n}\nexport function cleanupCompact() {\n  return value => {\n    if (value.includes(' as HasCompact')) {\n      for (let i = 0, count = value.length; i < count; i++) {\n        if (value[i] === '<') {\n          const end = findClosing(value, i + 1) - 14;\n          if (value.substring(end, end + 14) === ' as HasCompact') {\n            value = `Compact<${value.substring(i + 1, end)}>`;\n          }\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function flattenSingleTuple() {\n  const from1 = /,\\)/g;\n  const from2 = /\\(([^,]+)\\)/;\n  return value => {\n    from1.lastIndex = 0;\n    return value\n    // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n    .replace(from1, ')')\n    // change (u32) -> u32\n    .replace(from2, '$1');\n  };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n  let index = -1;\n  while (true) {\n    index = value.indexOf(matcher, index + 1);\n    if (index === -1) {\n      return value;\n    }\n    const start = index + matcher.length;\n    const end = findClosing(value, start);\n    value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;\n  }\n}\nexport function removeExtensions(type, isSized) {\n  return value => {\n    for (let i = 0, count = BOUNDED.length; i < count; i++) {\n      const tag = BOUNDED[i];\n      value = replaceTagWith(value, `${type}${tag}<`, v => {\n        const parts = v.split(',').map(s => s.trim()).filter(s => s);\n        if (isSized) {\n          parts.pop();\n        }\n        return `${tag}<${parts.join(',')}>`;\n      });\n    }\n    return value;\n  };\n}\nexport function removeColons() {\n  return value => {\n    let index = 0;\n    while (index !== -1) {\n      index = value.indexOf('::');\n      if (index === 0) {\n        value = value.substring(2);\n      } else if (index !== -1) {\n        let start = index;\n        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n          start--;\n        }\n        value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;\n      }\n    }\n    return value;\n  };\n}\nexport function removeGenerics() {\n  return value => {\n    for (let i = 0, count = value.length; i < count; i++) {\n      if (value[i] === '<') {\n        // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n        const box = ALLOWED_BOXES.find(box => {\n          const start = i - box.length;\n          return start >= 0 && value.substring(start, i) === box && (\n          // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n          start === 0 || BOX_PRECEDING.includes(value[start - 1]));\n        });\n        // we have not found anything, unwrap generic innards\n        if (!box) {\n          const end = findClosing(value, i + 1);\n          value = `${value.substring(0, i)}${value.substring(end + 1)}`;\n        }\n      }\n    }\n    return value;\n  };\n}\nexport function removePairOf() {\n  const replacer = v => `(${v},${v})`;\n  return value => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n  const from1 = /\\s/g;\n  const from2 = /(T|Self)::/g;\n  const from3 = /<(T|Self)asTrait>::/g;\n  const from4 = /<Tas[a-z]+::Trait>::/g;\n  const from5 = /<LookupasStaticLookup>/g;\n  const from6 = /::Type/g;\n  return value => {\n    from1.lastIndex = 0;\n    from2.lastIndex = 0;\n    from3.lastIndex = 0;\n    from4.lastIndex = 0;\n    from5.lastIndex = 0;\n    from6.lastIndex = 0;\n    return value\n    // remove all whitespaces\n    .replace(from1, '')\n    // anything `T::<type>` to end up as `<type>`\n    .replace(from2, '')\n    // replace `<T as Trait>::` (whitespaces were removed above)\n    .replace(from3, '')\n    // replace `<T as something::Trait>::` (whitespaces were removed above)\n    .replace(from4, '')\n    // replace <Lookup as StaticLookup>\n    .replace(from5, 'Lookup')\n    // replace `<...>::Type`\n    .replace(from6, '');\n  };\n}\nexport function removeWrap(check) {\n  const replacer = v => v;\n  return value => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n  const startValue = value.toString();\n  const memoized = sanitizeMap.get(startValue);\n  if (memoized) {\n    return memoized;\n  }\n  let result = startValue;\n  for (let i = 0, count = mappings.length; i < count; i++) {\n    result = mappings[i](result);\n  }\n  sanitizeMap.set(startValue, result);\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}