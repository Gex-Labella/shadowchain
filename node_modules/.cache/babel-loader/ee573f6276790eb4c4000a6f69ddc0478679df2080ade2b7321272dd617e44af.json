{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN_BILLION, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nfunction extractCompatRewards(claimedRewardsEras, ledger) {\n  const l = ledger ? (ledger.legacyClaimedRewards || ledger.claimedRewards).toArray() : [];\n  return claimedRewardsEras.toArray().concat(l);\n}\nfunction parseRewards(api, stashId, [erasPoints, erasPrefs, erasRewards], exposures) {\n  return exposures.map(({\n    era,\n    isEmpty,\n    isValidator,\n    nominating,\n    validators: eraValidators\n  }) => {\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n      const valPoints = allValPoints[validatorId] || BN_ZERO;\n      const valComm = allValPrefs[validatorId]?.commission.unwrap() || BN_ZERO;\n      const expTotal = exposure.total ? exposure.total?.unwrap() : exposure.pageTotal ? exposure.pageTotal?.unwrap() : BN_ZERO;\n      let avail = BN_ZERO;\n      let value;\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        const valCut = valComm.mul(avail).div(BN_BILLION);\n        let staked;\n        if (validatorId === stakerId) {\n          if (exposure.own) {\n            staked = exposure.own.unwrap();\n          } else {\n            const expAccount = exposure.others.find(({\n              who\n            }) => who.eq(validatorId));\n            staked = expAccount ? expAccount.value.unwrap() : BN_ZERO;\n          }\n        } else {\n          const stakerExp = exposure.others.find(({\n            who\n          }) => who.eq(stakerId));\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\nfunction allUniqValidators(rewards) {\n  return rewards.reduce(([all, perStash], rewards) => {\n    const uniq = [];\n    perStash.push(uniq);\n    rewards.forEach(({\n      validators\n    }) => Object.keys(validators).forEach(validatorId => {\n      if (!uniq.includes(validatorId)) {\n        uniq.push(validatorId);\n        if (!all.includes(validatorId)) {\n          all.push(validatorId);\n        }\n      }\n    }));\n    return [all, perStash];\n  }, [[], []]);\n}\nfunction removeClaimed(validators, queryValidators, reward, claimedRewardsEras) {\n  const rm = [];\n  Object.keys(reward.validators).forEach(validatorId => {\n    const index = validators.indexOf(validatorId);\n    if (index !== -1) {\n      const valLedger = queryValidators[index].stakingLedger;\n      if (extractCompatRewards(claimedRewardsEras, valLedger).some(e => reward.era.eq(e))) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(validatorId => {\n    delete reward.validators[validatorId];\n  });\n}\nfunction filterRewards(eras, valInfo, {\n  claimedRewardsEras,\n  rewards,\n  stakingLedger\n}) {\n  const filter = eras.filter(e => !extractCompatRewards(claimedRewardsEras, stakingLedger).some(s => s.eq(e)));\n  const validators = valInfo.map(([v]) => v);\n  const queryValidators = valInfo.map(([, q]) => q);\n  return rewards.filter(({\n    isEmpty\n  }) => !isEmpty).filter(reward => {\n    if (!filter.some(e => reward.era.eq(e))) {\n      return false;\n    }\n    removeClaimed(validators, queryValidators, reward, claimedRewardsEras);\n    return true;\n  }).filter(({\n    validators\n  }) => Object.keys(validators).length !== 0).map(reward => objectSpread({}, reward, {\n    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])\n  }));\n}\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, (eras, withActive = false) => combineLatest([api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, (accountIds, eras, withActive = false) => {\n    // Ensures that when number or string types are passed in they are sanitized\n    // Ref: https://github.com/polkadot-js/api/issues/5910\n    const sanitizedEras = eras.map(e => typeof e === 'number' || typeof e === 'string' ? api.registry.createType('u32', e) : e);\n    return combineLatest([api.derive.staking.queryMulti(accountIds, {\n      withClaimedRewardsEras: true,\n      withLedger: true\n    }), api.derive.staking._stakerExposures(accountIds, sanitizedEras, withActive), api.derive.staking._stakerRewardsEras(sanitizedEras, withActive)]).pipe(switchMap(([queries, exposures, erasResult]) => {\n      const allRewards = queries.map(({\n        claimedRewardsEras,\n        stakingLedger,\n        stashId\n      }, index) => !stashId || !stakingLedger && !claimedRewardsEras ? [] : parseRewards(api, stashId, erasResult, exposures[index]));\n      if (withActive) {\n        return of(allRewards);\n      }\n      const [allValidators, stashValidators] = allUniqValidators(allRewards);\n      return api.derive.staking.queryMulti(allValidators, {\n        withClaimedRewardsEras: true,\n        withLedger: true\n      }).pipe(map(queriedVals => queries.map(({\n        claimedRewardsEras,\n        stakingLedger\n      }, index) => filterRewards(eras, stashValidators[index].map(validatorId => [validatorId, queriedVals.find(q => q.accountId.eq(validatorId))]).filter(v => !!v[1]), {\n        claimedRewardsEras,\n        rewards: allRewards[index],\n        stakingLedger\n      }))));\n    }));\n  });\n}\nexport const stakerRewards = /*#__PURE__*/firstMemo((api, accountId, withActive) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking._stakerRewards([accountId], eras, withActive))));\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? api.derive.staking._stakerRewards(accountIds, eras, false) : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}