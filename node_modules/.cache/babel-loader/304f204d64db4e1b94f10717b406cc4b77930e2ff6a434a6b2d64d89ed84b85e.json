{"ast":null,"code":"import { combineLatest, map, switchMap } from 'rxjs';\nimport { BN, BN_ZERO, objectSpread } from '@polkadot/util';\nimport { firstMemo, memo } from '../util/index.js';\nconst QUERY_OPTS = {\n  withDestination: true,\n  withLedger: true,\n  withNominations: true,\n  withPrefs: true\n};\nfunction groupByEra(list) {\n  return list.reduce((map, {\n    era,\n    value\n  }) => {\n    const key = era.toString();\n    map[key] = (map[key] || BN_ZERO).add(value.unwrap());\n    return map;\n  }, {});\n}\nfunction calculateUnlocking(api, stakingLedger, sessionInfo) {\n  const results = Object.entries(groupByEra((stakingLedger?.unlocking || []).filter(({\n    era\n  }) => era.unwrap().gt(sessionInfo.activeEra)))).map(([eraString, value]) => ({\n    remainingEras: new BN(eraString).isub(sessionInfo.activeEra),\n    value: api.registry.createType('Balance', value)\n  }));\n  return results.length ? results : undefined;\n}\nfunction redeemableSum(api, stakingLedger, sessionInfo) {\n  return api.registry.createType('Balance', (stakingLedger?.unlocking || []).reduce((total, {\n    era,\n    value\n  }) => {\n    // aligns with https://github.com/paritytech/substrate/blob/fdfdc73f9e64dc47934b72eb9af3e1989e4ba699/frame/staking/src/pallet/mod.rs#L973-L975\n    // (ensure currentEra >= era passed, as per https://github.com/paritytech/substrate/blob/fdfdc73f9e64dc47934b72eb9af3e1989e4ba699/frame/staking/src/lib.rs#L477-L494)\n    // NOTE: Previously we used activeEra >= era, which is incorrect for the last session\n    return era.unwrap().gt(sessionInfo.currentEra) ? total : total.iadd(value.unwrap());\n  }, new BN(0)));\n}\nfunction parseResult(api, sessionInfo, keys, query) {\n  return objectSpread({}, keys, query, {\n    redeemable: redeemableSum(api, query.stakingLedger, sessionInfo),\n    unlocking: calculateUnlocking(api, query.stakingLedger, sessionInfo)\n  });\n}\n/**\n * @description From a list of stashes, fill in all the relevant staking details\n */\nexport function accounts(instanceId, api) {\n  return memo(instanceId, (accountIds, opts = QUERY_OPTS) => api.derive.session.info().pipe(switchMap(sessionInfo => combineLatest([api.derive.staking.keysMulti(accountIds), api.derive.staking.queryMulti(accountIds, opts)]).pipe(map(([keys, queries]) => queries.map((q, index) => parseResult(api, sessionInfo, keys[index], q)))))));\n}\n/**\n * @description From a stash, retrieve the controllerId and fill in all the relevant staking details\n */\nexport const account = /*#__PURE__*/firstMemo((api, accountId, opts) => api.derive.staking.accounts([accountId], opts));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}