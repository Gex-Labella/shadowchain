{"ast":null,"code":"import { Option, Struct } from '@polkadot/types-codec';\nimport { objectProperty, objectSpread, u8aToHex } from '@polkadot/util';\nconst knownTypes = {\n  address: 'Address',\n  assetId: 'Option<TAssetConversion>',\n  blockHash: 'Hash',\n  blockNumber: 'BlockNumber',\n  era: 'ExtrinsicEra',\n  genesisHash: 'Hash',\n  metadataHash: 'Option<[u8;32]>',\n  method: 'Call',\n  mode: 'u8',\n  nonce: 'Compact<Index>',\n  runtimeVersion: 'RuntimeVersion',\n  signedExtensions: 'Vec<Text>',\n  tip: 'Compact<Balance>',\n  version: 'u8'\n};\n/**\n * @name GenericSignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\nexport class GenericSignerPayload extends Struct {\n  __internal__extraTypes;\n  constructor(registry, value) {\n    const extensionTypes = objectSpread({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());\n    super(registry, objectSpread({}, extensionTypes, knownTypes, {\n      withSignedTransaction: 'bool'\n    }), value);\n    this.__internal__extraTypes = {};\n    const getter = key => this.get(key);\n    // add all extras that are not in the base types\n    for (const [key, type] of Object.entries(extensionTypes)) {\n      if (!knownTypes[key]) {\n        this.__internal__extraTypes[key] = type;\n      }\n      objectProperty(this, key, getter);\n    }\n  }\n  get address() {\n    return this.getT('address');\n  }\n  get blockHash() {\n    return this.getT('blockHash');\n  }\n  get blockNumber() {\n    return this.getT('blockNumber');\n  }\n  get era() {\n    return this.getT('era');\n  }\n  get genesisHash() {\n    return this.getT('genesisHash');\n  }\n  get method() {\n    return this.getT('method');\n  }\n  get nonce() {\n    return this.getT('nonce');\n  }\n  get runtimeVersion() {\n    return this.getT('runtimeVersion');\n  }\n  get signedExtensions() {\n    return this.getT('signedExtensions');\n  }\n  get tip() {\n    return this.getT('tip');\n  }\n  get assetId() {\n    return this.getT('assetId');\n  }\n  get version() {\n    return this.getT('version');\n  }\n  get mode() {\n    return this.getT('mode');\n  }\n  get metadataHash() {\n    return this.getT('metadataHash');\n  }\n  get withSignedTransaction() {\n    const val = this.getT('withSignedTransaction');\n    return val.isTrue;\n  }\n  /**\n   * @description Creates an representation of the structure as an ISignerPayload JSON\n   */\n  toPayload() {\n    const result = {};\n    const keys = Object.keys(this.__internal__extraTypes);\n    // add any explicit overrides we may have\n    for (let i = 0, count = keys.length; i < count; i++) {\n      const key = keys[i];\n      const value = this.getT(key);\n      // Don't include Option.isNone\n      if (!(value instanceof Option) || value.isSome) {\n        // NOTE In the spread below we convert (mostly) to Hex to align\n        // with the typings. In the case of \"unknown\" fields, we use the\n        // primitive toJSON conversion (which is serializable). Technically\n        // we can include isNone in here as well (\"null\" is allowed), however\n        // for empty fields we just skip it completely (historical compat)\n        result[key] = value.toJSON();\n      }\n    }\n    return objectSpread(result, {\n      // the known defaults as managed explicitly and has different\n      // formatting in cases, e.g. we mostly expose a hex format here\n      address: this.address.toString(),\n      assetId: this.assetId && this.assetId.isSome ? this.assetId.toHex() : null,\n      blockHash: this.blockHash.toHex(),\n      blockNumber: this.blockNumber.toHex(),\n      era: this.era.toHex(),\n      genesisHash: this.genesisHash.toHex(),\n      metadataHash: this.metadataHash.isSome ? this.metadataHash.toHex() : null,\n      method: this.method.toHex(),\n      mode: this.mode.toNumber(),\n      nonce: this.nonce.toHex(),\n      signedExtensions: this.signedExtensions.map(e => e.toString()),\n      specVersion: this.runtimeVersion.specVersion.toHex(),\n      tip: this.tip.toHex(),\n      transactionVersion: this.runtimeVersion.transactionVersion.toHex(),\n      version: this.version.toNumber(),\n      withSignedTransaction: this.withSignedTransaction\n    });\n  }\n  /**\n   * @description Creates a representation of the payload in raw Exrinsic form\n   */\n  toRaw() {\n    const payload = this.toPayload();\n    const data = u8aToHex(this.registry.createTypeUnsafe('ExtrinsicPayload', [payload, {\n      version: payload.version\n    }])\n    // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n    .toU8a({\n      method: true\n    }));\n    return {\n      address: payload.address,\n      data,\n      type: 'payload'\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}