{"ast":null,"code":"import { objectSpread } from '@polkadot/util';\n/** @internal */\nfunction createStorageHasher(registry, hasher) {\n  // Blake2_128_Concat has been added at index 2, so we increment all the\n  // indexes greater than 2\n  if (hasher.toNumber() >= 2) {\n    return registry.createTypeUnsafe('StorageHasherV10', [hasher.toNumber() + 1]);\n  }\n  return registry.createTypeUnsafe('StorageHasherV10', [hasher]);\n}\n/** @internal */\nfunction createStorageType(registry, entryType) {\n  if (entryType.isMap) {\n    return [objectSpread({}, entryType.asMap, {\n      hasher: createStorageHasher(registry, entryType.asMap.hasher)\n    }), 1];\n  }\n  if (entryType.isDoubleMap) {\n    return [objectSpread({}, entryType.asDoubleMap, {\n      hasher: createStorageHasher(registry, entryType.asDoubleMap.hasher),\n      key2Hasher: createStorageHasher(registry, entryType.asDoubleMap.key2Hasher)\n    }), 2];\n  }\n  return [entryType.asPlain, 0];\n}\n/** @internal */\nfunction convertModule(registry, mod) {\n  const storage = mod.storage.unwrapOr(null);\n  return registry.createTypeUnsafe('ModuleMetadataV10', [objectSpread({}, mod, {\n    storage: storage ? objectSpread({}, storage, {\n      items: storage.items.map(item => objectSpread({}, item, {\n        type: registry.createTypeUnsafe('StorageEntryTypeV10', createStorageType(registry, item.type))\n      }))\n    }) : null\n  })]);\n}\n/** @internal */\nexport function toV10(registry, {\n  modules\n}) {\n  return registry.createTypeUnsafe('MetadataV10', [{\n    modules: modules.map(mod => convertModule(registry, mod))\n  }]);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}