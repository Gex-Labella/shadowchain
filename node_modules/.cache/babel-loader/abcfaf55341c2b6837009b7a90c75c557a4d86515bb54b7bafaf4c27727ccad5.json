{"ast":null,"code":"import { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, {\n  method,\n  section\n}) {\n  return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n}\nexport class Decorate extends Events {\n  __internal__instanceId;\n  __internal__runtimeLog = {};\n  __internal__registry;\n  __internal__storageGetQ = [];\n  __internal__storageSubQ = [];\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n  __phantom = new BN(0);\n  _type;\n  _call = {};\n  _consts = {};\n  _derive;\n  _errors = {};\n  _events = {};\n  _extrinsics;\n  _extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;\n  _genesisHash;\n  _isConnected;\n  _isReady = false;\n  _query = {};\n  _queryMulti;\n  _rpc;\n  _rpcCore;\n  _runtimeMap = {};\n  _runtimeChain;\n  _runtimeMetadata;\n  _runtimeVersion;\n  _rx = {\n    call: {},\n    consts: {},\n    query: {},\n    tx: {}\n  };\n  _options;\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n  _decorateMethod;\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    super();\n    this.__internal__instanceId = `${++instanceCounter}`;\n    this.__internal__registry = options.source?.registry || options.registry || new TypeRegistry();\n    this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.call));\n    this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map(a => a.rx.query));\n    this._rx.registry = this.__internal__registry;\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type;\n    const provider = options.source ? options.source._rpcCore.provider.isClonable ? options.source._rpcCore.provider.clone() : options.source._rpcCore.provider : options.provider || new WsProvider();\n    // The RPC interface decorates the known interfaces on init\n    this._rpcCore = new RpcCore(this.__internal__instanceId, this.__internal__registry, {\n      isPedantic: this._options.isPedantic,\n      provider,\n      userRpc: this._options.rpc\n    });\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @description Return the current used registry\n   */\n  get registry() {\n    return this.__internal__registry;\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n  createType(type, ...params) {\n    return this.__internal__registry.createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n  registerTypes(types) {\n    types && this.__internal__registry.register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n  _emptyDecorated(registry, blockHash) {\n    return {\n      call: {},\n      consts: {},\n      errors: {},\n      events: {},\n      query: {},\n      registry,\n      rx: {\n        call: {},\n        query: {}\n      },\n      tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n    };\n  }\n  _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n    if (!decoratedApi) {\n      decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n    }\n    if (fromEmpty || !registry.decoratedMeta) {\n      registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n    }\n    const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n    const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n    const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n    const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n    augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n    augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n    augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n    augmentObject('query', storage, decoratedApi.query, fromEmpty);\n    augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n    augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n    augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n    decoratedApi.findCall = callIndex => findCall(registry.registry, callIndex);\n    decoratedApi.findError = errorIndex => findError(registry.registry, errorIndex);\n    decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);\n    decoratedApi.runtimeVersion = registry.runtimeVersion;\n    return {\n      createdAt: blockHash,\n      decoratedApi,\n      decoratedMeta: registry.decoratedMeta\n    };\n  }\n  _injectMetadata(registry, fromEmpty = false) {\n    // clear the decoration, we are redoing it here\n    if (fromEmpty || !registry.decoratedApi) {\n      registry.decoratedApi = this._emptyDecorated(registry.registry);\n    }\n    const {\n      decoratedApi,\n      decoratedMeta\n    } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n    this._call = decoratedApi.call;\n    this._consts = decoratedApi.consts;\n    this._errors = decoratedApi.errors;\n    this._events = decoratedApi.events;\n    this._query = decoratedApi.query;\n    this._rx.call = decoratedApi.rx.call;\n    this._rx.query = decoratedApi.rx.query;\n    const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n    const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = tx;\n      this._rx.tx = rxtx;\n    } else {\n      augmentObject('tx', tx, this._extrinsics, false);\n      augmentObject(null, rxtx, this._rx.tx, false);\n    }\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n    this.emit('decorated');\n  }\n  /**\n   * @deprecated\n   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n   */\n  injectMetadata(metadata, fromEmpty, registry) {\n    this._injectMetadata({\n      counter: 0,\n      metadata,\n      registry: registry || this.__internal__registry,\n      runtimeVersion: this.__internal__registry.createType('RuntimeVersionPartial')\n    }, fromEmpty);\n  }\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n    return output;\n  }\n  // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n  _filterRpc(methods, additional) {\n    // add any specific user-base RPCs\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional);\n      // re-decorate, only adding any new additional interfaces\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n    // extract the actual sections from the methods (this is useful when\n    // we try and create mappings to runtime names via a hash mapping)\n    const sectionMap = {};\n    for (let i = 0, count = methods.length; i < count; i++) {\n      const [section] = methods[i].split('_');\n      sectionMap[section] = true;\n    }\n    // convert the actual section names into an easy name lookup\n    const sections = Object.keys(sectionMap);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      const nameA = stringUpperFirst(sections[i]);\n      const nameB = `${nameA}Api`;\n      this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n      this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n    }\n    // finally we filter the actual methods to expose\n    this._filterRpcMethods(methods);\n  }\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = [];\n    const count = allKnown.length;\n    for (let i = 0; i < count; i++) {\n      const [, {\n        alias,\n        endpoint,\n        method,\n        pubsub,\n        section\n      }] = allKnown[i];\n      allKeys.push(`${section}_${method}`);\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n      if (alias) {\n        allKeys.push(...alias);\n      }\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n    }\n    const unknown = exposed.filter(k => !allKeys.includes(k) && !k.includes('_unstable_'));\n    if (unknown.length && !this._options.noInitWarn) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    }\n    // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n    for (let i = 0; i < count; i++) {\n      const [k, {\n        method,\n        section\n      }] = allKnown[i];\n      if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n        if (this._rpc[section]) {\n          delete this._rpc[section][method];\n          delete this._rx.rpc[section][method];\n        }\n      }\n    }\n  }\n  _rpcSubmitter(decorateMethod) {\n    const method = (method, ...params) => {\n      return from(this._rpcCore.provider.send(method, params));\n    };\n    return decorateMethod(method);\n  }\n  _decorateRpc(rpc, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {\n    const out = input;\n    const decorateFn = (section, method) => {\n      const source = rpc[section][method];\n      const fn = decorateMethod(source, {\n        methodName: method\n      });\n      fn.meta = source.meta;\n      fn.raw = decorateMethod(source.raw, {\n        methodName: method\n      });\n      return fn;\n    };\n    for (let s = 0, scount = rpc.sections.length; s < scount; s++) {\n      const section = rpc.sections[s];\n      if (!Object.prototype.hasOwnProperty.call(out, section)) {\n        const methods = Object.keys(rpc[section]);\n        const decorateInternal = method => decorateFn(section, method);\n        for (let m = 0, mcount = methods.length; m < mcount; m++) {\n          const method = methods[m];\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n              out[section] = {};\n            }\n            lazyMethod(out[section], method, decorateInternal);\n          }\n        }\n      }\n    }\n    return out;\n  }\n  // add all definition entries\n  _addRuntimeDef(result, additional) {\n    if (!additional) {\n      return;\n    }\n    const entries = Object.entries(additional);\n    for (let j = 0, ecount = entries.length; j < ecount; j++) {\n      const [key, defs] = entries[j];\n      if (result[key]) {\n        // we have this one already, step through for new versions or\n        // new methods and add those as applicable\n        for (let k = 0, dcount = defs.length; k < dcount; k++) {\n          const def = defs[k];\n          const prev = result[key].find(({\n            version\n          }) => def.version === version);\n          if (prev) {\n            // interleave the new methods with the old - last definition wins\n            objectSpread(prev.methods, def.methods);\n          } else {\n            // we don't have this specific version, add it\n            result[key].push(def);\n          }\n        }\n      } else {\n        // we don't have this runtime definition, add it as-is\n        result[key] = defs;\n      }\n    }\n  }\n  // extract all runtime definitions\n  _getRuntimeDefs(registry, specName, chain = '') {\n    const result = {};\n    const defValues = Object.values(typeDefinitions);\n    // options > chain/spec > built-in, apply in reverse order with\n    // methods overriding previous definitions (or interleave missing)\n    for (let i = 0, count = defValues.length; i < count; i++) {\n      this._addRuntimeDef(result, defValues[i].runtime);\n    }\n    this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n    this._addRuntimeDef(result, this._options.runtime);\n    return Object.entries(result);\n  }\n  // Helper for _getRuntimeDefsViaMetadata\n  _getMethods(registry, methods) {\n    const result = {};\n    methods.forEach(m => {\n      const {\n        docs,\n        inputs,\n        name,\n        output\n      } = m;\n      result[name.toString()] = {\n        description: docs.map(d => d.toString()).join(),\n        params: inputs.map(({\n          name,\n          type\n        }) => {\n          return {\n            name: name.toString(),\n            type: registry.lookup.getName(type) || registry.lookup.getTypeDef(type).type\n          };\n        }),\n        type: registry.lookup.getName(output) || registry.lookup.getTypeDef(output).type\n      };\n    });\n    return result;\n  }\n  // Maintains the same structure as `_getRuntimeDefs` in order to make conversion easier.\n  _getRuntimeDefsViaMetadata(registry) {\n    const result = {};\n    const {\n      apis\n    } = registry.metadata;\n    for (let i = 0, count = apis.length; i < count; i++) {\n      const {\n        methods,\n        name\n      } = apis[i];\n      result[name.toString()] = [{\n        methods: this._getMethods(registry, methods),\n        // We set the version to 0 here since it will not be relevant when we are grabbing the runtime apis\n        // from the Metadata.\n        version: 0\n      }];\n    }\n    return Object.entries(result);\n  }\n  // When the calls are available in the metadata, it will generate them based off of the metadata.\n  // When they are not available it will use the hardcoded calls generated in the static types.\n  _decorateCalls({\n    registry,\n    runtimeVersion: {\n      apis,\n      specName,\n      specVersion\n    }\n  }, decorateMethod, blockHash) {\n    const result = {};\n    const named = {};\n    const hashes = {};\n    const isApiInMetadata = registry.metadata.apis.length > 0;\n    const sections = isApiInMetadata ? this._getRuntimeDefsViaMetadata(registry) : this._getRuntimeDefs(registry, specName, this._runtimeChain);\n    const older = [];\n    const implName = `${specName.toString()}/${specVersion.toString()}`;\n    const hasLogged = this.__internal__runtimeLog[implName] || false;\n    this.__internal__runtimeLog[implName] = true;\n    if (isApiInMetadata) {\n      for (let i = 0, scount = sections.length; i < scount; i++) {\n        const [_section, secs] = sections[i];\n        const sec = secs[0];\n        const sectionHash = blake2AsHex(_section, 64);\n        const section = stringCamelCase(_section);\n        const methods = Object.entries(sec.methods);\n        if (!named[section]) {\n          named[section] = {};\n        }\n        for (let m = 0, mcount = methods.length; m < mcount; m++) {\n          const [_method, def] = methods[m];\n          const method = stringCamelCase(_method);\n          named[section][method] = objectSpread({\n            method,\n            name: `${_section}_${_method}`,\n            section,\n            sectionHash\n          }, def);\n        }\n      }\n    } else {\n      for (let i = 0, scount = sections.length; i < scount; i++) {\n        const [_section, secs] = sections[i];\n        const sectionHash = blake2AsHex(_section, 64);\n        const rtApi = apis.find(([a]) => a.eq(sectionHash));\n        hashes[sectionHash] = true;\n        if (rtApi) {\n          const all = secs.map(({\n            version\n          }) => version).sort();\n          const sec = secs.find(({\n            version\n          }) => rtApi[1].eq(version));\n          if (sec) {\n            const section = stringCamelCase(_section);\n            const methods = Object.entries(sec.methods);\n            if (methods.length) {\n              if (!named[section]) {\n                named[section] = {};\n              }\n              for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                const [_method, def] = methods[m];\n                const method = stringCamelCase(_method);\n                named[section][method] = objectSpread({\n                  method,\n                  name: `${_section}_${_method}`,\n                  section,\n                  sectionHash\n                }, def);\n              }\n            }\n          } else {\n            older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);\n          }\n        }\n      }\n      // find the runtimes that we don't have hashes for\n      const notFound = apis.map(([a, v]) => [a.toHex(), v.toString()]).filter(([a]) => !hashes[a]).map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);\n      if (!this._options.noInitWarn && !hasLogged) {\n        if (older.length) {\n          l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);\n        }\n        if (notFound.length) {\n          l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);\n        }\n      }\n    }\n    const stateCall = blockHash ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash) : (name, bytes) => this._rpcCore.state.call(name, bytes);\n    const lazySection = section => lazyMethods({}, Object.keys(named[section]), method => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n    const modules = Object.keys(named);\n    for (let i = 0, count = modules.length; i < count; i++) {\n      lazyMethod(result, modules[i], lazySection);\n    }\n    return result;\n  }\n  _decorateCall(registry, def, stateCall, decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const decorated = decorateMethod((...args) => {\n      if (args.length !== def.params.length) {\n        throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);\n      }\n      const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n      return stateCall(def.name, bytes).pipe(map(r => registry.createTypeUnsafe(def.type, [r])));\n    });\n    decorated.meta = def;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorated;\n  }\n  // only be called if supportMulti is true\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(keys => keys.length ? (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys.map(args => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])) : of([]));\n  }\n  _decorateMultiAt(atApi, decorateMethod, blockHash) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => calls.length ? this._rpcCore.state.queryStorageAt(calls.map(args => {\n      if (Array.isArray(args)) {\n        const {\n          creator\n        } = getAtQueryFn(atApi, args[0].creator);\n        return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];\n      }\n      return [getAtQueryFn(atApi, args.creator).creator];\n    }), blockHash) : of([]));\n  }\n  _decorateExtrinsics({\n    tx\n  }, decorateMethod) {\n    const result = createSubmittable(this._type, this._rx, decorateMethod);\n    const lazySection = section => lazyMethods({}, Object.keys(tx[section]), method => method.startsWith('$') ? tx[section][method] : this._decorateExtrinsicEntry(tx[section][method], result));\n    const sections = Object.keys(tx);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = (...params) => creator(method(...params));\n    // pass through the `.is`\n    decorated.is = other => method.is(other);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this._decorateFunctionMeta(method, decorated);\n  }\n  _decorateStorage({\n    query,\n    registry\n  }, decorateMethod, blockHash) {\n    const result = {};\n    const lazySection = section => lazyMethods({}, Object.keys(query[section]), method => blockHash ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash) : this._decorateStorageEntry(query[section][method], decorateMethod));\n    const sections = Object.keys(query);\n    for (let i = 0, count = sections.length; i < count; i++) {\n      lazyMethod(result, sections[i], lazySection);\n    }\n    return result;\n  }\n  _decorateStorageEntry(creator, decorateMethod) {\n    const getArgs = (args, registry) => extractStorageArgs(registry || this.__internal__registry, creator, args);\n    const getQueryAt = blockHash => from(this.at(blockHash)).pipe(map(api => getAtQueryFn(api, creator)));\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n    decorated.creator = creator;\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => q(...args))));\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n    decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n    // eslint-disable-next-line deprecation/deprecation\n    decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, null, args)));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.entriesAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapEntries(q.creator, blockHash, args)))));\n      decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n      decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, null, args)));\n      // eslint-disable-next-line deprecation/deprecation\n      decorated.keysAt = decorateMethod(memo(this.__internal__instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapKeys(q.creator, blockHash, args)))));\n      decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapKeysPaged(creator, undefined, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]])) : this._retrieveMulti(args.map(a => [creator, a])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n    const getArgs = args => extractStorageArgs(registry, creator, args);\n    // Disable this where it occurs for each field we are decorating\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n    decorated.creator = creator;\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n    decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));\n    // .keys() & .entries() only available on map types\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n      decorated.entriesPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n      decorated.keys = decorateMethod(memo(this.__internal__instanceId, (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n      decorated.keysPaged = decorateMethod(memo(this.__internal__instanceId, opts => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n    }\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]]), blockHash) : this._retrieveMulti(args.map(a => [creator, a]), blockHash));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n  _queueStorage(call, queue) {\n    const query = queue === this.__internal__storageSubQ ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    let queueIdx = queue.length - 1;\n    let valueIdx = 0;\n    let valueObs;\n    // if we don't have queue entries yet,\n    // or the current queue has fired (see from below),\n    // or the current queue has the max entries,\n    // then we create a new queue\n    if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n      queueIdx++;\n      valueObs = from(\n      // we delay the execution until the next tick, this allows\n      // any queries made in this timeframe to be added to the same\n      // queue for a single query\n      new Promise(resolve => {\n        nextTick(() => {\n          // get all the calls in this instance, resolve with it\n          // and then clear the queue so we don't add more\n          // (anything after this will be added to a new queue)\n          const calls = queue[queueIdx][1];\n          delete queue[queueIdx];\n          resolve(calls);\n        });\n      })).pipe(switchMap(calls => query(calls)));\n      queue.push([valueObs, [call]]);\n    } else {\n      valueObs = queue[queueIdx][0];\n      valueIdx = queue[queueIdx][1].length;\n      queue[queueIdx][1].push(call);\n    }\n    return valueObs.pipe(\n    // return the single value at this index\n    map(values => values[valueIdx]));\n  }\n  // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n  _decorateStorageCall(creator, decorateMethod) {\n    const memoed = memo(this.__internal__instanceId, (...args) => {\n      const call = extractStorageArgs(this.__internal__registry, creator, args);\n      if (!this.hasSubscriptions) {\n        return this._rpcCore.state.getStorage(call);\n      }\n      return this._queueStorage(call, this.__internal__storageSubQ);\n    });\n    return decorateMethod(memoed, {\n      methodName: creator.method,\n      overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(this.__internal__registry, creator, args), this.__internal__storageGetQ)\n    });\n  }\n  // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n  _retrieveMulti(keys, blockHash) {\n    if (!keys.length) {\n      return of([]);\n    }\n    const query = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    if (keys.length <= PAGE_SIZE_V) {\n      return blockHash ? query(keys, blockHash) : query(keys);\n    }\n    return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(k => blockHash ? query(k, blockHash) : query(k))).pipe(map(arrayFlatten));\n  }\n  _retrieveMapKeys({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, args) {\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const headKey = iterKey(...args).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const query = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n    const setMeta = key => key.setMeta(meta, section, method);\n    return startSubject.pipe(switchMap(query), map(keys => keys.map(setMeta)), tap(keys => nextTick(() => {\n      keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();\n    })), toArray(),\n    // toArray since we want to startSubject to be completed\n    map(arrayFlatten));\n  }\n  _retrieveMapKeysPaged({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, opts) {\n    if (!iterKey || !meta.type.isMap) {\n      throw new Error('keys can only be retrieved on maps');\n    }\n    const setMeta = key => key.setMeta(meta, section, method);\n    const query = at ? headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : headKey => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n    return query(iterKey(...opts.args).toHex()).pipe(map(keys => keys.map(setMeta)));\n  }\n  _retrieveMapEntries(entry, at, args) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeys(entry, at, args).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _retrieveMapEntriesPaged(entry, at, opts) {\n    const query = at ? keys => this._rpcCore.state.queryStorageAt(keys, at) : keys => this._rpcCore.state.queryStorageAt(keys);\n    return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap(keys => keys.length ? query(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n  _decorateDeriveRx(decorateMethod) {\n    const specName = this._runtimeVersion?.specName.toString();\n    // Pull in derive from api-derive\n    const available = getAvailableDerives(this.__internal__instanceId, this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));\n    return decorateDeriveSections(decorateMethod, available);\n  }\n  _decorateDerive(decorateMethod) {\n    return decorateDeriveSections(decorateMethod, this._rx.derive);\n  }\n  /**\n   * Put the `this.onCall` function of ApiRx here, because it is needed by\n   * `api._rx`.\n   */\n  _rxDecorateMethod = method => {\n    return method;\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}