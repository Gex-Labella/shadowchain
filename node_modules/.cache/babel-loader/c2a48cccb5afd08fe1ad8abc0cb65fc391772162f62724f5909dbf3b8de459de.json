{"ast":null,"code":"import { BN } from '../bn/bn.js';\n/**\n * @name u8aToBn\n * @summary Creates a BN from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual BN. `null` or `undefined` values returns an `0x0` value.\n * @param value The value to convert\n * @param options Options to pass while converting\n * @param options.isLe Convert using Little Endian (default)\n * @param options.isNegative Convert using two's complement\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToBn } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\nexport function u8aToBn(value, {\n  isLe = true,\n  isNegative = false\n} = {}) {\n  // slice + reverse is expensive, however SCALE is LE by default so this is the path\n  // we are most interested in (the BE is added for the sake of being comprehensive)\n  if (!isLe) {\n    value = value.slice().reverse();\n  }\n  const count = value.length;\n  // shortcut for <= u48 values - in this case the manual conversion\n  // here seems to be more efficient than passing the full array\n  if (isNegative && count && value[count - 1] & 0x80) {\n    // Most common case i{8, 16, 32} default LE SCALE-encoded\n    // For <= 32, we also optimize the xor to a single op\n    switch (count) {\n      case 0:\n        return new BN(0);\n      case 1:\n        return new BN((value[0] ^ 0x0000_00ff) * -1 - 1);\n      case 2:\n        return new BN((value[0] + (value[1] << 8) ^ 0x0000_ffff) * -1 - 1);\n      case 3:\n        return new BN((value[0] + (value[1] << 8) + (value[2] << 16) ^ 0x00ff_ffff) * -1 - 1);\n      case 4:\n        // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n        // 32-bit, in the case where the top-most bit is set this yields a negative value\n        return new BN((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00 ^ 0xffff_ffff) * -1 - 1);\n      case 5:\n        return new BN(((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00 ^ 0xffff_ffff) + (value[4] ^ 0xff) * 0x1_00_00_00_00) * -1 - 1);\n      case 6:\n        return new BN(((value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00 ^ 0xffff_ffff) + (value[4] + (value[5] << 8) ^ 0x0000_ffff) * 0x1_00_00_00_00) * -1 - 1);\n      default:\n        return new BN(value, 'le').fromTwos(count * 8);\n    }\n  }\n  // Most common case - u{8, 16, 32} default LE SCALE-encoded\n  //\n  // There are some slight benefits in unrolling this specific loop,\n  // however it comes with diminishing returns since here the actual\n  // `new BN` does seem to take up the bulk of the time\n  switch (count) {\n    case 0:\n      return new BN(0);\n    case 1:\n      return new BN(value[0]);\n    case 2:\n      return new BN(value[0] + (value[1] << 8));\n    case 3:\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16));\n    case 4:\n      // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to\n      // 32-bit, in the case where the top-most bit is set this yields a negative value\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + value[3] * 0x1_00_00_00);\n    case 5:\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8)) * 0x1_00_00_00);\n    case 6:\n      return new BN(value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] + (value[4] << 8) + (value[5] << 16)) * 0x1_00_00_00);\n    default:\n      return new BN(value, 'le');\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}