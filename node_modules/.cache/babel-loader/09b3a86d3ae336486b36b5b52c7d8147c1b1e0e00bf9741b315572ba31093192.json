{"ast":null,"code":"import { identity, isHex, isNumber, isObject, isString, isU8a, objectProperties, stringCamelCase, stringify, stringPascalCase, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { mapToTypeMap, typesToMap } from '../utils/index.js';\nimport { Null } from './Null.js';\nfunction isRustEnum(def) {\n  const defValues = Object.values(def);\n  if (defValues.some(v => isNumber(v))) {\n    if (!defValues.every(v => isNumber(v) && v >= 0 && v <= 255)) {\n      throw new Error('Invalid number-indexed enum definition');\n    }\n    return false;\n  }\n  return true;\n}\nfunction extractDef(registry, _def) {\n  const def = {};\n  let isBasic;\n  let isIndexed;\n  if (Array.isArray(_def)) {\n    for (let i = 0, count = _def.length; i < count; i++) {\n      def[_def[i]] = {\n        Type: Null,\n        index: i\n      };\n    }\n    isBasic = true;\n    isIndexed = false;\n  } else if (isRustEnum(_def)) {\n    const [Types, keys] = mapToTypeMap(registry, _def);\n    for (let i = 0, count = keys.length; i < count; i++) {\n      def[keys[i]] = {\n        Type: Types[i],\n        index: i\n      };\n    }\n    isBasic = !Object.values(def).some(({\n      Type\n    }) => Type !== Null);\n    isIndexed = false;\n  } else {\n    const entries = Object.entries(_def);\n    for (let i = 0, count = entries.length; i < count; i++) {\n      const [key, index] = entries[i];\n      def[key] = {\n        Type: Null,\n        index\n      };\n    }\n    isBasic = true;\n    isIndexed = true;\n  }\n  return {\n    def,\n    isBasic,\n    isIndexed\n  };\n}\nfunction getEntryType(def, checkIdx) {\n  const values = Object.values(def);\n  for (let i = 0, count = values.length; i < count; i++) {\n    const {\n      Type,\n      index\n    } = values[i];\n    if (index === checkIdx) {\n      return Type;\n    }\n  }\n  throw new Error(`Unable to create Enum via index ${checkIdx}, in ${Object.keys(def).join(', ')}`);\n}\nfunction createFromU8a(registry, def, index, value) {\n  const Type = getEntryType(def, index);\n  return {\n    index,\n    value: new Type(registry, value)\n  };\n}\nfunction createFromValue(registry, def, index = 0, value) {\n  const Type = getEntryType(def, index);\n  return {\n    index,\n    value: value instanceof Type ? value : new Type(registry, value)\n  };\n}\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (camelCase)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  const keys = Object.keys(def).map(k => k.toLowerCase());\n  const keyLower = key.toLowerCase();\n  const index = keys.indexOf(keyLower);\n  if (index === -1) {\n    throw new Error(`Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n  }\n  try {\n    return createFromValue(registry, def, Object.values(def)[index].index, value);\n  } catch (error) {\n    throw new Error(`Enum(${key}):: ${error.message}`);\n  }\n}\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value);\n  } else if (isU8a(value) || isHex(value)) {\n    const u8a = u8aToU8a(value);\n    // nested, we don't want to match isObject below\n    if (u8a.length) {\n      return createFromU8a(registry, def, u8a[0], u8a.subarray(1));\n    }\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromJSON(registry, def, value.toString());\n  } else if (isObject(value)) {\n    const key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  }\n  // Worst-case scenario, return the first with default\n  return createFromValue(registry, def, Object.values(def)[0].index);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\nexport class Enum {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__def;\n  __internal__entryIndex;\n  __internal__indexes;\n  __internal__isBasic;\n  __internal__isIndexed;\n  __internal__raw;\n  constructor(registry, Types, value, index, {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    const {\n      def,\n      isBasic,\n      isIndexed\n    } = definition || setDefinition(extractDef(registry, Types));\n    // shortcut isU8a as used in SCALE decoding\n    const decoded = isU8a(value) && value.length && !isNumber(index) ? createFromU8a(registry, def, value[0], value.subarray(1)) : decodeEnum(registry, def, value, index);\n    this.registry = registry;\n    this.__internal__def = def;\n    this.__internal__isBasic = isBasic;\n    this.__internal__isIndexed = isIndexed;\n    this.__internal__indexes = Object.values(def).map(({\n      index\n    }) => index);\n    this.__internal__entryIndex = this.__internal__indexes.indexOf(decoded.index);\n    this.__internal__raw = decoded.value;\n    if (this.__internal__raw.initialU8aLength) {\n      this.initialU8aLength = 1 + this.__internal__raw.initialU8aLength;\n    }\n  }\n  static with(Types) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Enum {\n      static {\n        const keys = Array.isArray(Types) ? Types : Object.keys(Types);\n        const count = keys.length;\n        const asKeys = new Array(count);\n        const isKeys = new Array(count);\n        for (let i = 0; i < count; i++) {\n          const name = stringPascalCase(keys[i]);\n          asKeys[i] = `as${name}`;\n          isKeys[i] = `is${name}`;\n        }\n        objectProperties(this.prototype, isKeys, (_, i, self) => self.type === keys[i]);\n        objectProperties(this.prototype, asKeys, (k, i, self) => {\n          if (self.type !== keys[i]) {\n            throw new Error(`Cannot convert '${self.type}' via ${k}`);\n          }\n          return self.value;\n        });\n      }\n      constructor(registry, value, index) {\n        super(registry, Types, value, index, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return 1 + this.__internal__raw.encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description The index of the enum value\n   */\n  get index() {\n    return this.__internal__indexes[this.__internal__entryIndex];\n  }\n  /**\n   * @description The value of the enum\n   */\n  get inner() {\n    return this.__internal__raw;\n  }\n  /**\n   * @description true if this is a basic enum (no values)\n   */\n  get isBasic() {\n    return this.__internal__isBasic;\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.__internal__raw.isEmpty;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n  get isNone() {\n    return this.__internal__raw instanceof Null;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n  get defIndexes() {\n    return this.__internal__indexes;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n  get defKeys() {\n    return Object.keys(this.__internal__def);\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n  get type() {\n    return this.defKeys[this.__internal__entryIndex];\n  }\n  /**\n   * @description The value of the enum\n   */\n  get value() {\n    return this.__internal__raw;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if (isU8a(other)) {\n      return !this.toU8a().some((entry, index) => entry !== other[index]);\n    } else if (isNumber(other)) {\n      return this.toNumber() === other;\n    } else if (this.__internal__isBasic && isString(other)) {\n      return this.type === other;\n    } else if (isHex(other)) {\n      return this.toHex() === other;\n    } else if (other instanceof Enum) {\n      return this.index === other.index && this.value.eq(other.value);\n    } else if (isObject(other)) {\n      return this.value.eq(other[this.type]);\n    }\n    // compare the actual wrapper value\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    if (this.__internal__isBasic) {\n      return {\n        outer: [new Uint8Array([this.index])]\n      };\n    }\n    const {\n      inner,\n      outer = []\n    } = this.__internal__raw.inspect();\n    return {\n      inner,\n      outer: [new Uint8Array([this.index]), ...outer]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    return this.__internal__isBasic || this.isNone ? this.type : {\n      [this.type]: this.__internal__raw.toHuman(isExtended, disableAscii)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.__internal__isBasic ? this.type : {\n      [stringCamelCase(this.type)]: this.__internal__raw.toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n  toNumber() {\n    return this.index;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    return this.__internal__isBasic ? this.type : {\n      [stringCamelCase(this.type)]: this.__internal__raw.toPrimitive(disableAscii)\n    };\n  }\n  /**\n   * @description Returns a raw struct representation of the enum types\n   */\n  _toRawStruct() {\n    if (this.__internal__isBasic) {\n      return this.__internal__isIndexed ? this.defKeys.reduce((out, key, index) => {\n        out[key] = this.__internal__indexes[index];\n        return out;\n      }, {}) : this.defKeys;\n    }\n    const entries = Object.entries(this.__internal__def);\n    return typesToMap(this.registry, entries.reduce((out, [key, {\n      Type\n    }], i) => {\n      out[0][i] = Type;\n      out[1][i] = key;\n      return out;\n    }, [new Array(entries.length), new Array(entries.length)]));\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return stringify({\n      _enum: this._toRawStruct()\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.isNone ? this.type : stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return isBare ? this.__internal__raw.toU8a(isBare) : u8aConcatStrict([new Uint8Array([this.index]), this.__internal__raw.toU8a(isBare)]);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}