{"ast":null,"code":"import { compactFromU8aLim, compactToU8a, isHex, isObject, isU8a, logger, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { Enum } from '../base/Enum.js';\nimport { Raw } from '../native/Raw.js';\nimport { Struct } from '../native/Struct.js';\nimport { compareMap, decodeU8a, sortMap, typeToConstructor } from '../utils/index.js';\nconst l = logger('Map');\n/** @internal */\nfunction decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {\n  const output = new Map();\n  const [offset, count] = compactFromU8aLim(u8a);\n  const types = [];\n  for (let i = 0; i < count; i++) {\n    types.push(KeyClass, ValClass);\n  }\n  const [values, decodedLength] = decodeU8a(registry, new Array(types.length), u8a.subarray(offset), [types, []]);\n  for (let i = 0, count = values.length; i < count; i += 2) {\n    output.set(values[i], values[i + 1]);\n  }\n  return [KeyClass, ValClass, output, offset + decodedLength];\n}\n/** @internal */\nfunction decodeMapFromMap(registry, KeyClass, ValClass, value) {\n  const output = new Map();\n  for (const [key, val] of value.entries()) {\n    const isComplex = KeyClass.prototype instanceof AbstractArray || KeyClass.prototype instanceof Struct || KeyClass.prototype instanceof Enum;\n    try {\n      output.set(key instanceof KeyClass ? key : new KeyClass(registry, isComplex && typeof key === 'string' ? JSON.parse(key) : key), val instanceof ValClass ? val : new ValClass(registry, val));\n    } catch (error) {\n      l.error('Failed to decode key or value:', error.message);\n      throw error;\n    }\n  }\n  return [KeyClass, ValClass, output, 0];\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param KeyClass - Type of the map key\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Map<any, any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonMap\n * @internal\n */\nfunction decodeMap(registry, keyType, valType, value) {\n  const KeyClass = typeToConstructor(registry, keyType);\n  const ValClass = typeToConstructor(registry, valType);\n  if (!value) {\n    return [KeyClass, ValClass, new Map(), 0];\n  } else if (isU8a(value) || isHex(value)) {\n    return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));\n  } else if (value instanceof Map) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, value);\n  } else if (isObject(value)) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));\n  }\n  throw new Error('Map: cannot decode type');\n}\nexport class CodecMap extends Map {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__KeyClass;\n  __internal__ValClass;\n  __internal__type;\n  constructor(registry, keyType, valType, rawValue, type = 'HashMap') {\n    const [KeyClass, ValClass, decoded, decodedLength] = decodeMap(registry, keyType, valType, rawValue);\n    super(type === 'BTreeMap' ? sortMap(decoded) : decoded);\n    this.registry = registry;\n    this.initialU8aLength = decodedLength;\n    this.__internal__KeyClass = KeyClass;\n    this.__internal__ValClass = ValClass;\n    this.__internal__type = type;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let len = compactToU8a(this.size).length;\n    for (const [k, v] of this.entries()) {\n      len += k.encodedLength + v.encodedLength;\n    }\n    return len;\n  }\n  /**\n   * @description Returns a hash of the value\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.size === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const inner = [];\n    for (const [k, v] of this.entries()) {\n      inner.push(k.inspect());\n      inner.push(v.inspect());\n    }\n    return {\n      inner,\n      outer: [compactToU8a(this.size)]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      json[k instanceof Raw && !disableAscii && k.isAscii ? k.toUtf8() : k.toString()] = v.toHuman(isExtended, disableAscii);\n    }\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      json[k.toString()] = v.toJSON();\n    }\n    return json;\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    const json = {};\n    for (const [k, v] of this.entries()) {\n      json[k instanceof Raw && !disableAscii && k.isAscii ? k.toUtf8() : k.toString()] = v.toPrimitive(disableAscii);\n    }\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `${this.__internal__type}<${this.registry.getClassName(this.__internal__KeyClass) || new this.__internal__KeyClass(this.registry).toRawType()},${this.registry.getClassName(this.__internal__ValClass) || new this.__internal__ValClass(this.registry).toRawType()}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    const encoded = [];\n    if (!isBare) {\n      encoded.push(compactToU8a(this.size));\n    }\n    for (const [k, v] of this.entries()) {\n      encoded.push(k.toU8a(isBare), v.toU8a(isBare));\n    }\n    return u8aConcatStrict(encoded);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}