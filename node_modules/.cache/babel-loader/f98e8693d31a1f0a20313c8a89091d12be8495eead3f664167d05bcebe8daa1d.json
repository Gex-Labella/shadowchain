{"ast":null,"code":"import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './wordlists/en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n/** @internal */\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n/** @internal */\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n/** @internal */\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\n/** @internal */\nfunction deriveChecksumBits(entropyBuffer) {\n  return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);\n}\nexport function mnemonicToSeedSync(mnemonic, password) {\n  return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;\n}\nexport function mnemonicToEntropy(mnemonic, wordlist = DEFAULT_WORDLIST) {\n  const words = normalize(mnemonic).split(' ');\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  // convert word indices to 11 bit binary strings\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n    return index.toString(2).padStart(11, '0');\n  }).join('');\n  // split the binary string into ENT/CS\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n  // calculate the checksum and compare\n  const matched = entropyBits.match(/(.{1,8})/g);\n  const entropyBytes = matched?.map(binaryToByte);\n  if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const entropy = u8aToU8a(entropyBytes);\n  if (deriveChecksumBits(entropy) !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n  return entropy;\n}\nexport function entropyToMnemonic(entropy, wordlist = DEFAULT_WORDLIST) {\n  // 128 <= ENT <= 256\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);\n  const mapped = matched?.map(b => wordlist[binaryToByte(b)]);\n  if (!mapped || mapped.length < 12) {\n    throw new Error('Unable to map entropy to mnemonic');\n  }\n  return mapped.join(' ');\n}\nexport function generateMnemonic(numWords, wordlist) {\n  return entropyToMnemonic(randomAsU8a(numWords / 3 * 4), wordlist);\n}\nexport function validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch {\n    return false;\n  }\n  return true;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}