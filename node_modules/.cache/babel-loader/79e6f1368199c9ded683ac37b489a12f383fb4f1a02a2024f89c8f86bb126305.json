{"ast":null,"code":"import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { toast } from 'react-toastify';\nimport { useWalletStore } from '../store/wallet';\nimport { config } from '../config/environment';\nlet api = null;\n\n// Set to true to run without substrate node\nconst MOCK_MODE = config.features.mockMode;\nexport async function setupPolkadotApi() {\n  if (api) return api;\n\n  // Mock mode - return a mock API object\n  if (MOCK_MODE) {\n    console.log('Running in MOCK MODE - no substrate node required');\n    toast.info('Running in demo mode - blockchain connection simulated');\n    // Return a mock API object that satisfies the interface\n    api = {};\n    return api;\n  }\n  try {\n    const wsProvider = new WsProvider(config.ws.url);\n    api = await ApiPromise.create({\n      provider: wsProvider,\n      types: {\n        // Custom types for Shadow pallet\n        ShadowItem: {\n          id: '[u8; 32]',\n          content: 'Vec<u8>',\n          timestamp: 'u64',\n          source: 'u8',\n          metadata: 'Vec<u8>'\n        },\n        ConsentRecord: {\n          granted_at: 'BlockNumber',\n          expires_at: 'Option<BlockNumber>',\n          message_hash: 'Vec<u8>'\n        }\n      }\n      // Let the API auto-detect signed extensions from chain metadata\n    });\n    await api.isReady;\n    const chain = await api.rpc.system.chain();\n    console.log(`Connected to chain: ${chain}`);\n    console.log(config.ws.url);\n    console.log(wsProvider);\n\n    // Subscribe to connection status\n    wsProvider.on('connected', () => {\n      console.log('WebSocket connected');\n    });\n    wsProvider.on('disconnected', () => {\n      console.error('WebSocket disconnected');\n      //toast.error('Lost connection to blockchain');\n      api = null;\n    });\n    wsProvider.on('error', error => {\n      console.error('WebSocket error:', error);\n      toast.error('Blockchain connection error');\n    });\n    return api;\n  } catch (error) {\n    console.error('Failed to connect to Substrate node:', error);\n    toast.error('Failed to connect to blockchain. Please ensure the node is running.');\n    throw error;\n  }\n}\nexport function getApi() {\n  if (MOCK_MODE) {\n    return {};\n  }\n  if (!api) {\n    throw new Error('API not initialized');\n  }\n  return api;\n}\nexport async function submitShadowItem(cid, encryptedKey, source, metadata) {\n  if (MOCK_MODE) {\n    console.log('Mock: submitting shadow item', {\n      cid,\n      source\n    });\n    toast.success('Mock: Shadow item submitted successfully');\n    return Promise.resolve('0x' + Math.random().toString(16).substr(2, 64));\n  }\n  const api = getApi();\n  const {\n    selectedAccount,\n    injector\n  } = useWalletStore.getState();\n  if (!selectedAccount || !injector) {\n    throw new Error('No account selected');\n  }\n  return new Promise((resolve, reject) => {\n    let unsub;\n    const cidBytes = Array.from(new TextEncoder().encode(cid));\n    const metadataBytes = Array.from(new TextEncoder().encode(metadata));\n    if (!api.tx.shadow) {\n      const error = new Error('Shadow pallet not available on this chain');\n      toast.error('Shadow pallet not found. Please ensure you are connected to the correct chain.');\n      return reject(error);\n    }\n    const timeout = setTimeout(() => {\n      if (unsub) unsub();\n      reject(new Error('Transaction timeout'));\n    }, 60000); // 60 second timeout\n\n    api.tx.shadow.submitShadowItem(cidBytes, Array.from(encryptedKey), source, metadataBytes).signAndSend(selectedAccount.address, {\n      signer: injector.signer\n    }, result => {\n      console.log(`Transaction status: ${result.status.type}`);\n      if (result.status.isInBlock) {\n        console.log(`Transaction included at blockHash ${result.status.asInBlock}`);\n        toast.info('Transaction included in block');\n      } else if (result.status.isFinalized) {\n        console.log(`Transaction finalized at blockHash ${result.status.asFinalized}`);\n        clearTimeout(timeout);\n\n        // Check for errors\n        let hasError = false;\n        result.events.forEach(({\n          phase,\n          event: {\n            data,\n            method,\n            section\n          }\n        }) => {\n          if (section === 'system' && method === 'ExtrinsicFailed') {\n            const [error] = data;\n            console.error('Extrinsic failed:', error.toString());\n            hasError = true;\n            toast.error('Transaction failed on chain');\n            reject(new Error('Transaction failed'));\n          } else if (section === 'shadow' && method === 'ShadowItemStored') {\n            toast.success('Shadow item stored successfully');\n          }\n        });\n        if (!hasError) {\n          if (unsub) unsub();\n          resolve(result.status.asFinalized.toString());\n        }\n      } else if (result.isError) {\n        clearTimeout(timeout);\n        console.error('Transaction error:', result);\n        toast.error('Transaction error');\n        if (unsub) unsub();\n        reject(new Error('Transaction error'));\n      }\n    }).then(unsubscribe => {\n      unsub = unsubscribe;\n    }).catch(error => {\n      clearTimeout(timeout);\n      console.error('Transaction submission failed:', error);\n      toast.error(`Failed to submit transaction: ${error.message}`);\n      reject(error);\n    });\n  });\n}\nexport async function getShadowItems(address) {\n  if (MOCK_MODE) {\n    console.log('Mock: getting shadow items for', address);\n    // Return some mock data\n    return [{\n      id: '0x' + Math.random().toString(16).substr(2, 64),\n      cid: 'QmX4qoKjGHNvWNiyXq8tLsh3kzPvfzCBzLYBEFM1234567',\n      encryptedKey: Array.from(new Uint8Array(32).fill(1)),\n      timestamp: Date.now() - 3600000,\n      source: 'GitHub',\n      metadata: Array.from(new TextEncoder().encode('Mock GitHub commit')),\n      deleted: false\n    }, {\n      id: '0x' + Math.random().toString(16).substr(2, 64),\n      cid: 'QmX4qoKjGHNvWNiyXq8tLsh3kzPvfzCBzLYBEFM7654321',\n      encryptedKey: Array.from(new Uint8Array(32).fill(2)),\n      timestamp: Date.now() - 7200000,\n      source: 'Twitter',\n      metadata: Array.from(new TextEncoder().encode('Mock Twitter post')),\n      deleted: false\n    }];\n  }\n  const api = getApi();\n\n  // Check if shadow pallet exists (registered as \"Shadow\" in runtime)\n  if (!api.query.shadow) {\n    console.warn('Shadow pallet not available on this chain, returning empty array');\n    return [];\n  }\n  const items = await api.query.shadow.shadowItems(address);\n  return items.toJSON();\n}\nexport async function getConsentRecord(address) {\n  if (MOCK_MODE) {\n    console.log('Mock: getting consent record for', address);\n    // Check localStorage for mock consent\n    const mockConsent = localStorage.getItem('shadowchain_mock_consent');\n    if (mockConsent) {\n      return JSON.parse(mockConsent);\n    }\n    return null; // No consent initially\n  }\n  const api = getApi();\n\n  // Check if shadow pallet exists (registered as \"Shadow\" in runtime)\n  if (!api.query.shadow) {\n    console.warn('Shadow pallet not available on this chain, returning null');\n    return null;\n  }\n  const consent = await api.query.shadow.consentRecords(address);\n  return consent.isEmpty ? null : consent.toJSON();\n}\nexport async function grantConsent(messageHash, expiresIn) {\n  if (MOCK_MODE) {\n    console.log('Mock: granting consent', {\n      messageHash,\n      expiresIn\n    });\n    // Store mock consent in localStorage\n    const mockConsent = {\n      grantedAt: Date.now(),\n      expiresAt: expiresIn ? Date.now() + expiresIn * 1000 : null,\n      messageHash\n    };\n    localStorage.setItem('shadowchain_mock_consent', JSON.stringify(mockConsent));\n    toast.success('Mock: Consent granted successfully');\n    return Promise.resolve('0x' + Math.random().toString(16).substr(2, 64));\n  }\n  const api = getApi();\n  const {\n    selectedAccount,\n    injector\n  } = useWalletStore.getState();\n  if (!selectedAccount || !injector) {\n    throw new Error('No account selected');\n  }\n  return new Promise((resolve, reject) => {\n    let unsub;\n\n    // Check if shadow pallet exists (registered as \"Shadow\" in runtime)\n    if (!api.tx.shadow) {\n      const error = new Error('Shadow pallet not available on this chain');\n      toast.error('Shadow pallet not found. Please ensure you are connected to the correct chain.');\n      return reject(error);\n    }\n\n    // Create a timeout for the transaction\n    const timeout = setTimeout(() => {\n      if (unsub) unsub();\n      reject(new Error('Transaction timeout'));\n    }, 60000); // 60 second timeout\n\n    api.tx.shadow.grantConsent(messageHash, expiresIn).signAndSend(selectedAccount.address, {\n      signer: injector.signer\n    }, result => {\n      console.log(`Consent transaction status: ${result.status.type}`);\n      if (result.status.isInBlock) {\n        toast.info('Consent transaction included in block');\n      } else if (result.status.isFinalized) {\n        clearTimeout(timeout);\n\n        // Check for errors\n        let hasError = false;\n        result.events.forEach(({\n          phase,\n          event: {\n            data,\n            method,\n            section\n          }\n        }) => {\n          if (section === 'system' && method === 'ExtrinsicFailed') {\n            const [error] = data;\n            console.error('Consent failed:', error.toString());\n            hasError = true;\n            toast.error('Consent transaction failed');\n            reject(new Error('Consent transaction failed'));\n          } else if (section === 'shadow' && method === 'ConsentGranted') {\n            toast.success('Consent granted successfully');\n          }\n        });\n        if (!hasError) {\n          if (unsub) unsub();\n          resolve(result.status.asFinalized.toString());\n        }\n      } else if (result.isError) {\n        clearTimeout(timeout);\n        console.error('Consent transaction error:', result);\n        toast.error('Consent transaction error');\n        if (unsub) unsub();\n        reject(new Error('Consent transaction error'));\n      }\n    }).then(unsubscribe => {\n      unsub = unsubscribe;\n    }).catch(error => {\n      clearTimeout(timeout);\n      console.error('Consent submission failed:', error);\n      toast.error(`Failed to grant consent: ${error.message}`);\n      reject(error);\n    });\n  });\n}","map":{"version":3,"names":["ApiPromise","WsProvider","toast","useWalletStore","config","api","MOCK_MODE","features","mockMode","setupPolkadotApi","console","log","info","wsProvider","ws","url","create","provider","types","ShadowItem","id","content","timestamp","source","metadata","ConsentRecord","granted_at","expires_at","message_hash","isReady","chain","rpc","system","on","error","getApi","Error","submitShadowItem","cid","encryptedKey","success","Promise","resolve","Math","random","toString","substr","selectedAccount","injector","getState","reject","unsub","cidBytes","Array","from","TextEncoder","encode","metadataBytes","tx","shadow","timeout","setTimeout","signAndSend","address","signer","result","status","type","isInBlock","asInBlock","isFinalized","asFinalized","clearTimeout","hasError","events","forEach","phase","event","data","method","section","isError","then","unsubscribe","catch","message","getShadowItems","Uint8Array","fill","Date","now","deleted","query","warn","items","shadowItems","toJSON","getConsentRecord","mockConsent","localStorage","getItem","JSON","parse","consent","consentRecords","isEmpty","grantConsent","messageHash","expiresIn","grantedAt","expiresAt","setItem","stringify"],"sources":["c:/Users/Admin/Documents/Keiths/Polkadot/shadowchain/frontend/src/services/polkadot.ts"],"sourcesContent":["import { ApiPromise, WsProvider } from '@polkadot/api';\r\nimport { toast } from 'react-toastify';\r\nimport { useWalletStore } from '../store/wallet';\r\nimport { config } from '../config/environment';\r\n\r\nlet api: ApiPromise | null = null;\r\n\r\n// Set to true to run without substrate node\r\nconst MOCK_MODE = config.features.mockMode;\r\n\r\nexport async function setupPolkadotApi(): Promise<ApiPromise> {\r\n  if (api) return api;\r\n\r\n  // Mock mode - return a mock API object\r\n  if (MOCK_MODE) {\r\n    console.log('Running in MOCK MODE - no substrate node required');\r\n    toast.info('Running in demo mode - blockchain connection simulated');\r\n    // Return a mock API object that satisfies the interface\r\n    api = {} as ApiPromise;\r\n    return api;\r\n  }\r\n\r\n  try {\r\n    const wsProvider = new WsProvider(config.ws.url);\r\n\r\n    api = await ApiPromise.create({\r\n      provider: wsProvider,\r\n      types: {\r\n        // Custom types for Shadow pallet\r\n        ShadowItem: {\r\n          id: '[u8; 32]',\r\n          content: 'Vec<u8>',\r\n          timestamp: 'u64',\r\n          source: 'u8',\r\n          metadata: 'Vec<u8>'\r\n        },\r\n        ConsentRecord: {\r\n          granted_at: 'BlockNumber',\r\n          expires_at: 'Option<BlockNumber>',\r\n          message_hash: 'Vec<u8>'\r\n        }\r\n      }\r\n      // Let the API auto-detect signed extensions from chain metadata\r\n    });\r\n\r\n    await api.isReady;\r\n\r\n    const chain = await api.rpc.system.chain();\r\n    console.log(`Connected to chain: ${chain}`);\r\n\r\n\r\n    console.log(config.ws.url)\r\n    console.log(wsProvider)\r\n\r\n    // Subscribe to connection status\r\n    wsProvider.on('connected', () => {\r\n      console.log('WebSocket connected');\r\n    });\r\n\r\n    wsProvider.on('disconnected', () => {\r\n      console.error('WebSocket disconnected');\r\n      //toast.error('Lost connection to blockchain');\r\n      api = null;\r\n    });\r\n\r\n    wsProvider.on('error', (error) => {\r\n      console.error('WebSocket error:', error);\r\n      toast.error('Blockchain connection error');\r\n    });\r\n\r\n    return api;\r\n  } catch (error) {\r\n    console.error('Failed to connect to Substrate node:', error);\r\n    toast.error('Failed to connect to blockchain. Please ensure the node is running.');\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport function getApi(): ApiPromise {\r\n  if (MOCK_MODE) {\r\n    return {} as ApiPromise;\r\n  }\r\n  if (!api) {\r\n    throw new Error('API not initialized');\r\n  }\r\n  return api;\r\n}\r\n\r\nexport async function submitShadowItem(\r\n  cid: string,\r\n  encryptedKey: Uint8Array,\r\n  source: 'GitHub' | 'Twitter',\r\n  metadata: string\r\n): Promise<string> {\r\n  if (MOCK_MODE) {\r\n    console.log('Mock: submitting shadow item', { cid, source });\r\n    toast.success('Mock: Shadow item submitted successfully');\r\n    return Promise.resolve('0x' + Math.random().toString(16).substr(2, 64));\r\n  }\r\n\r\n  const api = getApi();\r\n  const { selectedAccount, injector } = useWalletStore.getState();\r\n\r\n  if (!selectedAccount || !injector) {\r\n    throw new Error('No account selected');\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    let unsub: (() => void) | undefined;\r\n\r\n    const cidBytes = Array.from(new TextEncoder().encode(cid));\r\n    const metadataBytes = Array.from(new TextEncoder().encode(metadata));\r\n    \r\n    if (!api.tx.shadow) {\r\n      const error = new Error('Shadow pallet not available on this chain');\r\n      toast.error('Shadow pallet not found. Please ensure you are connected to the correct chain.');\r\n      return reject(error);\r\n    }\r\n    \r\n    const timeout = setTimeout(() => {\r\n      if (unsub) unsub();\r\n      reject(new Error('Transaction timeout'));\r\n    }, 60000); // 60 second timeout\r\n    \r\n    api.tx.shadow\r\n      .submitShadowItem(\r\n        cidBytes,\r\n        Array.from(encryptedKey),\r\n        source,\r\n        metadataBytes\r\n      )\r\n      .signAndSend(\r\n        selectedAccount.address,\r\n        { signer: injector.signer },\r\n        (result) => {\r\n          console.log(`Transaction status: ${result.status.type}`);\r\n\r\n          if (result.status.isInBlock) {\r\n            console.log(`Transaction included at blockHash ${result.status.asInBlock}`);\r\n            toast.info('Transaction included in block');\r\n          } else if (result.status.isFinalized) {\r\n            console.log(`Transaction finalized at blockHash ${result.status.asFinalized}`);\r\n            clearTimeout(timeout);\r\n            \r\n            // Check for errors\r\n            let hasError = false;\r\n            result.events.forEach(({ phase, event: { data, method, section } }) => {\r\n              if (section === 'system' && method === 'ExtrinsicFailed') {\r\n                const [error] = data as any;\r\n                console.error('Extrinsic failed:', error.toString());\r\n                hasError = true;\r\n                toast.error('Transaction failed on chain');\r\n                reject(new Error('Transaction failed'));\r\n              } else if (section === 'shadow' && method === 'ShadowItemStored') {\r\n                toast.success('Shadow item stored successfully');\r\n              }\r\n            });\r\n\r\n            if (!hasError) {\r\n              if (unsub) unsub();\r\n              resolve(result.status.asFinalized.toString());\r\n            }\r\n          } else if (result.isError) {\r\n            clearTimeout(timeout);\r\n            console.error('Transaction error:', result);\r\n            toast.error('Transaction error');\r\n            if (unsub) unsub();\r\n            reject(new Error('Transaction error'));\r\n          }\r\n        }\r\n      )\r\n      .then((unsubscribe) => {\r\n        unsub = unsubscribe;\r\n      })\r\n      .catch((error) => {\r\n        clearTimeout(timeout);\r\n        console.error('Transaction submission failed:', error);\r\n        toast.error(`Failed to submit transaction: ${error.message}`);\r\n        reject(error);\r\n      });\r\n  });\r\n}\r\n\r\nexport async function getShadowItems(address: string): Promise<any[]> {\r\n  if (MOCK_MODE) {\r\n    console.log('Mock: getting shadow items for', address);\r\n    // Return some mock data\r\n    return [\r\n      {\r\n        id: '0x' + Math.random().toString(16).substr(2, 64),\r\n        cid: 'QmX4qoKjGHNvWNiyXq8tLsh3kzPvfzCBzLYBEFM1234567',\r\n        encryptedKey: Array.from(new Uint8Array(32).fill(1)),\r\n        timestamp: Date.now() - 3600000,\r\n        source: 'GitHub',\r\n        metadata: Array.from(new TextEncoder().encode('Mock GitHub commit')),\r\n        deleted: false\r\n      },\r\n      {\r\n        id: '0x' + Math.random().toString(16).substr(2, 64),\r\n        cid: 'QmX4qoKjGHNvWNiyXq8tLsh3kzPvfzCBzLYBEFM7654321',\r\n        encryptedKey: Array.from(new Uint8Array(32).fill(2)),\r\n        timestamp: Date.now() - 7200000,\r\n        source: 'Twitter',\r\n        metadata: Array.from(new TextEncoder().encode('Mock Twitter post')),\r\n        deleted: false\r\n      }\r\n    ];\r\n  }\r\n  \r\n  const api = getApi();\r\n  \r\n  // Check if shadow pallet exists (registered as \"Shadow\" in runtime)\r\n  if (!api.query.shadow) {\r\n    console.warn('Shadow pallet not available on this chain, returning empty array');\r\n    return [];\r\n  }\r\n  \r\n  const items = await api.query.shadow.shadowItems(address);\r\n  return items.toJSON() as any[];\r\n}\r\n\r\nexport async function getConsentRecord(address: string): Promise<any> {\r\n  if (MOCK_MODE) {\r\n    console.log('Mock: getting consent record for', address);\r\n    // Check localStorage for mock consent\r\n    const mockConsent = localStorage.getItem('shadowchain_mock_consent');\r\n    if (mockConsent) {\r\n      return JSON.parse(mockConsent);\r\n    }\r\n    return null; // No consent initially\r\n  }\r\n  \r\n  const api = getApi();\r\n  \r\n  // Check if shadow pallet exists (registered as \"Shadow\" in runtime)\r\n  if (!api.query.shadow) {\r\n    console.warn('Shadow pallet not available on this chain, returning null');\r\n    return null;\r\n  }\r\n  \r\n  const consent = await api.query.shadow.consentRecords(address);\r\n  return consent.isEmpty ? null : consent.toJSON();\r\n}\r\n\r\nexport async function grantConsent(messageHash: string, expiresIn?: number): Promise<string> {\r\n  if (MOCK_MODE) {\r\n    console.log('Mock: granting consent', { messageHash, expiresIn });\r\n    // Store mock consent in localStorage\r\n    const mockConsent = {\r\n      grantedAt: Date.now(),\r\n      expiresAt: expiresIn ? Date.now() + expiresIn * 1000 : null,\r\n      messageHash\r\n    };\r\n    localStorage.setItem('shadowchain_mock_consent', JSON.stringify(mockConsent));\r\n    toast.success('Mock: Consent granted successfully');\r\n    return Promise.resolve('0x' + Math.random().toString(16).substr(2, 64));\r\n  }\r\n\r\n  const api = getApi();\r\n  const { selectedAccount, injector } = useWalletStore.getState();\r\n\r\n  if (!selectedAccount || !injector) {\r\n    throw new Error('No account selected');\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    let unsub: (() => void) | undefined;\r\n\r\n    // Check if shadow pallet exists (registered as \"Shadow\" in runtime)\r\n    if (!api.tx.shadow) {\r\n      const error = new Error('Shadow pallet not available on this chain');\r\n      toast.error('Shadow pallet not found. Please ensure you are connected to the correct chain.');\r\n      return reject(error);\r\n    }\r\n\r\n    // Create a timeout for the transaction\r\n    const timeout = setTimeout(() => {\r\n      if (unsub) unsub();\r\n      reject(new Error('Transaction timeout'));\r\n    }, 60000); // 60 second timeout\r\n\r\n    api.tx.shadow\r\n      .grantConsent(messageHash, expiresIn)\r\n      .signAndSend(\r\n        selectedAccount.address,\r\n        { signer: injector.signer },\r\n        (result) => {\r\n          console.log(`Consent transaction status: ${result.status.type}`);\r\n          \r\n          if (result.status.isInBlock) {\r\n            toast.info('Consent transaction included in block');\r\n          } else if (result.status.isFinalized) {\r\n            clearTimeout(timeout);\r\n            \r\n            // Check for errors\r\n            let hasError = false;\r\n            result.events.forEach(({ phase, event: { data, method, section } }) => {\r\n              if (section === 'system' && method === 'ExtrinsicFailed') {\r\n                const [error] = data as any;\r\n                console.error('Consent failed:', error.toString());\r\n                hasError = true;\r\n                toast.error('Consent transaction failed');\r\n                reject(new Error('Consent transaction failed'));\r\n              } else if (section === 'shadow' && method === 'ConsentGranted') {\r\n                toast.success('Consent granted successfully');\r\n              }\r\n            });\r\n\r\n            if (!hasError) {\r\n              if (unsub) unsub();\r\n              resolve(result.status.asFinalized.toString());\r\n            }\r\n          } else if (result.isError) {\r\n            clearTimeout(timeout);\r\n            console.error('Consent transaction error:', result);\r\n            toast.error('Consent transaction error');\r\n            if (unsub) unsub();\r\n            reject(new Error('Consent transaction error'));\r\n          }\r\n        }\r\n      )\r\n      .then((unsubscribe) => {\r\n        unsub = unsubscribe;\r\n      })\r\n      .catch((error) => {\r\n        clearTimeout(timeout);\r\n        console.error('Consent submission failed:', error);\r\n        toast.error(`Failed to grant consent: ${error.message}`);\r\n        reject(error);\r\n      });\r\n  });\r\n}"],"mappings":"AAAA,SAASA,UAAU,EAAEC,UAAU,QAAQ,eAAe;AACtD,SAASC,KAAK,QAAQ,gBAAgB;AACtC,SAASC,cAAc,QAAQ,iBAAiB;AAChD,SAASC,MAAM,QAAQ,uBAAuB;AAE9C,IAAIC,GAAsB,GAAG,IAAI;;AAEjC;AACA,MAAMC,SAAS,GAAGF,MAAM,CAACG,QAAQ,CAACC,QAAQ;AAE1C,OAAO,eAAeC,gBAAgBA,CAAA,EAAwB;EAC5D,IAAIJ,GAAG,EAAE,OAAOA,GAAG;;EAEnB;EACA,IAAIC,SAAS,EAAE;IACbI,OAAO,CAACC,GAAG,CAAC,mDAAmD,CAAC;IAChET,KAAK,CAACU,IAAI,CAAC,wDAAwD,CAAC;IACpE;IACAP,GAAG,GAAG,CAAC,CAAe;IACtB,OAAOA,GAAG;EACZ;EAEA,IAAI;IACF,MAAMQ,UAAU,GAAG,IAAIZ,UAAU,CAACG,MAAM,CAACU,EAAE,CAACC,GAAG,CAAC;IAEhDV,GAAG,GAAG,MAAML,UAAU,CAACgB,MAAM,CAAC;MAC5BC,QAAQ,EAAEJ,UAAU;MACpBK,KAAK,EAAE;QACL;QACAC,UAAU,EAAE;UACVC,EAAE,EAAE,UAAU;UACdC,OAAO,EAAE,SAAS;UAClBC,SAAS,EAAE,KAAK;UAChBC,MAAM,EAAE,IAAI;UACZC,QAAQ,EAAE;QACZ,CAAC;QACDC,aAAa,EAAE;UACbC,UAAU,EAAE,aAAa;UACzBC,UAAU,EAAE,qBAAqB;UACjCC,YAAY,EAAE;QAChB;MACF;MACA;IACF,CAAC,CAAC;IAEF,MAAMvB,GAAG,CAACwB,OAAO;IAEjB,MAAMC,KAAK,GAAG,MAAMzB,GAAG,CAAC0B,GAAG,CAACC,MAAM,CAACF,KAAK,CAAC,CAAC;IAC1CpB,OAAO,CAACC,GAAG,CAAC,uBAAuBmB,KAAK,EAAE,CAAC;IAG3CpB,OAAO,CAACC,GAAG,CAACP,MAAM,CAACU,EAAE,CAACC,GAAG,CAAC;IAC1BL,OAAO,CAACC,GAAG,CAACE,UAAU,CAAC;;IAEvB;IACAA,UAAU,CAACoB,EAAE,CAAC,WAAW,EAAE,MAAM;MAC/BvB,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;IACpC,CAAC,CAAC;IAEFE,UAAU,CAACoB,EAAE,CAAC,cAAc,EAAE,MAAM;MAClCvB,OAAO,CAACwB,KAAK,CAAC,wBAAwB,CAAC;MACvC;MACA7B,GAAG,GAAG,IAAI;IACZ,CAAC,CAAC;IAEFQ,UAAU,CAACoB,EAAE,CAAC,OAAO,EAAGC,KAAK,IAAK;MAChCxB,OAAO,CAACwB,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;MACxChC,KAAK,CAACgC,KAAK,CAAC,6BAA6B,CAAC;IAC5C,CAAC,CAAC;IAEF,OAAO7B,GAAG;EACZ,CAAC,CAAC,OAAO6B,KAAK,EAAE;IACdxB,OAAO,CAACwB,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC5DhC,KAAK,CAACgC,KAAK,CAAC,qEAAqE,CAAC;IAClF,MAAMA,KAAK;EACb;AACF;AAEA,OAAO,SAASC,MAAMA,CAAA,EAAe;EACnC,IAAI7B,SAAS,EAAE;IACb,OAAO,CAAC,CAAC;EACX;EACA,IAAI,CAACD,GAAG,EAAE;IACR,MAAM,IAAI+B,KAAK,CAAC,qBAAqB,CAAC;EACxC;EACA,OAAO/B,GAAG;AACZ;AAEA,OAAO,eAAegC,gBAAgBA,CACpCC,GAAW,EACXC,YAAwB,EACxBhB,MAA4B,EAC5BC,QAAgB,EACC;EACjB,IAAIlB,SAAS,EAAE;IACbI,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAE;MAAE2B,GAAG;MAAEf;IAAO,CAAC,CAAC;IAC5DrB,KAAK,CAACsC,OAAO,CAAC,0CAA0C,CAAC;IACzD,OAAOC,OAAO,CAACC,OAAO,CAAC,IAAI,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EACzE;EAEA,MAAMzC,GAAG,GAAG8B,MAAM,CAAC,CAAC;EACpB,MAAM;IAAEY,eAAe;IAAEC;EAAS,CAAC,GAAG7C,cAAc,CAAC8C,QAAQ,CAAC,CAAC;EAE/D,IAAI,CAACF,eAAe,IAAI,CAACC,QAAQ,EAAE;IACjC,MAAM,IAAIZ,KAAK,CAAC,qBAAqB,CAAC;EACxC;EAEA,OAAO,IAAIK,OAAO,CAAC,CAACC,OAAO,EAAEQ,MAAM,KAAK;IACtC,IAAIC,KAA+B;IAEnC,MAAMC,QAAQ,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAAClB,GAAG,CAAC,CAAC;IAC1D,MAAMmB,aAAa,GAAGJ,KAAK,CAACC,IAAI,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAAChC,QAAQ,CAAC,CAAC;IAEpE,IAAI,CAACnB,GAAG,CAACqD,EAAE,CAACC,MAAM,EAAE;MAClB,MAAMzB,KAAK,GAAG,IAAIE,KAAK,CAAC,2CAA2C,CAAC;MACpElC,KAAK,CAACgC,KAAK,CAAC,gFAAgF,CAAC;MAC7F,OAAOgB,MAAM,CAAChB,KAAK,CAAC;IACtB;IAEA,MAAM0B,OAAO,GAAGC,UAAU,CAAC,MAAM;MAC/B,IAAIV,KAAK,EAAEA,KAAK,CAAC,CAAC;MAClBD,MAAM,CAAC,IAAId,KAAK,CAAC,qBAAqB,CAAC,CAAC;IAC1C,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;;IAEX/B,GAAG,CAACqD,EAAE,CAACC,MAAM,CACVtB,gBAAgB,CACfe,QAAQ,EACRC,KAAK,CAACC,IAAI,CAACf,YAAY,CAAC,EACxBhB,MAAM,EACNkC,aACF,CAAC,CACAK,WAAW,CACVf,eAAe,CAACgB,OAAO,EACvB;MAAEC,MAAM,EAAEhB,QAAQ,CAACgB;IAAO,CAAC,EAC1BC,MAAM,IAAK;MACVvD,OAAO,CAACC,GAAG,CAAC,uBAAuBsD,MAAM,CAACC,MAAM,CAACC,IAAI,EAAE,CAAC;MAExD,IAAIF,MAAM,CAACC,MAAM,CAACE,SAAS,EAAE;QAC3B1D,OAAO,CAACC,GAAG,CAAC,qCAAqCsD,MAAM,CAACC,MAAM,CAACG,SAAS,EAAE,CAAC;QAC3EnE,KAAK,CAACU,IAAI,CAAC,+BAA+B,CAAC;MAC7C,CAAC,MAAM,IAAIqD,MAAM,CAACC,MAAM,CAACI,WAAW,EAAE;QACpC5D,OAAO,CAACC,GAAG,CAAC,sCAAsCsD,MAAM,CAACC,MAAM,CAACK,WAAW,EAAE,CAAC;QAC9EC,YAAY,CAACZ,OAAO,CAAC;;QAErB;QACA,IAAIa,QAAQ,GAAG,KAAK;QACpBR,MAAM,CAACS,MAAM,CAACC,OAAO,CAAC,CAAC;UAAEC,KAAK;UAAEC,KAAK,EAAE;YAAEC,IAAI;YAAEC,MAAM;YAAEC;UAAQ;QAAE,CAAC,KAAK;UACrE,IAAIA,OAAO,KAAK,QAAQ,IAAID,MAAM,KAAK,iBAAiB,EAAE;YACxD,MAAM,CAAC7C,KAAK,CAAC,GAAG4C,IAAW;YAC3BpE,OAAO,CAACwB,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAACW,QAAQ,CAAC,CAAC,CAAC;YACpD4B,QAAQ,GAAG,IAAI;YACfvE,KAAK,CAACgC,KAAK,CAAC,6BAA6B,CAAC;YAC1CgB,MAAM,CAAC,IAAId,KAAK,CAAC,oBAAoB,CAAC,CAAC;UACzC,CAAC,MAAM,IAAI4C,OAAO,KAAK,QAAQ,IAAID,MAAM,KAAK,kBAAkB,EAAE;YAChE7E,KAAK,CAACsC,OAAO,CAAC,iCAAiC,CAAC;UAClD;QACF,CAAC,CAAC;QAEF,IAAI,CAACiC,QAAQ,EAAE;UACb,IAAItB,KAAK,EAAEA,KAAK,CAAC,CAAC;UAClBT,OAAO,CAACuB,MAAM,CAACC,MAAM,CAACK,WAAW,CAAC1B,QAAQ,CAAC,CAAC,CAAC;QAC/C;MACF,CAAC,MAAM,IAAIoB,MAAM,CAACgB,OAAO,EAAE;QACzBT,YAAY,CAACZ,OAAO,CAAC;QACrBlD,OAAO,CAACwB,KAAK,CAAC,oBAAoB,EAAE+B,MAAM,CAAC;QAC3C/D,KAAK,CAACgC,KAAK,CAAC,mBAAmB,CAAC;QAChC,IAAIiB,KAAK,EAAEA,KAAK,CAAC,CAAC;QAClBD,MAAM,CAAC,IAAId,KAAK,CAAC,mBAAmB,CAAC,CAAC;MACxC;IACF,CACF,CAAC,CACA8C,IAAI,CAAEC,WAAW,IAAK;MACrBhC,KAAK,GAAGgC,WAAW;IACrB,CAAC,CAAC,CACDC,KAAK,CAAElD,KAAK,IAAK;MAChBsC,YAAY,CAACZ,OAAO,CAAC;MACrBlD,OAAO,CAACwB,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtDhC,KAAK,CAACgC,KAAK,CAAC,iCAAiCA,KAAK,CAACmD,OAAO,EAAE,CAAC;MAC7DnC,MAAM,CAAChB,KAAK,CAAC;IACf,CAAC,CAAC;EACN,CAAC,CAAC;AACJ;AAEA,OAAO,eAAeoD,cAAcA,CAACvB,OAAe,EAAkB;EACpE,IAAIzD,SAAS,EAAE;IACbI,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEoD,OAAO,CAAC;IACtD;IACA,OAAO,CACL;MACE3C,EAAE,EAAE,IAAI,GAAGuB,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC;MACnDR,GAAG,EAAE,gDAAgD;MACrDC,YAAY,EAAEc,KAAK,CAACC,IAAI,CAAC,IAAIiC,UAAU,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;MACpDlE,SAAS,EAAEmE,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,OAAO;MAC/BnE,MAAM,EAAE,QAAQ;MAChBC,QAAQ,EAAE6B,KAAK,CAACC,IAAI,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAAC,oBAAoB,CAAC,CAAC;MACpEmC,OAAO,EAAE;IACX,CAAC,EACD;MACEvE,EAAE,EAAE,IAAI,GAAGuB,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC;MACnDR,GAAG,EAAE,gDAAgD;MACrDC,YAAY,EAAEc,KAAK,CAACC,IAAI,CAAC,IAAIiC,UAAU,CAAC,EAAE,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;MACpDlE,SAAS,EAAEmE,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,OAAO;MAC/BnE,MAAM,EAAE,SAAS;MACjBC,QAAQ,EAAE6B,KAAK,CAACC,IAAI,CAAC,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAAC,mBAAmB,CAAC,CAAC;MACnEmC,OAAO,EAAE;IACX,CAAC,CACF;EACH;EAEA,MAAMtF,GAAG,GAAG8B,MAAM,CAAC,CAAC;;EAEpB;EACA,IAAI,CAAC9B,GAAG,CAACuF,KAAK,CAACjC,MAAM,EAAE;IACrBjD,OAAO,CAACmF,IAAI,CAAC,kEAAkE,CAAC;IAChF,OAAO,EAAE;EACX;EAEA,MAAMC,KAAK,GAAG,MAAMzF,GAAG,CAACuF,KAAK,CAACjC,MAAM,CAACoC,WAAW,CAAChC,OAAO,CAAC;EACzD,OAAO+B,KAAK,CAACE,MAAM,CAAC,CAAC;AACvB;AAEA,OAAO,eAAeC,gBAAgBA,CAAClC,OAAe,EAAgB;EACpE,IAAIzD,SAAS,EAAE;IACbI,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAEoD,OAAO,CAAC;IACxD;IACA,MAAMmC,WAAW,GAAGC,YAAY,CAACC,OAAO,CAAC,0BAA0B,CAAC;IACpE,IAAIF,WAAW,EAAE;MACf,OAAOG,IAAI,CAACC,KAAK,CAACJ,WAAW,CAAC;IAChC;IACA,OAAO,IAAI,CAAC,CAAC;EACf;EAEA,MAAM7F,GAAG,GAAG8B,MAAM,CAAC,CAAC;;EAEpB;EACA,IAAI,CAAC9B,GAAG,CAACuF,KAAK,CAACjC,MAAM,EAAE;IACrBjD,OAAO,CAACmF,IAAI,CAAC,2DAA2D,CAAC;IACzE,OAAO,IAAI;EACb;EAEA,MAAMU,OAAO,GAAG,MAAMlG,GAAG,CAACuF,KAAK,CAACjC,MAAM,CAAC6C,cAAc,CAACzC,OAAO,CAAC;EAC9D,OAAOwC,OAAO,CAACE,OAAO,GAAG,IAAI,GAAGF,OAAO,CAACP,MAAM,CAAC,CAAC;AAClD;AAEA,OAAO,eAAeU,YAAYA,CAACC,WAAmB,EAAEC,SAAkB,EAAmB;EAC3F,IAAItG,SAAS,EAAE;IACbI,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAE;MAAEgG,WAAW;MAAEC;IAAU,CAAC,CAAC;IACjE;IACA,MAAMV,WAAW,GAAG;MAClBW,SAAS,EAAEpB,IAAI,CAACC,GAAG,CAAC,CAAC;MACrBoB,SAAS,EAAEF,SAAS,GAAGnB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGkB,SAAS,GAAG,IAAI,GAAG,IAAI;MAC3DD;IACF,CAAC;IACDR,YAAY,CAACY,OAAO,CAAC,0BAA0B,EAAEV,IAAI,CAACW,SAAS,CAACd,WAAW,CAAC,CAAC;IAC7EhG,KAAK,CAACsC,OAAO,CAAC,oCAAoC,CAAC;IACnD,OAAOC,OAAO,CAACC,OAAO,CAAC,IAAI,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EACzE;EAEA,MAAMzC,GAAG,GAAG8B,MAAM,CAAC,CAAC;EACpB,MAAM;IAAEY,eAAe;IAAEC;EAAS,CAAC,GAAG7C,cAAc,CAAC8C,QAAQ,CAAC,CAAC;EAE/D,IAAI,CAACF,eAAe,IAAI,CAACC,QAAQ,EAAE;IACjC,MAAM,IAAIZ,KAAK,CAAC,qBAAqB,CAAC;EACxC;EAEA,OAAO,IAAIK,OAAO,CAAC,CAACC,OAAO,EAAEQ,MAAM,KAAK;IACtC,IAAIC,KAA+B;;IAEnC;IACA,IAAI,CAAC9C,GAAG,CAACqD,EAAE,CAACC,MAAM,EAAE;MAClB,MAAMzB,KAAK,GAAG,IAAIE,KAAK,CAAC,2CAA2C,CAAC;MACpElC,KAAK,CAACgC,KAAK,CAAC,gFAAgF,CAAC;MAC7F,OAAOgB,MAAM,CAAChB,KAAK,CAAC;IACtB;;IAEA;IACA,MAAM0B,OAAO,GAAGC,UAAU,CAAC,MAAM;MAC/B,IAAIV,KAAK,EAAEA,KAAK,CAAC,CAAC;MAClBD,MAAM,CAAC,IAAId,KAAK,CAAC,qBAAqB,CAAC,CAAC;IAC1C,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;;IAEX/B,GAAG,CAACqD,EAAE,CAACC,MAAM,CACV+C,YAAY,CAACC,WAAW,EAAEC,SAAS,CAAC,CACpC9C,WAAW,CACVf,eAAe,CAACgB,OAAO,EACvB;MAAEC,MAAM,EAAEhB,QAAQ,CAACgB;IAAO,CAAC,EAC1BC,MAAM,IAAK;MACVvD,OAAO,CAACC,GAAG,CAAC,+BAA+BsD,MAAM,CAACC,MAAM,CAACC,IAAI,EAAE,CAAC;MAEhE,IAAIF,MAAM,CAACC,MAAM,CAACE,SAAS,EAAE;QAC3BlE,KAAK,CAACU,IAAI,CAAC,uCAAuC,CAAC;MACrD,CAAC,MAAM,IAAIqD,MAAM,CAACC,MAAM,CAACI,WAAW,EAAE;QACpCE,YAAY,CAACZ,OAAO,CAAC;;QAErB;QACA,IAAIa,QAAQ,GAAG,KAAK;QACpBR,MAAM,CAACS,MAAM,CAACC,OAAO,CAAC,CAAC;UAAEC,KAAK;UAAEC,KAAK,EAAE;YAAEC,IAAI;YAAEC,MAAM;YAAEC;UAAQ;QAAE,CAAC,KAAK;UACrE,IAAIA,OAAO,KAAK,QAAQ,IAAID,MAAM,KAAK,iBAAiB,EAAE;YACxD,MAAM,CAAC7C,KAAK,CAAC,GAAG4C,IAAW;YAC3BpE,OAAO,CAACwB,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAACW,QAAQ,CAAC,CAAC,CAAC;YAClD4B,QAAQ,GAAG,IAAI;YACfvE,KAAK,CAACgC,KAAK,CAAC,4BAA4B,CAAC;YACzCgB,MAAM,CAAC,IAAId,KAAK,CAAC,4BAA4B,CAAC,CAAC;UACjD,CAAC,MAAM,IAAI4C,OAAO,KAAK,QAAQ,IAAID,MAAM,KAAK,gBAAgB,EAAE;YAC9D7E,KAAK,CAACsC,OAAO,CAAC,8BAA8B,CAAC;UAC/C;QACF,CAAC,CAAC;QAEF,IAAI,CAACiC,QAAQ,EAAE;UACb,IAAItB,KAAK,EAAEA,KAAK,CAAC,CAAC;UAClBT,OAAO,CAACuB,MAAM,CAACC,MAAM,CAACK,WAAW,CAAC1B,QAAQ,CAAC,CAAC,CAAC;QAC/C;MACF,CAAC,MAAM,IAAIoB,MAAM,CAACgB,OAAO,EAAE;QACzBT,YAAY,CAACZ,OAAO,CAAC;QACrBlD,OAAO,CAACwB,KAAK,CAAC,4BAA4B,EAAE+B,MAAM,CAAC;QACnD/D,KAAK,CAACgC,KAAK,CAAC,2BAA2B,CAAC;QACxC,IAAIiB,KAAK,EAAEA,KAAK,CAAC,CAAC;QAClBD,MAAM,CAAC,IAAId,KAAK,CAAC,2BAA2B,CAAC,CAAC;MAChD;IACF,CACF,CAAC,CACA8C,IAAI,CAAEC,WAAW,IAAK;MACrBhC,KAAK,GAAGgC,WAAW;IACrB,CAAC,CAAC,CACDC,KAAK,CAAElD,KAAK,IAAK;MAChBsC,YAAY,CAACZ,OAAO,CAAC;MACrBlD,OAAO,CAACwB,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClDhC,KAAK,CAACgC,KAAK,CAAC,4BAA4BA,KAAK,CAACmD,OAAO,EAAE,CAAC;MACxDnC,MAAM,CAAChB,KAAK,CAAC;IACf,CAAC,CAAC;EACN,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}