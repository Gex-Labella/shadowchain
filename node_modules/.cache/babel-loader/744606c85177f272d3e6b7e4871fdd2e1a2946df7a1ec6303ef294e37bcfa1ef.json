{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isFunction } from '@polkadot/util';\nimport { firstObservable } from '../util/index.js';\nimport { callMethod, withSection } from './helpers.js';\nfunction parse(api, [hashes, proposals, votes]) {\n  return proposals.map((o, index) => ({\n    hash: api.registry.createType('Hash', hashes[index]),\n    proposal: o && o.isSome ? o.unwrap() : null,\n    votes: votes[index].unwrapOr(null)\n  }));\n}\nfunction _proposalsFrom(api, query, hashes) {\n  return (isFunction(query?.proposals) && hashes.length ? combineLatest([of(hashes),\n  // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n  // however we have had cases on Edgeware where the indices have moved around after an\n  // upgrade, which results in invalid on-chain data\n  query.proposalOf.multi(hashes).pipe(catchError(() => of(hashes.map(() => null)))), query.voting.multi(hashes)]) : of([[], [], []])).pipe(map(r => parse(api, r)));\n}\nexport function hasProposals(section) {\n  return withSection(section, query => () => of(isFunction(query?.proposals)));\n}\nexport function proposals(section) {\n  return withSection(section, (query, api) => () => api.derive[section].proposalHashes().pipe(switchMap(all => _proposalsFrom(api, query, all))));\n}\nexport function proposal(section) {\n  return withSection(section, (query, api) => hash => isFunction(query?.proposals) ? firstObservable(_proposalsFrom(api, query, [hash])) : of(null));\n}\nexport const proposalCount = /*#__PURE__*/callMethod('proposalCount', null);\nexport const proposalHashes = /*#__PURE__*/callMethod('proposals', []);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}