{"ast":null,"code":"import { Bytes } from '@polkadot/types-codec';\nimport { isFunction, isString, isU8a } from '@polkadot/util';\nimport { getSiName } from '../metadata/util/index.js';\nimport { unwrapStorageType } from '../util/index.js';\nconst HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\n/** @internal */\nfunction decodeStorageKey(value) {\n  if (isU8a(value) || !value || isString(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (isFunction(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    const [fn, args = []] = value;\n    if (!isFunction(fn)) {\n      throw new Error('Expected function input for key construction');\n    }\n    if (fn.meta && fn.meta.type.isMap) {\n      const map = fn.meta.type.asMap;\n      if (!Array.isArray(args) || args.length !== map.hashers.length) {\n        throw new Error(`Expected an array of ${map.hashers.length} values as params to a Map query`);\n      }\n    }\n    return {\n      key: fn(...args),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n  throw new Error(`Unable to convert input ${value} to StorageKey`);\n}\n/** @internal */\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  let offset = 32;\n  const count = hashers.length;\n  const result = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const [hasher, type] = hashers[i];\n    const [hashLen, canDecode] = HASHER_MAP[hasher.type];\n    const decoded = canDecode ? registry.createTypeUnsafe(getSiName(registry.lookup, type), [value.subarray(offset + hashLen)]) : registry.createTypeUnsafe('Raw', [value.subarray(offset, offset + hashLen)]);\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result[i] = decoded;\n  }\n  return result;\n}\n/** @internal */\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !meta.type.isMap) {\n    return [];\n  }\n  const {\n    hashers,\n    key\n  } = meta.type.asMap;\n  const keys = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;\n  return decodeHashers(registry, value, hashers.map((h, i) => [h, keys[i]]));\n}\n/** @internal */\nfunction getMeta(value) {\n  if (value instanceof StorageKey) {\n    return value.meta;\n  } else if (isFunction(value)) {\n    return value.meta;\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n    return fn.meta;\n  }\n  return undefined;\n}\n/** @internal */\nfunction getType(registry, value) {\n  if (value instanceof StorageKey) {\n    return value.outputType;\n  } else if (isFunction(value)) {\n    return unwrapStorageType(registry, value.meta.type);\n  } else if (Array.isArray(value)) {\n    const [fn] = value;\n    if (fn.meta) {\n      return unwrapStorageType(registry, fn.meta.type);\n    }\n  }\n  // If we have no type set, default to Raw\n  return 'Raw';\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\nexport class StorageKey extends Bytes {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  __internal__args;\n  __internal__meta;\n  __internal__outputType;\n  __internal__method;\n  __internal__section;\n  constructor(registry, value, override = {}) {\n    const {\n      key,\n      method,\n      section\n    } = decodeStorageKey(value);\n    super(registry, key);\n    this.__internal__outputType = getType(registry, value);\n    // decode the args (as applicable based on the key and the hashers, after all init)\n    this.setMeta(getMeta(value), override.section || section, override.method || method);\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map with decodable values)\n   */\n  get args() {\n    return this.__internal__args;\n  }\n  /**\n   * @description The metadata or `undefined` when not available\n   */\n  get meta() {\n    return this.__internal__meta;\n  }\n  /**\n   * @description The key method or `undefined` when not specified\n   */\n  get method() {\n    return this.__internal__method;\n  }\n  /**\n   * @description The output type\n   */\n  get outputType() {\n    return this.__internal__outputType;\n  }\n  /**\n   * @description The key section or `undefined` when not specified\n   */\n  get section() {\n    return this.__internal__section;\n  }\n  is(key) {\n    return key.section === this.section && key.method === this.method;\n  }\n  /**\n   * @description Sets the meta for this key\n   */\n  setMeta(meta, section, method) {\n    this.__internal__meta = meta;\n    this.__internal__method = method || this.__internal__method;\n    this.__internal__section = section || this.__internal__section;\n    if (meta) {\n      this.__internal__outputType = unwrapStorageType(this.registry, meta.type);\n    }\n    try {\n      this.__internal__args = decodeArgsFromMeta(this.registry, this.toU8a(true), meta);\n    } catch {\n      // ignore...\n    }\n    return this;\n  }\n  /**\n   * @description Returns the Human representation for this type\n   */\n  toHuman(_isExtended, disableAscii) {\n    return this.__internal__args.length ? this.__internal__args.map(a => a.toHuman(undefined, disableAscii)) : super.toHuman(undefined, disableAscii);\n  }\n  /**\n   * @description Returns the raw type for this\n   */\n  toRawType() {\n    return 'StorageKey';\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}