{"ast":null,"code":"import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode({\n  coder,\n  ipfs\n}, validate) {\n  return (value, ipfsCompat) => {\n    validate(value, ipfsCompat);\n    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);\n  };\n}\n/** @internal */\nexport function createEncode({\n  coder,\n  ipfs\n}) {\n  return (value, ipfsCompat) => {\n    const out = coder.encode(u8aToU8a(value));\n    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;\n  };\n}\n/** @internal */\nexport function createIs(validate) {\n  return (value, ipfsCompat) => {\n    try {\n      return validate(value, ipfsCompat);\n    } catch {\n      return false;\n    }\n  };\n}\n/** @internal */\nexport function createValidate({\n  chars,\n  ipfs,\n  type,\n  withPadding\n}) {\n  return (value, ipfsCompat) => {\n    if (typeof value !== 'string') {\n      throw new Error(`Expected ${type} string input`);\n    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {\n      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n    }\n    for (let i = ipfsCompat ? 1 : 0, count = value.length; i < count; i++) {\n      if (chars.includes(value[i])) {\n        // all ok, character found\n      } else if (withPadding && value[i] === '=') {\n        if (i === count - 1) {\n          // last character, everything ok\n        } else if (value[i + 1] === '=') {\n          // next one is also padding, sequence ok\n        } else {\n          throw new Error(`Invalid ${type} padding sequence \"${value[i]}${value[i + 1]}\" at index ${i}`);\n        }\n      } else {\n        throw new Error(`Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n      }\n    }\n    return true;\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}