{"ast":null,"code":"import { assertUnreachable } from '@polkadot/util';\nfunction convertType(key) {\n  return (registry, {\n    type\n  }) => registry.createType('Si1TypeDef', {\n    [key]: {\n      type: type.toNumber()\n    }\n  });\n}\nfunction convertArray(registry, {\n  len,\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Array: {\n      len,\n      type: type.toNumber()\n    }\n  });\n}\nfunction convertBitSequence(registry, {\n  bitOrderType,\n  bitStoreType\n}) {\n  return registry.createType('Si1TypeDef', {\n    BitSequence: {\n      bitOrderType: bitOrderType.toNumber(),\n      bitStoreType: bitStoreType.toNumber()\n    }\n  });\n}\nconst convertCompact = convertType('Compact');\nfunction convertComposite(registry, {\n  fields\n}) {\n  return registry.createType('Si1TypeDef', {\n    Composite: {\n      fields: convertFields(registry, fields)\n    }\n  });\n}\nfunction convertFields(registry, fields) {\n  return fields.map(({\n    docs,\n    name,\n    type,\n    typeName\n  }) => registry.createType('Si1Field', {\n    docs,\n    name,\n    type: type.toNumber(),\n    typeName\n  }));\n}\nfunction convertPhantom(registry, path) {\n  console.warn(`Converting phantom type ${path.map(p => p.toString()).join('::')} to empty tuple`);\n  return registry.createType('Si1TypeDef', {\n    Tuple: []\n  });\n}\nfunction convertPrimitive(registry, prim) {\n  return registry.createType('Si1TypeDef', {\n    Primitive: prim.toString()\n  });\n}\nconst convertSequence = convertType('Sequence');\nfunction convertTuple(registry, types) {\n  return registry.createType('Si1TypeDef', {\n    Tuple: types.map(t => t.toNumber())\n  });\n}\nfunction convertVariant(registry, {\n  variants\n}) {\n  return registry.createType('Si1TypeDef', {\n    Variant: {\n      variants: variants.map(({\n        discriminant,\n        docs,\n        fields,\n        name\n      }, index) => registry.createType('Si1Variant', {\n        docs,\n        fields: convertFields(registry, fields),\n        index: discriminant.isSome ? discriminant.unwrap().toNumber() : index,\n        name\n      }))\n    }\n  });\n}\nfunction convertDef(registry, {\n  def,\n  path\n}) {\n  let result;\n  switch (def.type) {\n    case 'Array':\n      result = convertArray(registry, def.asArray);\n      break;\n    case 'BitSequence':\n      result = convertBitSequence(registry, def.asBitSequence);\n      break;\n    case 'Compact':\n      result = convertCompact(registry, def.asCompact);\n      break;\n    case 'Composite':\n      result = convertComposite(registry, def.asComposite);\n      break;\n    case 'Phantom':\n      result = convertPhantom(registry, path);\n      break;\n    case 'Primitive':\n      result = convertPrimitive(registry, def.asPrimitive);\n      break;\n    case 'Sequence':\n      result = convertSequence(registry, def.asSequence);\n      break;\n    case 'Tuple':\n      result = convertTuple(registry, def.asTuple);\n      break;\n    case 'Variant':\n      result = convertVariant(registry, def.asVariant);\n      break;\n    default:\n      assertUnreachable(def.type);\n  }\n  return result;\n}\nexport function toV1(registry, types) {\n  return types.map((t, index) => registry.createType('PortableType', {\n    // offsets are +1 from v0\n    id: index + 1,\n    type: {\n      def: convertDef(registry, t),\n      docs: [],\n      params: t.params.map(p => registry.createType('Si1TypeParameter', {\n        type: p.toNumber()\n      })),\n      path: t.path.map(p => p.toString())\n    }\n  }));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}