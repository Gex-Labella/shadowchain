{"ast":null,"code":"import { Struct, U8aFixed } from '@polkadot/types-codec';\nimport { isHex, isObject, isU8a, objectSpread, u8aToU8a } from '@polkadot/util';\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  return meta.fields.reduce((result, {\n    name,\n    type\n  }, index) => {\n    result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);\n    return result;\n  }, {});\n}\n/** @internal */\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value;\n  // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex;\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = registry.firstCallIndex.slice();\n  callIndex.set(value.subarray(0, 2), 0);\n  // Find metadata with callIndex\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if (isU8a(value) || isHex(value)) {\n    return decodeCallViaU8a(registry, u8aToU8a(value), _meta);\n  } else if (isObject(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name GenericCallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\nexport class GenericCallIndex extends U8aFixed {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toHex();\n  }\n}\n/**\n * @name GenericCall\n * @description\n * Extrinsic function descriptor\n */\nexport class GenericCall extends Struct {\n  _meta;\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n    try {\n      super(registry, {\n        callIndex: GenericCallIndex,\n        // eslint-disable-next-line sort-keys\n        args: Struct.with(decoded.argsDef)\n      }, decoded);\n    } catch (error) {\n      let method = 'unknown.unknown';\n      try {\n        const c = registry.findMetaCall(decoded.callIndex);\n        method = `${c.section}.${c.method}`;\n      } catch {\n        // ignore\n      }\n      throw new Error(`Call: failed decoding ${method}:: ${error.message}`);\n    }\n    this._meta = decoded.meta;\n  }\n  /**\n   * @description The arguments for the function call\n   */\n  get args() {\n    return [...this.getT('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The argument entries\n   */\n  get argsEntries() {\n    return [...this.getT('args').entries()];\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n  get callIndex() {\n    return this.getT('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n  get data() {\n    return this.getT('args').toU8a();\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n  get method() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n  get section() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n  is(other) {\n    return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExpanded, disableAscii) {\n    let call;\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch {\n      // swallow\n    }\n    return objectSpread({\n      args: this.argsEntries.reduce((args, [n, a]) => objectSpread(args, {\n        [n]: a.toHuman(isExpanded, disableAscii)\n      }), {}),\n      method: call?.method,\n      section: call?.section\n    }, isExpanded && call ? {\n      docs: call.meta.docs.map(d => d.toString())\n    } : null);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Call';\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}