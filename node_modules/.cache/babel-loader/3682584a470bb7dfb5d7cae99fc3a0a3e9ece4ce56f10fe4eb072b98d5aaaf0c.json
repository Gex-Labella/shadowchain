{"ast":null,"code":"import { BigInt } from '@polkadot/x-bigint';\nimport { _0n, _1n } from './consts.js';\nimport { nToBigInt } from './toBigInt.js';\nconst DIV = BigInt(256);\nconst NEG_MASK = BigInt(0xff);\nfunction toU8a(value, isLe, isNegative) {\n  const arr = [];\n  const withSigned = isNegative && value < _0n;\n  if (withSigned) {\n    value = (value + _1n) * -_1n;\n  }\n  while (value !== _0n) {\n    const mod = value % DIV;\n    const val = Number(withSigned ? mod ^ NEG_MASK : mod);\n    if (isLe) {\n      arr.push(val);\n    } else {\n      arr.unshift(val);\n    }\n    value = (value - mod) / DIV;\n  }\n  return Uint8Array.from(arr);\n}\n/**\n * @name nToU8a\n * @summary Creates a Uint8Array object from a bigint.\n */\nexport function nToU8a(value, {\n  bitLength = -1,\n  isLe = true,\n  isNegative = false\n} = {}) {\n  const valueBi = nToBigInt(value);\n  if (valueBi === _0n) {\n    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(Math.ceil((bitLength || 0) / 8));\n  }\n  const u8a = toU8a(valueBi, isLe, isNegative);\n  if (bitLength === -1) {\n    return u8a;\n  }\n  const byteLength = Math.ceil((bitLength || 0) / 8);\n  const output = new Uint8Array(byteLength);\n  if (isNegative) {\n    output.fill(0xff);\n  }\n  output.set(u8a, isLe ? 0 : byteLength - u8a.length);\n  return output;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}