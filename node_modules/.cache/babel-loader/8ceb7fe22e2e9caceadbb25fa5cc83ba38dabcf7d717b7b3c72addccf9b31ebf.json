{"ast":null,"code":"import { identity, isFunction, isHex, isString, isU8a, stringify, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8a, mapToTypeMap, typesToConstructors, typeToConstructor } from '../utils/index.js';\n/** @internal */\nfunction decodeTuple(registry, result, value, Classes) {\n  if (Array.isArray(value)) {\n    const Types = Classes[0];\n    for (let i = 0, count = Types.length; i < count; i++) {\n      try {\n        const entry = value?.[i];\n        result[i] = entry instanceof Types[i] ? entry : new Types[i](registry, entry);\n      } catch (error) {\n        throw new Error(`Tuple: failed on ${i}:: ${error.message}`);\n      }\n    }\n    return [result, 0];\n  } else if (isHex(value)) {\n    return decodeU8a(registry, result, u8aToU8a(value), Classes);\n  } else if (!value || !result.length) {\n    const Types = Classes[0];\n    for (let i = 0, count = Types.length; i < count; i++) {\n      result[i] = new Types[i](registry);\n    }\n    return [result, 0];\n  }\n  throw new Error(`Expected array input to Tuple decoding, found ${typeof value}: ${stringify(value)}`);\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\nexport class Tuple extends AbstractArray {\n  __internal__Types;\n  constructor(registry, Types, value, {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    const Classes = definition || setDefinition(Array.isArray(Types) ? [typesToConstructors(registry, Types), []] : isFunction(Types) || isString(Types) ? [[typeToConstructor(registry, Types)], []] : mapToTypeMap(registry, Types));\n    super(registry, Classes[0].length);\n    this.initialU8aLength = (isU8a(value) ? decodeU8a(registry, this, value, Classes) : decodeTuple(registry, this, value, Classes))[1];\n    this.__internal__Types = Classes;\n  }\n  static with(Types) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Tuple {\n      constructor(registry, value) {\n        super(registry, Types, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    let total = 0;\n    for (let i = 0, count = this.length; i < count; i++) {\n      total += this[i].encodedLength;\n    }\n    return total;\n  }\n  /**\n   * @description The types definition of the tuple\n   */\n  get Types() {\n    return this.__internal__Types[1].length ? this.__internal__Types[1] : this.__internal__Types[0].map(T => new T(this.registry).toRawType());\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return {\n      inner: this.inspectInner()\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    const types = this.__internal__Types[0].map(T => this.registry.getClassName(T) || new T(this.registry).toRawType());\n    return `(${types.join(',')})`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    // Overwrite the default toString representation of Array.\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return u8aConcatStrict(this.toU8aInner(isBare));\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}