{"ast":null,"code":"import { combineLatest, map, of, switchMap } from 'rxjs';\nimport { BN, BN_ZERO, bnMax, bnMin, isFunction, objectSpread } from '@polkadot/util';\nimport { memo } from '../util/index.js';\nconst VESTING_ID = '0x76657374696e6720';\nfunction calcLocked(api, bestNumber, locks) {\n  let lockedBalance = api.registry.createType('Balance');\n  let lockedBreakdown = [];\n  let vestingLocked = api.registry.createType('Balance');\n  let allLocked = false;\n  if (Array.isArray(locks)) {\n    // only get the locks that are valid until passed the current block\n    lockedBreakdown = locks.filter(({\n      until\n    }) => !until || bestNumber && until.gt(bestNumber));\n    allLocked = lockedBreakdown.some(({\n      amount\n    }) => amount && amount.isMax());\n    vestingLocked = api.registry.createType('Balance', lockedBreakdown.filter(({\n      id\n    }) => id.eq(VESTING_ID)).reduce((result, {\n      amount\n    }) => result.iadd(amount), new BN(0)));\n    // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699\n    const notAll = lockedBreakdown.filter(({\n      amount\n    }) => amount && !amount.isMax());\n    if (notAll.length) {\n      lockedBalance = api.registry.createType('Balance', bnMax(...notAll.map(({\n        amount\n      }) => amount)));\n    }\n  }\n  return {\n    allLocked,\n    lockedBalance,\n    lockedBreakdown,\n    vestingLocked\n  };\n}\nfunction calcShared(api, bestNumber, data, locks) {\n  const {\n    allLocked,\n    lockedBalance,\n    lockedBreakdown,\n    vestingLocked\n  } = calcLocked(api, bestNumber, locks);\n  let transferable = null;\n  if (data?.frameSystemAccountInfo?.frozen) {\n    const {\n      frameSystemAccountInfo,\n      freeBalance,\n      reservedBalance\n    } = data;\n    const noFrozenReserved = frameSystemAccountInfo.frozen.isZero() && reservedBalance.isZero();\n    const ED = api.consts.balances.existentialDeposit;\n    const maybeED = noFrozenReserved ? new BN(0) : ED;\n    const frozenReserveDif = frameSystemAccountInfo.frozen.sub(reservedBalance);\n    transferable = api.registry.createType('Balance', allLocked ? 0 : freeBalance.sub(bnMax(maybeED, frozenReserveDif)));\n  }\n  return objectSpread({}, data, {\n    availableBalance: api.registry.createType('Balance', allLocked ? 0 : bnMax(new BN(0), data?.freeBalance ? data.freeBalance.sub(lockedBalance) : new BN(0))),\n    lockedBalance,\n    lockedBreakdown,\n    transferable,\n    vestingLocked\n  });\n}\nfunction calcVesting(bestNumber, shared, _vesting) {\n  // Calculate the vesting balances,\n  //  - offset = balance locked at startingBlock\n  //  - perBlock is the unlock amount\n  const vesting = _vesting || [];\n  const isVesting = !shared.vestingLocked.isZero();\n  const vestedBalances = vesting.map(({\n    locked,\n    perBlock,\n    startingBlock\n  }) => bestNumber.gt(startingBlock) ? bnMin(locked, perBlock.mul(bestNumber.sub(startingBlock))) : BN_ZERO);\n  const vestedBalance = vestedBalances.reduce((all, value) => all.iadd(value), new BN(0));\n  const vestingTotal = vesting.reduce((all, {\n    locked\n  }) => all.iadd(locked), new BN(0));\n  return {\n    isVesting,\n    vestedBalance,\n    vestedClaimable: isVesting ? shared.vestingLocked.sub(vestingTotal.sub(vestedBalance)) : BN_ZERO,\n    vesting: vesting.map(({\n      locked,\n      perBlock,\n      startingBlock\n    }, index) => ({\n      endBlock: locked.div(perBlock).iadd(startingBlock),\n      locked,\n      perBlock,\n      startingBlock,\n      vested: vestedBalances[index]\n    })).filter(({\n      locked\n    }) => !locked.isZero()),\n    vestingTotal\n  };\n}\nfunction calcBalances(api, result) {\n  const [data, [vesting, allLocks, namedReserves], bestNumber] = result;\n  const shared = calcShared(api, bestNumber, data, allLocks[0]);\n  return objectSpread(shared, calcVesting(bestNumber, shared, vesting), {\n    accountId: data.accountId,\n    accountNonce: data.accountNonce,\n    additional: allLocks.slice(1).map((l, index) => calcShared(api, bestNumber, data.additional[index], l)),\n    namedReserves\n  });\n}\nfunction queryOld(api, accountId) {\n  return combineLatest([api.query.balances.locks(accountId), api.query.balances['vesting'](accountId)]).pipe(map(([locks, optVesting]) => {\n    let vestingNew = null;\n    if (optVesting.isSome) {\n      const {\n        offset: locked,\n        perBlock,\n        startingBlock\n      } = optVesting.unwrap();\n      vestingNew = api.registry.createType('VestingInfo', {\n        locked,\n        perBlock,\n        startingBlock\n      });\n    }\n    return [vestingNew ? [vestingNew] : null, [locks], []];\n  }));\n}\nconst isNonNullable = nullable => !!nullable;\nfunction createCalls(calls) {\n  return [calls.map(c => !c), calls.filter(isNonNullable)];\n}\nfunction queryCurrent(api, accountId, balanceInstances = ['balances']) {\n  const [lockEmpty, lockQueries] = createCalls(balanceInstances.map(m => api.derive[m]?.customLocks || api.query[m]?.locks));\n  const [reserveEmpty, reserveQueries] = createCalls(balanceInstances.map(m => api.query[m]?.reserves));\n  return combineLatest([api.query.vesting?.vesting ? api.query.vesting.vesting(accountId) : of(api.registry.createType('Option<VestingInfo>')), lockQueries.length ? combineLatest(lockQueries.map(c => c(accountId))) : of([]), reserveQueries.length ? combineLatest(reserveQueries.map(c => c(accountId))) : of([])]).pipe(map(([opt, locks, reserves]) => {\n    let offsetLock = -1;\n    let offsetReserve = -1;\n    const vesting = opt.unwrapOr(null);\n    return [vesting ? Array.isArray(vesting) ? vesting : [vesting] : null, lockEmpty.map(e => e ? api.registry.createType('Vec<BalanceLock>') : locks[++offsetLock]), reserveEmpty.map(e => e ? api.registry.createType('Vec<PalletBalancesReserveData>') : reserves[++offsetReserve])];\n  }));\n}\n/**\n * @name all\n * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.\n * @returns An object containing the results of various balance queries\n * @example\n * <BR>\n *\n * ```javascript\n * const ALICE = 'F7Hs';\n *\n * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {\n *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);\n * });\n * ```\n */\nexport function all(instanceId, api) {\n  const balanceInstances = api.registry.getModuleInstances(api.runtimeVersion.specName, 'balances');\n  return memo(instanceId, address => combineLatest([api.derive.balances.account(address), isFunction(api.query.system?.account) || isFunction(api.query.balances?.account) ? queryCurrent(api, address, balanceInstances) : queryOld(api, address)]).pipe(switchMap(([account, locks]) => combineLatest([of(account), of(locks), api.derive.chain.bestNumber()])), map(result => calcBalances(api, result))));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}