{"ast":null,"code":"import { catchError, combineLatest, map, of, switchMap } from 'rxjs';\nimport { isNumber, isUndefined } from '@polkadot/util';\nimport { unwrapBlockNumber } from '../util/index.js';\nimport { FALLBACK_MAX_HASH_COUNT, FALLBACK_PERIOD, MAX_FINALITY_LAG, MORTAL_PERIOD } from './constants.js';\nfunction latestNonce(api, address) {\n  return api.derive.balances.account(address).pipe(map(({\n    accountNonce\n  }) => accountNonce));\n}\nfunction nextNonce(api, address) {\n  if (api.call.accountNonceApi) {\n    return api.call.accountNonceApi.accountNonce(address);\n  } else {\n    return api.rpc.system?.accountNextIndex ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);\n  }\n}\nfunction signingHeader(api) {\n  return combineLatest([api.rpc.chain.getHeader().pipe(switchMap(header =>\n  // check for chains at genesis (until block 1 is produced, e.g. 6s), since\n  // we do need to allow transactions at chain start (also dev/seal chains)\n  header.parentHash.isEmpty ? of(header)\n  // in the case of the current block, we use the parent to minimize the\n  // impact of forks on the system, but not completely remove it\n  : api.rpc.chain.getHeader(header.parentHash).pipe(catchError(() => of(header))))), api.rpc.chain.getFinalizedHead().pipe(switchMap(hash => api.rpc.chain.getHeader(hash).pipe(catchError(() => of(null)))))]).pipe(map(([current, finalized]) =>\n  // determine the hash to use, current when lag > max, else finalized\n  !finalized || unwrapBlockNumber(current).sub(unwrapBlockNumber(finalized)).gt(MAX_FINALITY_LAG) ? current : finalized));\n}\nfunction babeOrAuraPeriod(api) {\n  const period = api.consts.babe?.expectedBlockTime ||\n  // this will be present ones https://github.com/paritytech/polkadot-sdk/pull/3732 is merged\n  api.consts['aura']?.slotDuration || api.consts.timestamp?.minimumPeriod.muln(2);\n  return period && period.isZero && !period.isZero() ? period : undefined;\n}\nexport function signingInfo(_instanceId, api) {\n  // no memo, we want to do this fresh on each run\n  return (address, nonce, era) => combineLatest([\n  // retrieve nonce if none was specified\n  isUndefined(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : of(api.registry.createType('Index', nonce)),\n  // if no era (create) or era > 0 (mortal), do block retrieval\n  isUndefined(era) || isNumber(era) && era > 0 ? signingHeader(api) : of(null)]).pipe(map(([nonce, header]) => ({\n    header,\n    mortalLength: Math.min(api.consts.system?.blockHashCount?.toNumber() || FALLBACK_MAX_HASH_COUNT, MORTAL_PERIOD.div(babeOrAuraPeriod(api) || FALLBACK_PERIOD).iadd(MAX_FINALITY_LAG).toNumber()),\n    nonce\n  })));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}