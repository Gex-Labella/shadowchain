{"ast":null,"code":"import { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, noop, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsHex, cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst SUPPORTED_METADATA_VERSIONS = [15, 14];\nconst l = logger('api/init');\nfunction textToString(t) {\n  return t.toString();\n}\nexport class Init extends Decorate {\n  __internal__atLast = null;\n  __internal__healthTimer = null;\n  __internal__registries = [];\n  __internal__updateSub = null;\n  __internal__waitingRegistries = {};\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    // all injected types added to the registry for overrides\n    this.registry.setKnownTypes(options);\n    // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      this.__internal__registries = options.source.__internal__registries;\n    }\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n    this._rx.signer = options.signer;\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n    this._rpcCore.setResolveBlockHash(blockNumber => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', () => this.__internal__onProviderDisconnect());\n      this._rpcCore.provider.on('error', e => this.__internal__onProviderError(e));\n      this._rpcCore.provider.on('connected', () => this.__internal__onProviderConnect());\n    } else if (!this._options.noInitWarn) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    }\n    // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n    if (this._rpcCore.provider.isConnected) {\n      this.__internal__onProviderConnect().catch(noop);\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.clearCache();\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName));\n    // for bundled types, pull through the aliases defined\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n    registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions), this._options.noInitWarn);\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n  _getDefaultRegistry() {\n    return assertReturn(this.__internal__registries.find(({\n      isDefault\n    }) => isDefault), 'Initialization error, cannot find the default registry');\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n  async at(blockHash, knownVersion) {\n    const u8aHash = u8aToU8a(blockHash);\n    const u8aHex = u8aToHex(u8aHash);\n    const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n    if (!this.__internal__atLast || this.__internal__atLast[0] !== u8aHex) {\n      // always create a new decoration - since we are pointing to a specific hash, this\n      // means that all queries needs to use that hash (not a previous one already existing)\n      this.__internal__atLast = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];\n    }\n    return this.__internal__atLast[1];\n  }\n  async _createBlockRegistry(blockHash, header, version) {\n    const registry = new TypeRegistry(blockHash);\n    const metadata = await this._retrieveMetadata(version.apis, header.parentHash, registry);\n    const runtimeChain = this._runtimeChain;\n    if (!runtimeChain) {\n      throw new Error('Invalid initializion order, runtimeChain is not available');\n    }\n    this._initRegistry(registry, runtimeChain, version, metadata);\n    // add our new registry\n    const result = {\n      counter: 0,\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      runtimeVersion: version\n    };\n    this.__internal__registries.push(result);\n    return result;\n  }\n  _cacheBlockRegistryProgress(key, creator) {\n    // look for waiting resolves\n    let waiting = this.__internal__waitingRegistries[key];\n    if (isUndefined(waiting)) {\n      // nothing waiting, construct new\n      waiting = this.__internal__waitingRegistries[key] = new Promise((resolve, reject) => {\n        creator().then(registry => {\n          delete this.__internal__waitingRegistries[key];\n          resolve(registry);\n        }).catch(error => {\n          delete this.__internal__waitingRegistries[key];\n          reject(error);\n        });\n      });\n    }\n    return waiting;\n  }\n  _getBlockRegistryViaVersion(blockHash, version) {\n    if (version) {\n      // check for pre-existing registries. We also check specName, e.g. it\n      // could be changed like in Westmint with upgrade from shell -> westmint\n      const existingViaVersion = this.__internal__registries.find(({\n        runtimeVersion: {\n          specName,\n          specVersion\n        }\n      }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));\n      if (existingViaVersion) {\n        existingViaVersion.counter++;\n        existingViaVersion.lastBlockHash = blockHash;\n        return existingViaVersion;\n      }\n    }\n    return null;\n  }\n  async _getBlockRegistryViaHash(blockHash) {\n    // ensure we have everything required\n    if (!this._genesisHash || !this._runtimeVersion) {\n      throw new Error('Cannot retrieve data on an uninitialized chain');\n    }\n    // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n    if (header.parentHash.isEmpty) {\n      throw new Error('Unable to retrieve header and parent from supplied hash');\n    }\n    // get the runtime version, either on-chain or via an known upgrade history\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      apis: firstVersion.apis,\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n    return (\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, version) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)))\n    );\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n  async getBlockRegistry(blockHash, knownVersion) {\n    return (\n      // try to find via blockHash\n      this.__internal__registries.find(({\n        lastBlockHash\n      }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) ||\n      // try to find via version\n      this._getBlockRegistryViaVersion(blockHash, knownVersion) || (\n      // return new or in-flight result\n      await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)))\n    );\n  }\n  async _loadMeta() {\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      // on re-connection only re-subscribe to chain updates if we are not a clone\n      if (!this._options.source) {\n        this._subscribeUpdates();\n      }\n      return true;\n    }\n    this._unsubscribeUpdates();\n    // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n    [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n    const sections = Object.keys(source.rpc);\n    const rpcs = [];\n    for (let s = 0, scount = sections.length; s < scount; s++) {\n      const section = sections[s];\n      const methods = Object.keys(source.rpc[section]);\n      for (let m = 0, mcount = methods.length; m < mcount; m++) {\n        rpcs.push(`${section}_${methods[m]}`);\n      }\n    }\n    this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n  // subscribe to metadata updates, inject the types on changes\n  _subscribeUpdates() {\n    if (this.__internal__updateSub || !this.hasSubscriptions) {\n      return;\n    }\n    this.__internal__updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version =>\n    // only retrieve the metadata when the on-chain version has been changed\n    this._runtimeVersion?.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n      l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n      this._runtimeMetadata = metadata;\n      this._runtimeVersion = version;\n      this._rx.runtimeVersion = version;\n      // update the default registry version\n      const thisRegistry = this._getDefaultRegistry();\n      const runtimeChain = this._runtimeChain;\n      if (!runtimeChain) {\n        throw new Error('Invalid initializion order, runtimeChain is not available');\n      }\n      // setup the data as per the current versions\n      thisRegistry.metadata = metadata;\n      thisRegistry.runtimeVersion = version;\n      this._initRegistry(this.registry, runtimeChain, version, metadata);\n      this._injectMetadata(thisRegistry, true);\n      return true;\n    })))).subscribe();\n  }\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods())]);\n    // set our chain version & genesisHash as returned\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion;\n    // retrieve metadata, either from chain  or as pass-in via options\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = optMetadata?.[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await this._retrieveMetadata(runtimeVersion.apis);\n    // initializes the registry & RPC\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n    this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n    this._subscribeUpdates();\n    // setup the initial registry, when we have none\n    if (!this.__internal__registries.length) {\n      this.__internal__registries.push({\n        counter: 0,\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        runtimeVersion\n      });\n    }\n    // get unique types & validate\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n  _initFromMeta(metadata) {\n    const runtimeVersion = this._runtimeVersion;\n    if (!runtimeVersion) {\n      throw new Error('Invalid initializion order, runtimeVersion is not available');\n    }\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = runtimeVersion;\n    // inject metadata and adjust the types as detected\n    this._injectMetadata(this._getDefaultRegistry(), true);\n    // derive is last, since it uses the decorated rx\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n  /**\n   * @internal\n   *\n   * Tries to use runtime api calls to retrieve metadata. This ensures the api initializes with the latest metadata.\n   * If the runtime call is not there it will use the rpc method.\n   */\n  async _retrieveMetadata(apis, at, registry) {\n    let metadataVersion = null;\n    const metadataApi = apis.find(([a]) => a.eq(blake2AsHex('Metadata', 64)));\n    const typeRegistry = registry || this.registry;\n    // This chain does not have support for the metadataApi, or does not have the required version.\n    if (!metadataApi || metadataApi[1].toNumber() < 2) {\n      l.warn('MetadataApi not available, rpc::state::get_metadata will be used.');\n      return at ? new Metadata(typeRegistry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(at))) : await firstValueFrom(this._rpcCore.state.getMetadata());\n    }\n    try {\n      const metadataVersionsAsBytes = at ? await firstValueFrom(this._rpcCore.state.call.raw('Metadata_metadata_versions', '0x', at)) : await firstValueFrom(this._rpcCore.state.call('Metadata_metadata_versions', '0x'));\n      const versions = typeRegistry.createType('Vec<u32>', metadataVersionsAsBytes);\n      metadataVersion = versions.reduce((largest, current) => current.gt(largest) ? current : largest);\n    } catch (e) {\n      l.debug(e.message);\n      l.warn('error with state_call::Metadata_metadata_versions, rpc::state::get_metadata will be used');\n    }\n    // When the metadata version does not align with the latest supported versions we ensure not to call the metadata runtime call.\n    // I noticed on some previous runtimes that have support for `Metadata_metadata_at_version` that very irregular versions were being returned.\n    // This was evident with runtime 1000000 - it return a very large number. This ensures we always stick within what is supported.\n    if (metadataVersion && !SUPPORTED_METADATA_VERSIONS.includes(metadataVersion.toNumber())) {\n      metadataVersion = null;\n    }\n    if (metadataVersion) {\n      try {\n        const metadataBytes = at ? await firstValueFrom(this._rpcCore.state.call.raw('Metadata_metadata_at_version', u8aToHex(metadataVersion.toU8a()), at)) : await firstValueFrom(this._rpcCore.state.call('Metadata_metadata_at_version', u8aToHex(metadataVersion.toU8a())));\n        // When the metadata is called with `at` it is required to use `.raw`. Therefore since the length prefix is not present the\n        // need to create a `Raw` type is necessary before creating the `OpaqueMetadata` type or else there will be a magic number\n        // mismatch\n        const rawMeta = at ? typeRegistry.createType('Raw', metadataBytes).toU8a() : metadataBytes;\n        const opaqueMetadata = typeRegistry.createType('Option<OpaqueMetadata>', rawMeta).unwrapOr(null);\n        if (opaqueMetadata) {\n          return new Metadata(typeRegistry, opaqueMetadata.toHex());\n        }\n      } catch (e) {\n        l.debug(e.message);\n        l.warn('error with state_call::Metadata_metadata_at_version, rpc::state::get_metadata will be used');\n      }\n    }\n    return at ? new Metadata(typeRegistry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(at))) : await firstValueFrom(this._rpcCore.state.getMetadata());\n  }\n  _subscribeHealth() {\n    this._unsubscribeHealth();\n    // Only enable the health keepalive on WS, not needed on HTTP\n    this.__internal__healthTimer = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health.raw()).catch(noop);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n  _unsubscribeHealth() {\n    if (this.__internal__healthTimer) {\n      clearInterval(this.__internal__healthTimer);\n      this.__internal__healthTimer = null;\n    }\n  }\n  _unsubscribeUpdates() {\n    if (this.__internal__updateSub) {\n      this.__internal__updateSub.unsubscribe();\n      this.__internal__updateSub = null;\n    }\n  }\n  _unsubscribe() {\n    this._unsubscribeHealth();\n    this._unsubscribeUpdates();\n  }\n  async __internal__onProviderConnect() {\n    this._isConnected.next(true);\n    this.emit('connected');\n    try {\n      const cryptoReady = this._options.initWasm === false ? true : await cryptoWaitReady();\n      const hasMeta = await this._loadMeta();\n      this._subscribeHealth();\n      if (hasMeta && !this._isReady && cryptoReady) {\n        this._isReady = true;\n        this.emit('ready', this);\n      }\n    } catch (_error) {\n      const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n      l.error(error);\n      this.emit('error', error);\n    }\n  }\n  __internal__onProviderDisconnect() {\n    this._isConnected.next(false);\n    this._unsubscribe();\n    this.emit('disconnected');\n  }\n  __internal__onProviderError(error) {\n    this.emit('error', error);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}