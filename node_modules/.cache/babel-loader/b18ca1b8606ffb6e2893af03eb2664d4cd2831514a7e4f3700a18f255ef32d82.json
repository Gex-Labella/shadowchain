{"ast":null,"code":"import { AbstractBase } from '@polkadot/types-codec';\nimport { hexToU8a, isHex, u8aToHex } from '@polkadot/util';\nimport { DEFAULT_VERSION } from './constants.js';\nconst VERSIONS = ['ExtrinsicPayloadUnknown',\n// v0 is unknown\n'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadV4'];\n/** @internal */\nfunction decodeExtrinsicPayload(registry, value, version = DEFAULT_VERSION) {\n  if (value instanceof GenericExtrinsicPayload) {\n    return value.unwrap();\n  }\n  /**\n   * HACK: In order to change the assetId from `number | object` to HexString (While maintaining the true type ie Option<TAssetConversion>),\n   * to allow for easier generalization of the SignerPayloadJSON interface the below check is necessary. The ExtrinsicPayloadV4 class does not like\n   * a value passed in as an Option, and can't decode it properly. Therefore, we ensure to convert the following below, and then pass the option as a unwrapped\n   * JSON value.\n   *\n   * ref: https://github.com/polkadot-js/api/pull/5968\n   * ref: https://github.com/polkadot-js/api/pull/5967\n   */\n  if (value && value.assetId && isHex(value.assetId)) {\n    const adjustedPayload = {\n      ...value,\n      assetId: registry.createType('TAssetConversion', hexToU8a(value.assetId)).toJSON()\n    };\n    return registry.createTypeUnsafe(VERSIONS[version] || VERSIONS[0], [adjustedPayload, {\n      version\n    }]);\n  }\n  return registry.createTypeUnsafe(VERSIONS[version] || VERSIONS[0], [value, {\n    version\n  }]);\n}\n/**\n * @name GenericExtrinsicPayload\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based\n * on the contents included\n */\nexport class GenericExtrinsicPayload extends AbstractBase {\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, decodeExtrinsicPayload(registry, value, version));\n  }\n  /**\n   * @description The block [[BlockHash]] the signature applies to (mortal/immortal)\n   */\n  get blockHash() {\n    return this.inner.blockHash;\n  }\n  /**\n   * @description The [[ExtrinsicEra]]\n   */\n  get era() {\n    return this.inner.era;\n  }\n  /**\n   * @description The genesis block [[BlockHash]] the signature applies to\n   */\n  get genesisHash() {\n    // NOTE only v3+\n    return this.inner.genesisHash || this.registry.createTypeUnsafe('Hash', []);\n  }\n  /**\n   * @description The [[Bytes]] contained in the payload\n   */\n  get method() {\n    return this.inner.method;\n  }\n  /**\n   * @description The [[Index]]\n   */\n  get nonce() {\n    return this.inner.nonce;\n  }\n  /**\n   * @description The specVersion as a [[u32]] for this payload\n   */\n  get specVersion() {\n    // NOTE only v3+\n    return this.inner.specVersion || this.registry.createTypeUnsafe('u32', []);\n  }\n  /**\n   * @description The [[Balance]]\n   */\n  get tip() {\n    // NOTE from v2+\n    return this.inner.tip || this.registry.createTypeUnsafe('Compact<Balance>', []);\n  }\n  /**\n   * @description The transaction version as a [[u32]] for this payload\n   */\n  get transactionVersion() {\n    // NOTE only v4+\n    return this.inner.transactionVersion || this.registry.createTypeUnsafe('u32', []);\n  }\n  /**\n   * @description The (optional) asset id as a [[u32]] or [[MultiLocation]] for this payload\n   */\n  get assetId() {\n    return this.inner.assetId;\n  }\n  /**\n   * @description The (optional) [[Hash]] of the genesis metadata for this payload\n   */\n  get metadataHash() {\n    return this.inner.metadataHash;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return this.inner.eq(other);\n  }\n  /**\n   * @description Sign the payload with the keypair\n   */\n  sign(signerPair) {\n    const signature = this.inner.sign(signerPair);\n    // This is extensible, so we could quite readily extend to send back extra\n    // information, such as for instance the payload, i.e. `payload: this.toHex()`\n    // For the case here we sign via the extrinsic, we ignore the return, so generally\n    // this is applicable for external signing\n    return {\n      signature: u8aToHex(signature)\n    };\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    return this.inner.toHuman(isExtended, disableAscii);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'ExtrinsicPayload';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns a serialized u8a form\n   */\n  toU8a(isBare) {\n    // call our parent, with only the method stripped\n    return super.toU8a(isBare ? {\n      method: true\n    } : false);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}