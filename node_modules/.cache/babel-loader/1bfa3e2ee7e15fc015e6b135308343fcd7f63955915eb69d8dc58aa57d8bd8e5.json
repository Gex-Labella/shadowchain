{"ast":null,"code":"import { Enum, Struct } from '@polkadot/types-codec';\nimport { objectSpread } from '@polkadot/util';\nimport { sign } from '../util.js';\n/**\n * @name GenericExtrinsicPayloadV4\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is\n * variable length based on the contents included\n */\nexport class GenericExtrinsicPayloadV4 extends Struct {\n  __internal__signOptions;\n  constructor(registry, value) {\n    super(registry, objectSpread({\n      method: 'Bytes'\n    }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value);\n    // Do detection for the type of extrinsic, in the case of MultiSignature\n    // this is an enum, in the case of AnySignature, this is a Hash only\n    // (which may be 64 or 65 bytes)\n    this.__internal__signOptions = {\n      withType: registry.createTypeUnsafe('ExtrinsicSignature', []) instanceof Enum\n    };\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    return super.inspect({\n      method: true\n    });\n  }\n  /**\n   * @description The block [[BlockHash]] the signature applies to (mortal/immortal)\n   */\n  get blockHash() {\n    return this.getT('blockHash');\n  }\n  /**\n   * @description The [[ExtrinsicEra]]\n   */\n  get era() {\n    return this.getT('era');\n  }\n  /**\n   * @description The genesis [[BlockHash]] the signature applies to (mortal/immortal)\n   */\n  get genesisHash() {\n    return this.getT('genesisHash');\n  }\n  /**\n   * @description The [[Bytes]] contained in the payload\n   */\n  get method() {\n    return this.getT('method');\n  }\n  /**\n   * @description The [[Index]]\n   */\n  get nonce() {\n    return this.getT('nonce');\n  }\n  /**\n   * @description The specVersion for this signature\n   */\n  get specVersion() {\n    return this.getT('specVersion');\n  }\n  /**\n   * @description The tip [[Balance]]\n   */\n  get tip() {\n    return this.getT('tip');\n  }\n  /**\n   * @description The transactionVersion for this signature\n   */\n  get transactionVersion() {\n    return this.getT('transactionVersion');\n  }\n  /**\n   * @description The (optional) asset id for this signature for chains that support transaction fees in assets\n   */\n  get assetId() {\n    return this.getT('assetId');\n  }\n  /**\n   * @description The (optional) asset id for this signature for chains that support transaction fees in assets\n   */\n  get metadataHash() {\n    return this.getT('metadataHash');\n  }\n  /**\n   * @description Sign the payload with the keypair\n   */\n  sign(signerPair) {\n    // NOTE The `toU8a({ method: true })` argument is absolutely critical, we\n    // don't want the method (Bytes) to have the length prefix included. This\n    // means that the data-as-signed is un-decodable, but is also doesn't need\n    // the extra information, only the pure data (and is not decoded) ...\n    // The same applies to V1..V3, if we have a V5, carry this comment\n    return sign(this.registry, signerPair, this.toU8a({\n      method: true\n    }), this.__internal__signOptions);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}