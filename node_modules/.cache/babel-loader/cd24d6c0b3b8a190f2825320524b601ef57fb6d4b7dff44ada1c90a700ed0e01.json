{"ast":null,"code":"import { BN, bnSqrt, isHex, isString, isU8a, objectSpread, stringToHex, u8aToHex } from '@polkadot/util';\nfunction isOldInfo(info) {\n  return !!info.proposalHash;\n}\nfunction isCurrentStatus(status) {\n  return !!status.tally;\n}\nexport function compareRationals(n1, d1, n2, d2) {\n  while (true) {\n    const q1 = n1.div(d1);\n    const q2 = n2.div(d2);\n    if (q1.lt(q2)) {\n      return true;\n    } else if (q2.lt(q1)) {\n      return false;\n    }\n    const r1 = n1.mod(d1);\n    const r2 = n2.mod(d2);\n    if (r2.isZero()) {\n      return false;\n    } else if (r1.isZero()) {\n      return true;\n    }\n    n1 = d2;\n    n2 = d1;\n    d1 = r2;\n    d2 = r1;\n  }\n}\nfunction calcPassingOther(threshold, sqrtElectorate, {\n  votedAye,\n  votedNay,\n  votedTotal\n}) {\n  const sqrtVoters = bnSqrt(votedTotal);\n  return sqrtVoters.isZero() ? false : threshold.isSuperMajorityApprove ? compareRationals(votedNay, sqrtVoters, votedAye, sqrtElectorate) : compareRationals(votedNay, sqrtElectorate, votedAye, sqrtVoters);\n}\nexport function calcPassing(threshold, sqrtElectorate, state) {\n  return threshold.isSimpleMajority ? state.votedAye.gt(state.votedNay) : calcPassingOther(threshold, sqrtElectorate, state);\n}\nfunction calcVotesPrev(votesFor) {\n  return votesFor.reduce((state, derived) => {\n    const {\n      balance,\n      vote\n    } = derived;\n    const isDefault = vote.conviction.index === 0;\n    const counted = balance.muln(isDefault ? 1 : vote.conviction.index).divn(isDefault ? 10 : 1);\n    if (vote.isAye) {\n      state.allAye.push(derived);\n      state.voteCountAye++;\n      state.votedAye.iadd(counted);\n    } else {\n      state.allNay.push(derived);\n      state.voteCountNay++;\n      state.votedNay.iadd(counted);\n    }\n    state.voteCount++;\n    state.votedTotal.iadd(counted);\n    return state;\n  }, {\n    allAye: [],\n    allNay: [],\n    voteCount: 0,\n    voteCountAye: 0,\n    voteCountNay: 0,\n    votedAye: new BN(0),\n    votedNay: new BN(0),\n    votedTotal: new BN(0)\n  });\n}\nfunction calcVotesCurrent(tally, votes) {\n  const allAye = [];\n  const allNay = [];\n  votes.forEach(derived => {\n    if (derived.vote.isAye) {\n      allAye.push(derived);\n    } else {\n      allNay.push(derived);\n    }\n  });\n  return {\n    allAye,\n    allNay,\n    voteCount: allAye.length + allNay.length,\n    voteCountAye: allAye.length,\n    voteCountNay: allNay.length,\n    votedAye: tally.ayes,\n    votedNay: tally.nays,\n    votedTotal: tally.turnout\n  };\n}\nexport function calcVotes(sqrtElectorate, referendum, votes) {\n  const state = isCurrentStatus(referendum.status) ? calcVotesCurrent(referendum.status.tally, votes) : calcVotesPrev(votes);\n  return objectSpread({}, state, {\n    isPassing: calcPassing(referendum.status.threshold, sqrtElectorate, state),\n    votes\n  });\n}\nexport function getStatus(info) {\n  if (info.isNone) {\n    return null;\n  }\n  const unwrapped = info.unwrap();\n  return isOldInfo(unwrapped) ? unwrapped : unwrapped.isOngoing ? unwrapped.asOngoing\n  // done, we don't include it here... only currently active\n  : null;\n}\nexport function getImageHashBounded(hash) {\n  return hash.isLegacy ? hash.asLegacy.hash_.toHex() : hash.isLookup ? hash.asLookup.hash_.toHex()\n  // for inline, use the actual Bytes hash\n  : hash.isInline ? hash.asInline.hash.toHex() : isString(hash) ? isHex(hash) ? hash : stringToHex(hash) : isU8a(hash) ? u8aToHex(hash) : hash.toHex();\n}\nexport function getImageHash(status) {\n  return getImageHashBounded(status.proposal || status.proposalHash);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}