{"ast":null,"code":"import { Struct } from '@polkadot/types-codec';\nimport { isU8a, isUndefined, objectProperties, objectSpread, stringify, u8aToHex } from '@polkadot/util';\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants.js';\nimport { GenericExtrinsicPayloadV4 } from './ExtrinsicPayload.js';\nconst FAKE_SIGNATURE = new Uint8Array(256).fill(1);\nfunction toAddress(registry, address) {\n  return registry.createTypeUnsafe('Address', [isU8a(address) ? u8aToHex(address) : address]);\n}\n/**\n * @name GenericExtrinsicSignatureV4\n * @description\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\n */\nexport class GenericExtrinsicSignatureV4 extends Struct {\n  __internal__signKeys;\n  constructor(registry, value, {\n    isSigned\n  } = {}) {\n    const signTypes = registry.getSignedExtensionTypes();\n    super(registry, objectSpread(\n    // eslint-disable-next-line sort-keys\n    {\n      signer: 'Address',\n      signature: 'ExtrinsicSignature'\n    }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));\n    this.__internal__signKeys = Object.keys(signTypes);\n    objectProperties(this, this.__internal__signKeys, k => this.get(k));\n  }\n  /** @internal */\n  static decodeExtrinsicSignature(value, isSigned = false) {\n    if (!value) {\n      return EMPTY_U8A;\n    } else if (value instanceof GenericExtrinsicSignatureV4) {\n      return value;\n    }\n    return isSigned ? value : EMPTY_U8A;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.isSigned ? super.encodedLength : 0;\n  }\n  /**\n   * @description `true` if the signature is valid\n   */\n  get isSigned() {\n    return !this.signature.isEmpty;\n  }\n  /**\n   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\n   */\n  get era() {\n    return this.getT('era');\n  }\n  /**\n   * @description The [[Index]] for the signature\n   */\n  get nonce() {\n    return this.getT('nonce');\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n  get signature() {\n    // the second case here is when we don't have an enum signature, treat as raw\n    return this.multiSignature.value || this.multiSignature;\n  }\n  /**\n   * @description The raw [[ExtrinsicSignature]]\n   */\n  get multiSignature() {\n    return this.getT('signature');\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n  get signer() {\n    return this.getT('signer');\n  }\n  /**\n   * @description The [[Balance]] tip\n   */\n  get tip() {\n    return this.getT('tip');\n  }\n  /**\n   * @description The [[u32]] or [[MultiLocation]] assetId\n   */\n  get assetId() {\n    return this.getT('assetId');\n  }\n  /**\n   * @description the [[u32]] mode\n   */\n  get mode() {\n    return this.getT('mode');\n  }\n  /**\n   * @description The [[Hash]] for the metadata\n   */\n  get metadataHash() {\n    return this.getT('metadataHash');\n  }\n  _injectSignature(signer, signature, payload) {\n    // use the fields exposed to guide the getters\n    for (let i = 0, count = this.__internal__signKeys.length; i < count; i++) {\n      const k = this.__internal__signKeys[i];\n      const v = payload.get(k);\n      if (!isUndefined(v)) {\n        this.set(k, v);\n      }\n    }\n    // additional fields (exposed in struct itself)\n    this.set('signer', signer);\n    this.set('signature', signature);\n    return this;\n  }\n  /**\n   * @description Adds a raw signature\n   */\n  addSignature(signer, signature, payload) {\n    return this._injectSignature(toAddress(this.registry, signer), this.registry.createTypeUnsafe('ExtrinsicSignature', [signature]), new GenericExtrinsicPayloadV4(this.registry, payload));\n  }\n  /**\n   * @description Creates a payload from the supplied options\n   */\n  createPayload(method, options) {\n    const {\n      era,\n      runtimeVersion: {\n        specVersion,\n        transactionVersion\n      }\n    } = options;\n    return new GenericExtrinsicPayloadV4(this.registry, objectSpread({}, options, {\n      era: era || IMMORTAL_ERA,\n      method: method.toHex(),\n      specVersion,\n      transactionVersion\n    }));\n  }\n  /**\n   * @description Generate a payload and applies the signature from a keypair\n   */\n  sign(method, account, options) {\n    if (!account?.addressRaw) {\n      throw new Error(`Expected a valid keypair for signing, found ${stringify(account)}`);\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, account.addressRaw), this.registry.createTypeUnsafe('ExtrinsicSignature', [payload.sign(account)]), payload);\n  }\n  /**\n   * @description Generate a payload and applies a fake signature\n   */\n  signFake(method, address, options) {\n    if (!address) {\n      throw new Error(`Expected a valid address for signing, found ${stringify(address)}`);\n    }\n    const payload = this.createPayload(method, options);\n    return this._injectSignature(toAddress(this.registry, address), this.registry.createTypeUnsafe('ExtrinsicSignature', [FAKE_SIGNATURE]), payload);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}