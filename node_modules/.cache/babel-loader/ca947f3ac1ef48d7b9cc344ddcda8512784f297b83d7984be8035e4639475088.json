{"ast":null,"code":"import { AbstractBase } from '@polkadot/types-codec';\nimport { compactAddLength, compactFromU8a, compactToU8a, isHex, isU8a, objectProperty, objectSpread, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { EXTRINSIC_VERSION as LATEST_EXTRINSIC_VERSION } from './v4/Extrinsic.js';\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from './constants.js';\nconst VERSIONS = ['ExtrinsicUnknown',\n// v0 is unknown\n'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];\nexport { LATEST_EXTRINSIC_VERSION };\n/** @internal */\nfunction newFromValue(registry, value, version) {\n  if (value instanceof GenericExtrinsic) {\n    return value.unwrap();\n  }\n  const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\n  const type = VERSIONS[version & UNMASK_VERSION] || VERSIONS[0];\n  // we cast here since the VERSION definition is incredibly broad - we don't have a\n  // slice for \"only add extrinsic types\", and more string definitions become unwieldy\n  return registry.createTypeUnsafe(type, [value, {\n    isSigned,\n    version\n  }]);\n}\n/** @internal */\nfunction decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {\n  if (isU8a(value) || Array.isArray(value) || isHex(value)) {\n    return decodeU8a(registry, u8aToU8a(value), version);\n  } else if (value instanceof registry.createClassUnsafe('Call')) {\n    return newFromValue(registry, {\n      method: value\n    }, version);\n  }\n  return newFromValue(registry, value, version);\n}\n/** @internal */\nfunction decodeU8a(registry, value, version) {\n  if (!value.length) {\n    return newFromValue(registry, new Uint8Array(), version);\n  }\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + length.toNumber();\n  if (total > value.length) {\n    throw new Error(`Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);\n  }\n  const data = value.subarray(offset, total);\n  return newFromValue(registry, data.subarray(1), data[0]);\n}\nclass ExtrinsicBase extends AbstractBase {\n  constructor(registry, value, initialU8aLength) {\n    super(registry, value, initialU8aLength);\n    const signKeys = Object.keys(registry.getSignedExtensionTypes());\n    const getter = key => this.inner.signature[key];\n    // This is on the abstract class, ensuring that hasOwnProperty operates\n    // correctly, i.e. it needs to be on the base class exposing it\n    for (let i = 0, count = signKeys.length; i < count; i++) {\n      objectProperty(this, signKeys[i], getter);\n    }\n  }\n  /**\n   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\n   */\n  get args() {\n    return this.method.args;\n  }\n  /**\n   * @description The argument definitions, compatible with [[Call]]\n   */\n  get argsDef() {\n    return this.method.argsDef;\n  }\n  /**\n   * @description The actual `[sectionIndex, methodIndex]` as used in the Call\n   */\n  get callIndex() {\n    return this.method.callIndex;\n  }\n  /**\n   * @description The actual data for the Call\n   */\n  get data() {\n    return this.method.data;\n  }\n  /**\n   * @description The era for this extrinsic\n   */\n  get era() {\n    return this.inner.signature.era;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description `true` id the extrinsic is signed\n   */\n  get isSigned() {\n    return this.inner.signature.isSigned;\n  }\n  /**\n   * @description The length of the actual data, excluding prefix\n   */\n  get length() {\n    return this.toU8a(true).length;\n  }\n  /**\n   * @description The [[FunctionMetadataLatest]] that describes the extrinsic\n   */\n  get meta() {\n    return this.method.meta;\n  }\n  /**\n   * @description The [[Call]] this extrinsic wraps\n   */\n  get method() {\n    return this.inner.method;\n  }\n  /**\n   * @description The nonce for this extrinsic\n   */\n  get nonce() {\n    return this.inner.signature.nonce;\n  }\n  /**\n   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]\n   */\n  get signature() {\n    return this.inner.signature.signature;\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n  get signer() {\n    return this.inner.signature.signer;\n  }\n  /**\n   * @description Forwards compat\n   */\n  get tip() {\n    return this.inner.signature.tip;\n  }\n  /**\n   * @description Forward compat\n   */\n  get assetId() {\n    return this.inner.signature.assetId;\n  }\n  /**\n   * @description Forward compat\n   */\n  get metadataHash() {\n    return this.inner.signature.metadataHash;\n  }\n  /**\n   * @description Forward compat\n   */\n  get mode() {\n    return this.inner.signature.mode;\n  }\n  /**\n   * @description Returns the raw transaction version (not flagged with signing information)\n  */\n  get type() {\n    return this.inner.version;\n  }\n  get inner() {\n    return this.unwrap();\n  }\n  /**\n   * @description Returns the encoded version flag\n  */\n  get version() {\n    return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\n  }\n  /**\n   * @description Checks if the source matches this in type\n   */\n  is(other) {\n    return this.method.is(other);\n  }\n  unwrap() {\n    return super.unwrap();\n  }\n}\n/**\n * @name GenericExtrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\nexport class GenericExtrinsic extends ExtrinsicBase {\n  __internal__hashCache;\n  static LATEST_EXTRINSIC_VERSION = LATEST_EXTRINSIC_VERSION;\n  constructor(registry, value, {\n    version\n  } = {}) {\n    super(registry, decodeExtrinsic(registry, value, version));\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    if (!this.__internal__hashCache) {\n      this.__internal__hashCache = super.hash;\n    }\n    return this.__internal__hashCache;\n  }\n  /**\n   * @description Injects an already-generated signature into the extrinsic\n   */\n  addSignature(signer, signature, payload) {\n    this.inner.addSignature(signer, signature, payload);\n    this.__internal__hashCache = undefined;\n    return this;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const encoded = u8aConcat(...this.toU8aInner());\n    return {\n      inner: this.isSigned ? this.inner.inspect().inner : this.inner.method.inspect().inner,\n      outer: [compactToU8a(encoded.length), new Uint8Array([this.version])]\n    };\n  }\n  /**\n   * @description Sign the extrinsic with a specific keypair\n   */\n  sign(account, options) {\n    this.inner.sign(account, options);\n    this.__internal__hashCache = undefined;\n    return this;\n  }\n  /**\n   * @describe Adds a fake signature to the extrinsic\n   */\n  signFake(signer, options) {\n    this.inner.signFake(signer, options);\n    this.__internal__hashCache = undefined;\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex(isBare) {\n    return u8aToHex(this.toU8a(isBare));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExpanded, disableAscii) {\n    return objectSpread({}, {\n      isSigned: this.isSigned,\n      method: this.method.toHuman(isExpanded, disableAscii)\n    }, this.isSigned ? {\n      assetId: this.assetId ? this.assetId.toHuman(isExpanded, disableAscii) : null,\n      era: this.era.toHuman(isExpanded, disableAscii),\n      metadataHash: this.metadataHash ? this.metadataHash.toHex() : null,\n      mode: this.mode ? this.mode.toHuman() : null,\n      nonce: this.nonce.toHuman(isExpanded, disableAscii),\n      signature: this.signature.toHex(),\n      signer: this.signer.toHuman(isExpanded, disableAscii),\n      tip: this.tip.toHuman(isExpanded, disableAscii)\n    } : null);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Extrinsic';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value is not length-prefixed\n   */\n  toU8a(isBare) {\n    const encoded = u8aConcat(...this.toU8aInner());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n  toU8aInner() {\n    // we do not apply bare to the internal values, rather this only determines out length addition,\n    // where we strip all lengths this creates an extrinsic that cannot be decoded\n    return [new Uint8Array([this.version]), this.inner.toU8a()];\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}