{"ast":null,"code":"import { identity, isCodec, isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\nimport { typeToConstructor } from '../utils/index.js';\nimport { Null } from './Null.js';\nclass None extends Null {\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'None';\n  }\n}\n/** @internal */\nfunction decodeOption(registry, Type, value) {\n  if (value instanceof Type) {\n    // don't re-create, use as it (which also caters for derived types)\n    return value;\n  } else if (value instanceof Option) {\n    if (value.value instanceof Type) {\n      // same instance, return it\n      return value.value;\n    } else if (value.isNone) {\n      // internal is None, we are also none\n      return new None(registry);\n    }\n    // convert the actual value into known\n    return new Type(registry, value.value);\n  } else if (isNull(value) || isUndefined(value) || value === '0x' || value instanceof None) {\n    // anything empty we pass as-is\n    return new None(registry);\n  } else if (isU8a(value)) {\n    // the isU8a check happens last in the if-tree - since the wrapped value\n    // may be an instance of it, so Type and Option checks go in first\n    return !value.length || value[0] === 0 ? new None(registry) : new Type(registry, value.subarray(1));\n  }\n  return new Type(registry, value);\n}\n/**\n * @name Option\n * @description\n * An Option is an optional field. Basically the first byte indicates that there is\n * is value to follow. If the byte is `1` there is an actual value. So the Option\n * implements that - decodes, checks for optionality and wraps the required structure\n * with a value if/as required/found.\n */\nexport class Option {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__Type;\n  __internal__raw;\n  constructor(registry, typeName, value, {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    const Type = definition || setDefinition(typeToConstructor(registry, typeName));\n    const decoded = isU8a(value) && value.length && !isCodec(value) ? value[0] === 0 ? new None(registry) : new Type(registry, value.subarray(1)) : decodeOption(registry, Type, value);\n    this.registry = registry;\n    this.__internal__Type = Type;\n    this.__internal__raw = decoded;\n    if (decoded?.initialU8aLength) {\n      this.initialU8aLength = 1 + decoded.initialU8aLength;\n    }\n  }\n  static with(Type) {\n    let definition;\n    const setDefinition = d => {\n      definition = d;\n      return d;\n    };\n    return class extends Option {\n      constructor(registry, value) {\n        super(registry, Type, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    // boolean byte (has value, doesn't have) along with wrapped length\n    return 1 + this.__internal__raw.encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n  get isEmpty() {\n    return this.isNone;\n  }\n  /**\n   * @description Checks if the Option has no value\n   */\n  get isNone() {\n    return this.__internal__raw instanceof None;\n  }\n  /**\n   * @description Checks if the Option has a value\n   */\n  get isSome() {\n    return !this.isNone;\n  }\n  /**\n   * @description The actual value for the Option\n   */\n  get value() {\n    return this.__internal__raw;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    if (other instanceof Option) {\n      return this.isSome === other.isSome && this.value.eq(other.value);\n    }\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    if (this.isNone) {\n      return {\n        outer: [new Uint8Array([0])]\n      };\n    }\n    const {\n      inner,\n      outer = []\n    } = this.__internal__raw.inspect();\n    return {\n      inner,\n      outer: [new Uint8Array([1]), ...outer]\n    };\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    // This attempts to align with the JSON encoding - actually in this case\n    // the isSome value is correct, however the `isNone` may be problematic\n    return this.isNone ? '0x' : u8aToHex(this.toU8a().subarray(1));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman(isExtended, disableAscii) {\n    return this.__internal__raw.toHuman(isExtended, disableAscii);\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.isNone ? null : this.__internal__raw.toJSON();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive(disableAscii) {\n    return this.isNone ? null : this.__internal__raw.toPrimitive(disableAscii);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType(isBare) {\n    const wrapped = this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType();\n    return isBare ? wrapped : `Option<${wrapped}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.__internal__raw.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    if (isBare) {\n      return this.__internal__raw.toU8a(true);\n    }\n    const u8a = new Uint8Array(this.encodedLength);\n    if (this.isSome) {\n      u8a.set([1]);\n      u8a.set(this.__internal__raw.toU8a(), 1);\n    }\n    return u8a;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available), throws if null\n   */\n  unwrap() {\n    if (this.isNone) {\n      throw new Error('Option: unwrapping a None value');\n    }\n    return this.__internal__raw;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n  unwrapOr(defaultValue) {\n    return this.isSome ? this.unwrap() : defaultValue;\n  }\n  /**\n   * @description Returns the value that the Option represents (if available) or defaultValue if none\n   * @param defaultValue The value to return if the option isNone\n   */\n  unwrapOrDefault() {\n    return this.isSome ? this.unwrap() : new this.__internal__Type(this.registry);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}