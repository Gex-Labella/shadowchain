{"ast":null,"code":"import { Option } from '../base/Option.js';\nimport { Tuple } from '../base/Tuple.js';\nimport { Vec } from '../base/Vec.js';\nimport { Struct } from '../native/Struct.js';\nconst EMPTY = new Uint8Array();\n/**\n * @name Linkage\n * @description The wrapper for the result from a LinkedMap\n */\nexport class Linkage extends Struct {\n  constructor(registry, Type, value) {\n    super(registry, {\n      previous: Option.with(Type),\n      // eslint-disable-next-line sort-keys\n      next: Option.with(Type)\n    }, value);\n  }\n  static withKey(Type) {\n    return class extends Linkage {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n    };\n  }\n  /**\n   * @description Returns the next item the Linkage is pointing to\n   */\n  get previous() {\n    return this.get('previous');\n  }\n  /**\n   * @description Returns the previous item the Linkage is pointing to\n   */\n  get next() {\n    return this.get('next');\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `Linkage<${this.next.toRawType(true)}>`;\n  }\n  /**\n   * @description Custom toU8a which with bare mode does not return the linkage if empty\n   */\n  toU8a(isBare) {\n    // As part of a storage query (where these appear), in the case of empty, the values\n    // are NOT populated by the node - follow the same logic, leaving it empty\n    return this.isEmpty ? EMPTY : super.toU8a(isBare);\n  }\n}\n/**\n * @name LinkageResult\n * @description A Linkage keys/Values tuple\n */\nexport class LinkageResult extends Tuple {\n  constructor(registry, [TypeKey, keys], [TypeValue, values]) {\n    super(registry, {\n      Keys: Vec.with(TypeKey),\n      Values: Vec.with(TypeValue)\n    }, [keys, values]);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}