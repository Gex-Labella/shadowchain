{"ast":null,"code":"import { combineLatest, map, of } from 'rxjs';\nimport { firstMemo, memo } from '../util/index.js';\nimport { erasHistoricApplyAccount } from './util.js';\nexport function _ownExposures(instanceId, api) {\n  return memo(instanceId, (accountId, eras, _withActive, page) => {\n    const emptyStakingExposure = api.registry.createType('Exposure');\n    // The reason we don't explicitly make the actual types is for compatibility. If the chain doesn't have the noted type it will fail\n    // on construction. Therefore we just make an empty option.\n    const emptyOptionPage = api.registry.createType('Option<Null>');\n    const emptyOptionMeta = api.registry.createType('Option<Null>');\n    return eras.length ? combineLatest([\n    // Backwards and forward compat for historical integrity when using `erasHistoricApplyAccount`\n    api.query.staking.erasStakersClipped ? combineLatest(eras.map(e => api.query.staking.erasStakersClipped(e, accountId))) : of(eras.map(_ => emptyStakingExposure)), api.query.staking.erasStakers ? combineLatest(eras.map(e => api.query.staking.erasStakers(e, accountId))) : of(eras.map(_ => emptyStakingExposure)), api.query.staking.erasStakersPaged ? combineLatest(eras.map(e => api.query.staking.erasStakersPaged(e, accountId, page))) : of(eras.map(_ => emptyOptionPage)), api.query.staking.erasStakersOverview ? combineLatest(eras.map(e => api.query.staking.erasStakersOverview(e, accountId))) : of(eras.map(_ => emptyOptionMeta))]).pipe(map(([clp, exp, paged, expMeta]) => eras.map((era, index) => ({\n      clipped: clp[index],\n      era,\n      exposure: exp[index],\n      exposureMeta: expMeta[index],\n      exposurePaged: paged[index]\n    })))) : of([]);\n  });\n}\nexport const ownExposure = /*#__PURE__*/firstMemo((api, accountId, era, page) => api.derive.staking._ownExposures(accountId, [era], true, page || 0));\nexport const ownExposures = /*#__PURE__*/erasHistoricApplyAccount('_ownExposures');","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}