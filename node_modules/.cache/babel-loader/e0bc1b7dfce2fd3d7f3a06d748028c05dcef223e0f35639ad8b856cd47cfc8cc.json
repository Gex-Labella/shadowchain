{"ast":null,"code":"import { compactAddLength, compactFromU8aLim, compactToU8a, hexToU8a, isHex, isString, isU8a, stringToU8a, u8aToHex, u8aToString } from '@polkadot/util';\nimport { Raw } from './Raw.js';\nconst MAX_LENGTH = 128 * 1024;\n/** @internal */\nfunction decodeText(value) {\n  if (isU8a(value)) {\n    if (!value.length) {\n      return ['', 0];\n    }\n    // for Raw, the internal buffer does not have an internal length\n    // (the same applies in e.g. Bytes, where length is added at encoding-time)\n    if (value instanceof Raw) {\n      return [u8aToString(value), 0];\n    }\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + length;\n    if (length > MAX_LENGTH) {\n      throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    } else if (total > value.length) {\n      throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [u8aToString(value.subarray(offset, total)), total];\n  } else if (isHex(value)) {\n    return [u8aToString(hexToU8a(value)), 0];\n  }\n  return [value ? value.toString() : '', 0];\n}\n/**\n * @name Text\n * @description\n * This is a string wrapper, along with the length. It is used both for strings as well\n * as items such as documentation. It simply extends the standard JS `String` built-in\n * object, inheriting all methods exposed from `String`.\n * @noInheritDoc\n */\nexport class Text extends String {\n  registry;\n  createdAtHash;\n  initialU8aLength;\n  isStorageFallback;\n  __internal__override = null;\n  constructor(registry, value) {\n    const [str, decodedLength] = decodeText(value);\n    super(str);\n    this.registry = registry;\n    this.initialU8aLength = decodedLength;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n  get isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * @description The length of the value\n   */\n  get length() {\n    // only included here since we ignore inherited docs\n    return super.length;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  eq(other) {\n    return isString(other) ? this.toString() === other.toString() : false;\n  }\n  /**\n   * @description Returns a breakdown of the hex encoding for this Codec\n   */\n  inspect() {\n    const value = stringToU8a(super.toString());\n    return {\n      outer: value.length ? [compactToU8a(value.length), value] : [compactToU8a(value.length)]\n    };\n  }\n  /**\n   * @description Set an override value for this\n   */\n  setOverride(override) {\n    this.__internal__override = override;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n  toHex() {\n    // like with Vec<u8>, when we are encoding to hex, we don't actually add\n    // the length prefix (it is already implied by the actual string length)\n    return u8aToHex(this.toU8a(true));\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n  toHuman() {\n    return this.toJSON();\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * @description Converts the value in a best-fit primitive form\n   */\n  toPrimitive() {\n    return this.toJSON();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return 'Text';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n  toString() {\n    return this.__internal__override || super.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  toU8a(isBare) {\n    // NOTE Here we use the super toString (we are not taking overrides into account,\n    // rather encoding the original value the string was constructed with)\n    const encoded = stringToU8a(super.toString());\n    return isBare ? encoded : compactAddLength(encoded);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}