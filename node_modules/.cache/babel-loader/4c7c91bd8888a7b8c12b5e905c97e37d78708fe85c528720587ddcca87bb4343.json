{"ast":null,"code":"import { BTreeMap, BTreeSet, Bytes, CodecSet, Compact, DoNotConstruct, Enum, HashMap, Int, Null, Option, Range, RangeInclusive, Result, Struct, Tuple, U8aFixed, UInt, Vec, VecFixed, WrapperKeepOpaque, WrapperOpaque } from '@polkadot/types-codec';\nimport { isNumber, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from '../types/index.js';\nimport { getTypeDef } from '../util/getTypeDef.js';\nfunction getTypeDefType({\n  lookupName,\n  type\n}) {\n  return lookupName || type;\n}\nfunction getSubDefArray(value) {\n  if (!Array.isArray(value.sub)) {\n    throw new Error(`Expected subtype as TypeDef[] in ${stringify(value)}`);\n  }\n  return value.sub;\n}\nfunction getSubDef(value) {\n  if (!value.sub || Array.isArray(value.sub)) {\n    throw new Error(`Expected subtype as TypeDef in ${stringify(value)}`);\n  }\n  return value.sub;\n}\nfunction getSubType(value) {\n  return getTypeDefType(getSubDef(value));\n}\nfunction getTypeClassMap(value) {\n  const subs = getSubDefArray(value);\n  const map = {};\n  for (let i = 0, count = subs.length; i < count; i++) {\n    const sub = subs[i];\n    if (!sub.name) {\n      throw new Error(`No name found in definition ${stringify(sub)}`);\n    }\n    map[sub.name] = getTypeDefType(sub);\n  }\n  return map;\n}\nfunction getTypeClassArray(value) {\n  return getSubDefArray(value).map(getTypeDefType);\n}\nfunction createInt(Clazz, {\n  displayName,\n  length\n}) {\n  if (!isNumber(length)) {\n    throw new Error(`Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);\n  }\n  return Clazz.with(length, displayName);\n}\nfunction createHashMap(Clazz, value) {\n  const [keyType, valueType] = getTypeClassArray(value);\n  return Clazz.with(keyType, valueType);\n}\nfunction createWithSub(Clazz, value) {\n  return Clazz.with(getSubType(value));\n}\nconst infoMapping = {\n  [TypeDefInfo.BTreeMap]: (_registry, value) => createHashMap(BTreeMap, value),\n  [TypeDefInfo.BTreeSet]: (_registry, value) => createWithSub(BTreeSet, value),\n  [TypeDefInfo.Compact]: (_registry, value) => createWithSub(Compact, value),\n  [TypeDefInfo.DoNotConstruct]: (_registry, value) => DoNotConstruct.with(value.displayName || value.type),\n  [TypeDefInfo.Enum]: (_registry, value) => {\n    const subs = getSubDefArray(value);\n    return Enum.with(subs.every(({\n      type\n    }) => type === 'Null') ? subs.reduce((out, {\n      index,\n      name\n    }, count) => {\n      if (!name) {\n        throw new Error('No name found in sub definition');\n      }\n      out[name] = index || count;\n      return out;\n    }, {}) : getTypeClassMap(value));\n  },\n  [TypeDefInfo.HashMap]: (_registry, value) => createHashMap(HashMap, value),\n  [TypeDefInfo.Int]: (_registry, value) => createInt(Int, value),\n  // We have circular deps between Linkage & Struct\n  [TypeDefInfo.Linkage]: (_registry, value) => {\n    const type = `Option<${getSubType(value)}>`;\n    // eslint-disable-next-line sort-keys\n    const Clazz = Struct.with({\n      previous: type,\n      next: type\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    Clazz.prototype.toRawType = function () {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n      return `Linkage<${this.next.toRawType(true)}>`;\n    };\n    return Clazz;\n  },\n  [TypeDefInfo.Null]: (_registry, _value) => Null,\n  [TypeDefInfo.Option]: (_registry, value) => {\n    if (!value.sub || Array.isArray(value.sub)) {\n      throw new Error('Expected type information for Option');\n    }\n    // NOTE This is opt-in (unhandled), not by default\n    // if (value.sub.type === 'bool') {\n    //   return OptionBool;\n    // }\n    return createWithSub(Option, value);\n  },\n  [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),\n  [TypeDefInfo.Range]: (_registry, value) => createWithSub(Range, value),\n  [TypeDefInfo.RangeInclusive]: (_registry, value) => createWithSub(RangeInclusive, value),\n  [TypeDefInfo.Result]: (_registry, value) => {\n    const [Ok, Err] = getTypeClassArray(value);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return Result.with({\n      Err,\n      Ok\n    });\n  },\n  [TypeDefInfo.Set]: (_registry, value) => CodecSet.with(getSubDefArray(value).reduce((result, {\n    index,\n    name\n  }) => {\n    if (!name || !isNumber(index)) {\n      throw new Error('No name found in sub definition');\n    }\n    result[name] = index;\n    return result;\n  }, {}), value.length),\n  [TypeDefInfo.Si]: (registry, value) => getTypeClass(registry, registry.lookup.getTypeDef(value.type)),\n  [TypeDefInfo.Struct]: (_registry, value) => Struct.with(getTypeClassMap(value), value.alias),\n  [TypeDefInfo.Tuple]: (_registry, value) => Tuple.with(getTypeClassArray(value)),\n  [TypeDefInfo.UInt]: (_registry, value) => createInt(UInt, value),\n  [TypeDefInfo.Vec]: (_registry, {\n    sub\n  }) => {\n    if (!sub || Array.isArray(sub)) {\n      throw new Error('Expected type information for vector');\n    }\n    return sub.type === 'u8' ? Bytes : Vec.with(getTypeDefType(sub));\n  },\n  [TypeDefInfo.VecFixed]: (_registry, {\n    displayName,\n    length,\n    sub\n  }) => {\n    if (!isNumber(length) || !sub || Array.isArray(sub)) {\n      throw new Error('Expected length & type information for fixed vector');\n    }\n    return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(getTypeDefType(sub), length);\n  },\n  [TypeDefInfo.WrapperKeepOpaque]: (_registry, value) => createWithSub(WrapperKeepOpaque, value),\n  [TypeDefInfo.WrapperOpaque]: (_registry, value) => createWithSub(WrapperOpaque, value)\n};\nexport function constructTypeClass(registry, typeDef) {\n  try {\n    const Type = infoMapping[typeDef.info](registry, typeDef);\n    if (!Type) {\n      throw new Error('No class created');\n    }\n    // don't clobber any existing\n    if (!Type.__fallbackType && typeDef.fallbackType) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore ...this is the only place we we actually assign this...\n      Type.__fallbackType = typeDef.fallbackType;\n    }\n    return Type;\n  } catch (error) {\n    throw new Error(`Unable to construct class from ${stringify(typeDef)}: ${error.message}`);\n  }\n}\nexport function getTypeClass(registry, typeDef) {\n  return registry.getUnsafe(typeDef.type, false, typeDef);\n}\nexport function createClassUnsafe(registry, type) {\n  return (\n    // just retrieve via name, no creation via typeDef\n    registry.getUnsafe(type) ||\n    // we don't have an existing type, create the class via typeDef\n    getTypeClass(registry, registry.isLookupType(type) ? registry.lookup.getTypeDef(type) : getTypeDef(type))\n  );\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}