{"ast":null,"code":"import { compactFromU8aLim, identity, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 512 * 1024;\nconst l = logger('Vec');\nfunction decodeVecLength(value) {\n  if (Array.isArray(value)) {\n    return [value, value.length, 0];\n  } else if (isU8a(value) || isHex(value)) {\n    const u8a = u8aToU8a(value);\n    const [startAt, length] = compactFromU8aLim(u8a);\n    if (length > MAX_LENGTH) {\n      throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    }\n    return [u8a, length, startAt];\n  } else if (!value) {\n    return [null, 0, 0];\n  }\n  throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n  if (Array.isArray(value)) {\n    const count = result.length;\n    for (let i = 0; i < count; i++) {\n      // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const entry = value[i];\n      try {\n        result[i] = entry instanceof Type ? entry : new Type(registry, entry);\n      } catch (error) {\n        l.error(`Unable to decode on index ${i}`, error.message);\n        throw error;\n      }\n    }\n    return [0, 0];\n  } else if (!value) {\n    return [0, 0];\n  }\n  // we don't need more checks, we already limited it via the length decoding\n  return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n  __internal__Type;\n  constructor(registry, Type, value = [], {\n    definition,\n    setDefinition = identity\n  } = {}) {\n    const [decodeFrom, length, startAt] = decodeVecLength(value);\n    super(registry, length);\n    this.__internal__Type = definition || setDefinition(typeToConstructor(registry, Type));\n    this.initialU8aLength = (isU8a(decodeFrom) ? decodeU8aVec(registry, this, decodeFrom, startAt, this.__internal__Type) : decodeVec(registry, this, decodeFrom, startAt, this.__internal__Type))[0];\n  }\n  static with(Type) {\n    let definition;\n    // eslint-disable-next-line no-return-assign\n    const setDefinition = d => definition = d;\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value, {\n          definition,\n          setDefinition\n        });\n      }\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n  get Type() {\n    return this.__internal__Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n  indexOf(other) {\n    // convert type first, this removes overhead from the eq\n    const check = other instanceof this.__internal__Type ? other : new this.__internal__Type(this.registry, other);\n    for (let i = 0, count = this.length; i < count; i++) {\n      if (check.eq(this[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n  toRawType() {\n    return `Vec<${this.registry.getClassName(this.__internal__Type) || new this.__internal__Type(this.registry).toRawType()}>`;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}