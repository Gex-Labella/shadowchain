{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, noop, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'], ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'], ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'], ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'], ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'], ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'], ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'], ['subscribe_newHead', 'unsubscribe_newHead'], ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'], ['state_subscribeStorage', 'state_unsubscribeStorage']]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n  __internal__Sc;\n  __internal__coder = new RpcCoder();\n  __internal__spec;\n  __internal__sharedSandbox;\n  __internal__subscriptions = new Map();\n  __internal__resubscribeMethods = new Map();\n  __internal__requests = new Map();\n  __internal__wellKnownChains;\n  __internal__eventemitter = new EventEmitter();\n  __internal__chain = null;\n  __internal__isChainReady = false;\n  constructor(Sc, spec, sharedSandbox) {\n    if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n      throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n    }\n    this.__internal__Sc = Sc;\n    this.__internal__spec = spec;\n    this.__internal__sharedSandbox = sharedSandbox;\n    this.__internal__wellKnownChains = new Set(Object.values(Sc.WellKnownChain));\n  }\n  get hasSubscriptions() {\n    // Indicates that subscriptions are supported\n    return !!true;\n  }\n  get isClonable() {\n    return !!false;\n  }\n  get isConnected() {\n    return !!this.__internal__chain && this.__internal__isChainReady;\n  }\n  clone() {\n    throw new Error('clone() is not supported.');\n  }\n  // Config details can be found in @substrate/connect repo following the link:\n  // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n  async connect(config, checkerFactory = healthChecker) {\n    if (this.isConnected) {\n      throw new Error('Already connected!');\n    }\n    // it could happen that after emitting `disconnected` due to the fact that\n    // smoldot is syncing, the consumer tries to reconnect after a certain amount\n    // of time... In which case we want to make sure that we don't create a new\n    // chain.\n    if (this.__internal__chain) {\n      await this.__internal__chain;\n      return;\n    }\n    if (this.__internal__sharedSandbox && !this.__internal__sharedSandbox.isConnected) {\n      await this.__internal__sharedSandbox.connect();\n    }\n    const client = this.__internal__sharedSandbox ? scClients.get(this.__internal__sharedSandbox) : this.__internal__Sc.createScClient(config);\n    if (!client) {\n      throw new Error('Unknown ScProvider!');\n    }\n    scClients.set(this, client);\n    const hc = checkerFactory();\n    const onResponse = res => {\n      const hcRes = hc.responsePassThrough(res);\n      if (!hcRes) {\n        return;\n      }\n      const response = JSON.parse(hcRes);\n      let decodedResponse;\n      try {\n        decodedResponse = this.__internal__coder.decodeResponse(response);\n      } catch (e) {\n        decodedResponse = e;\n      }\n      // It's not a subscription message, but rather a standar RPC response\n      if (response.params?.subscription === undefined || !response.method) {\n        return this.__internal__requests.get(response.id)?.(decodedResponse);\n      }\n      // We are dealing with a subscription message\n      const subscriptionId = `${response.method}::${response.params.subscription}`;\n      const callback = this.__internal__subscriptions.get(subscriptionId)?.[0];\n      callback?.(decodedResponse);\n    };\n    const addChain = this.__internal__sharedSandbox ? async (...args) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const source = this.__internal__sharedSandbox;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return (await source.__internal__chain).addChain(...args);\n    } : this.__internal__wellKnownChains.has(this.__internal__spec) ? client.addWellKnownChain : client.addChain;\n    this.__internal__chain = addChain(this.__internal__spec, onResponse).then(chain => {\n      hc.setSendJsonRpc(chain.sendJsonRpc);\n      this.__internal__isChainReady = false;\n      const cleanup = () => {\n        // If there are any callbacks left, we have to reject/error them.\n        // Otherwise, that would cause a memory leak.\n        const disconnectionError = new Error('Disconnected');\n        this.__internal__requests.forEach(cb => cb(disconnectionError));\n        this.__internal__subscriptions.forEach(([cb]) => cb(disconnectionError));\n        this.__internal__subscriptions.clear();\n      };\n      const staleSubscriptions = [];\n      const killStaleSubscriptions = () => {\n        if (staleSubscriptions.length === 0) {\n          return;\n        }\n        const stale = staleSubscriptions.pop();\n        if (!stale) {\n          throw new Error('Unable to get stale subscription');\n        }\n        const {\n          id,\n          unsubscribeMethod\n        } = stale;\n        Promise.race([this.send(unsubscribeMethod, [id]).catch(noop), new Promise(resolve => setTimeout(resolve, 500))]).then(killStaleSubscriptions).catch(noop);\n      };\n      hc.start(health => {\n        const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n        // if it's the same as before, then nothing has changed and we are done\n        if (this.__internal__isChainReady === isReady) {\n          return;\n        }\n        this.__internal__isChainReady = isReady;\n        if (!isReady) {\n          // If we've reached this point, that means that the chain used to be \"ready\"\n          // and now we are about to emit `disconnected`.\n          //\n          // This will cause the PolkadotJs API think that the connection is\n          // actually dead. In reality the smoldot chain is not dead, of course.\n          // However, we have to cleanup all the existing callbacks because when\n          // the smoldot chain stops syncing, then we will emit `connected` and\n          // the PolkadotJs API will try to re-create the previous\n          // subscriptions and requests. Although, now is not a good moment\n          // to be sending unsubscription messages to the smoldot chain, we\n          // should wait until is no longer syncing to send the unsubscription\n          // messages from the stale subscriptions of the previous connection.\n          //\n          // That's why -before we perform the cleanup of `this.__internal__subscriptions`-\n          // we keep the necessary information that we will need later on to\n          // kill the stale subscriptions.\n          [...this.__internal__subscriptions.values()].forEach(s => {\n            staleSubscriptions.push(s[1]);\n          });\n          cleanup();\n          this.__internal__eventemitter.emit('disconnected');\n        } else {\n          killStaleSubscriptions();\n          this.__internal__eventemitter.emit('connected');\n          if (this.__internal__resubscribeMethods.size) {\n            this.__internal__resubscribe();\n          }\n        }\n      });\n      return objectSpread({}, chain, {\n        remove: () => {\n          hc.stop();\n          chain.remove();\n          cleanup();\n        },\n        sendJsonRpc: hc.sendJsonRpc.bind(hc)\n      });\n    });\n    try {\n      await this.__internal__chain;\n    } catch (e) {\n      this.__internal__chain = null;\n      this.__internal__eventemitter.emit('error', e);\n      throw e;\n    }\n  }\n  __internal__resubscribe = () => {\n    const promises = [];\n    this.__internal__resubscribeMethods.forEach(subDetails => {\n      // only re-create subscriptions which are not in author (only area where\n      // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n      // are not included (and will not be re-broadcast)\n      if (subDetails.type.startsWith('author_')) {\n        return;\n      }\n      try {\n        const promise = new Promise(resolve => {\n          this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch(error => console.log(error));\n          resolve();\n        });\n        promises.push(promise);\n      } catch (error) {\n        l.error(error);\n      }\n    });\n    Promise.all(promises).catch(err => l.log(err));\n  };\n  async disconnect() {\n    if (!this.__internal__chain) {\n      return;\n    }\n    const chain = await this.__internal__chain;\n    this.__internal__chain = null;\n    this.__internal__isChainReady = false;\n    try {\n      chain.remove();\n    } catch (_) {}\n    this.__internal__eventemitter.emit('disconnected');\n  }\n  on(type, sub) {\n    // It's possible. Although, quite unlikely, that by the time that polkadot\n    // subscribes to the `connected` event, the Provider is already connected.\n    // In that case, we must emit to let the consumer know that we are connected.\n    if (type === 'connected' && this.isConnected) {\n      sub();\n    }\n    this.__internal__eventemitter.on(type, sub);\n    return () => {\n      this.__internal__eventemitter.removeListener(type, sub);\n    };\n  }\n  async send(method, params) {\n    if (!this.isConnected || !this.__internal__chain) {\n      throw new Error('Provider is not connected');\n    }\n    const chain = await this.__internal__chain;\n    const [id, json] = this.__internal__coder.encodeJson(method, params);\n    const result = new Promise((resolve, reject) => {\n      this.__internal__requests.set(id, response => {\n        (isError(response) ? reject : resolve)(response);\n      });\n      try {\n        chain.sendJsonRpc(json);\n      } catch (e) {\n        this.__internal__chain = null;\n        try {\n          chain.remove();\n        } catch (_) {}\n        this.__internal__eventemitter.emit('error', e);\n      }\n    });\n    try {\n      return await result;\n    } finally {\n      // let's ensure that once the Promise is resolved/rejected, then we remove\n      // remove its entry from the internal #requests\n      this.__internal__requests.delete(id);\n    }\n  }\n  async subscribe(type, method, params, callback) {\n    if (!subscriptionUnsubscriptionMethods.has(method)) {\n      throw new Error(`Unsupported subscribe method: ${method}`);\n    }\n    const id = await this.send(method, params);\n    const subscriptionId = `${type}::${id}`;\n    const cb = response => {\n      if (response instanceof Error) {\n        callback(response, undefined);\n      } else {\n        callback(null, response);\n      }\n    };\n    const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n    if (!unsubscribeMethod) {\n      throw new Error('Invalid unsubscribe method found');\n    }\n    this.__internal__resubscribeMethods.set(subscriptionId, {\n      callback,\n      method,\n      params,\n      type\n    });\n    this.__internal__subscriptions.set(subscriptionId, [cb, {\n      id,\n      unsubscribeMethod\n    }]);\n    return id;\n  }\n  unsubscribe(type, method, id) {\n    if (!this.isConnected) {\n      throw new Error('Provider is not connected');\n    }\n    const subscriptionId = `${type}::${id}`;\n    if (!this.__internal__subscriptions.has(subscriptionId)) {\n      return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n    }\n    this.__internal__resubscribeMethods.delete(subscriptionId);\n    this.__internal__subscriptions.delete(subscriptionId);\n    return this.send(method, [id]);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}